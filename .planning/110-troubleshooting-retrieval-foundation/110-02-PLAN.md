---
phase: 110-troubleshooting-retrieval-foundation
plan: 02
type: execute
wave: 2
depends_on: [110-01]
files_modified:
  - src/knowledge/thread-assembler.test.ts
  - src/knowledge/troubleshooting-retrieval.test.ts
autonomous: true
requirements: [TSHOOT-01, TSHOOT-02, TSHOOT-03]

must_haves:
  truths:
    - "Thread assembler unit tests verify truncation, tail selection, budget distribution, empty-comment edge case, and semantic fill"
    - "Integration tests verify state-filtered retrieval returns only closed issues"
    - "Integration tests verify similarity floor filters low-quality matches"
    - "Integration tests verify wiki fallback fires when no resolved issues match"
    - "Integration tests verify silent no-match returns null when nothing found"
    - "Integration tests verify PR records are excluded from results"
    - "Budget distribution tests confirm similarity-weighted allocation"
  artifacts:
    - path: "src/knowledge/thread-assembler.test.ts"
      provides: "Unit tests for truncateIssueBody, selectTailComments, computeBudgetDistribution, assembleIssueThread"
      min_lines: 100
    - path: "src/knowledge/troubleshooting-retrieval.test.ts"
      provides: "Integration tests for retrieveTroubleshootingContext with mock stores"
      min_lines: 150
  key_links:
    - from: "src/knowledge/thread-assembler.test.ts"
      to: "src/knowledge/thread-assembler.ts"
      via: "imports truncateIssueBody, selectTailComments, computeBudgetDistribution, assembleIssueThread"
      pattern: "from.*thread-assembler"
    - from: "src/knowledge/troubleshooting-retrieval.test.ts"
      to: "src/knowledge/troubleshooting-retrieval.ts"
      via: "imports retrieveTroubleshootingContext, extractKeywords"
      pattern: "from.*troubleshooting-retrieval"
---

<objective>
Comprehensive test coverage for the thread assembler and troubleshooting retrieval pipeline, verifying state filtering, budget enforcement, wiki fallback, and silent no-match behavior.

Purpose: The thread assembler has nuanced budget logic (tail-first, semantic fill, similarity-weighted distribution) and the orchestrator has a multi-step fallback chain. Tests lock down correctness before Phase 111 builds on top.

Output: Two test files covering unit-level thread assembly functions and integration-level retrieval pipeline behavior.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v0.23-ROADMAP.md
@.planning/110-troubleshooting-retrieval-foundation/110-CONTEXT.md
@.planning/110-troubleshooting-retrieval-foundation/110-RESEARCH.md
@.planning/110-troubleshooting-retrieval-foundation/110-01-SUMMARY.md

@src/knowledge/thread-assembler.ts
@src/knowledge/troubleshooting-retrieval.ts
@src/knowledge/issue-types.ts
@src/knowledge/issue-store.test.ts
@src/knowledge/wiki-retrieval.ts

<interfaces>
<!-- Key types from 110-01. Executor should read the actual files. -->

From src/knowledge/thread-assembler.ts (created in 110-01):
```typescript
export type ThreadAssemblyResult = {
  issueNumber: number;
  title: string;
  body: string;
  tailComments: string[];
  semanticComments: string[];
  totalChars: number;
};

export function truncateIssueBody(body: string, maxChars?: number): string;
export function selectTailComments(
  comments: IssueCommentRecord[],
  charBudget: number,
): { selected: IssueCommentRecord[]; remaining: IssueCommentRecord[]; charsUsed: number };
export function computeBudgetDistribution(
  matches: Array<{ distance: number }>,
  totalBudget: number,
): number[];
export function assembleIssueThread(params: {
  issueStore: IssueStore;
  embeddingProvider: EmbeddingProvider;
  repo: string;
  issueNumber: number;
  queryEmbedding: Float32Array;
  charBudget: number;
  logger: Logger;
}): Promise<ThreadAssemblyResult>;
```

From src/knowledge/troubleshooting-retrieval.ts (created in 110-01):
```typescript
export type TroubleshootingConfig = {
  enabled: boolean;
  similarityThreshold: number;
  maxResults: number;
  totalBudgetChars: number;
};

export type TroubleshootingResult = {
  matches: TroubleshootingMatch[];
  wikiResults: WikiKnowledgeMatch[];
  source: "issues" | "wiki" | "both";
};

export function retrieveTroubleshootingContext(params: {
  issueStore: IssueStore;
  wikiPageStore?: WikiPageStore;
  embeddingProvider: EmbeddingProvider;
  repo: string;
  queryTitle: string;
  queryBody: string | null;
  config: TroubleshootingConfig;
  logger: Logger;
}): Promise<TroubleshootingResult | null>;

export function extractKeywords(title: string, body: string | null): string;
```

From src/knowledge/issue-store.test.ts (test patterns):
```typescript
const mockLogger = {
  info: () => {}, warn: () => {}, error: () => {}, debug: () => {},
  trace: () => {}, fatal: () => {}, child: () => mockLogger, level: "silent",
} as unknown as import("pino").Logger;

function makeEmbedding(seed: number = 42): Float32Array { /* ... */ }
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Thread assembler unit tests</name>
  <files>src/knowledge/thread-assembler.test.ts</files>
  <action>
Create `src/knowledge/thread-assembler.test.ts` using `bun:test` (describe/test/expect pattern from issue-store.test.ts).

Import `truncateIssueBody`, `selectTailComments`, `computeBudgetDistribution`, `assembleIssueThread` from `./thread-assembler.ts`.

Reuse `mockLogger` pattern from `issue-store.test.ts`.

**describe("truncateIssueBody")**:

1. **"returns short body unchanged"** -- body under 500 chars returned as-is
2. **"truncates long body to first and last paragraph"** -- body with 4+ paragraphs separated by `\n\n`, verify result contains first paragraph, `[...]`, last paragraph
3. **"hard truncates when only 1-2 paragraphs"** -- single long paragraph gets `body.slice(0, 500) + "..."`
4. **"handles empty body"** -- empty string returns empty string
5. **"respects custom maxChars"** -- pass maxChars=200, verify truncation at that threshold

**describe("selectTailComments")**:

Create mock `IssueCommentRecord[]` helper. 5 comments with bodies of 100, 200, 300, 150, 250 chars.

1. **"selects last comments within budget"** -- budget 500: should select last 2 comments (250+150=400), not 3rd-from-last (400+300>500)
2. **"returns all comments if budget allows"** -- budget 5000: all 5 selected
3. **"returns empty when budget is 0"** -- budget 0: no comments selected
4. **"handles empty comments array"** -- empty input returns empty selected, empty remaining
5. **"maintains chronological order"** -- selected comments are in original order, not reversed
6. **"remaining excludes selected"** -- remaining has the comments not in selected

**describe("computeBudgetDistribution")**:

1. **"returns empty for no matches"** -- [] input returns []
2. **"returns full budget for single match"** -- 1 match gets totalBudget
3. **"distributes proportionally by similarity"** -- 2 matches at distance 0.2 and 0.4 (similarity 0.8 and 0.6). Total sim 1.4. First gets floor(0.8/1.4 * 12000), second gets floor(0.6/1.4 * 12000)
4. **"handles equal distances"** -- 3 matches all at distance 0.3: each gets floor(12000/3)

**describe("assembleIssueThread")**:

Create mock IssueStore with:
- `getByNumber`: returns a mock issue record
- `getCommentsByIssue`: returns mock comments
- `searchCommentsByEmbedding`: returns mock results matching some comments

Create mock EmbeddingProvider with `generate` returning a fixed Float32Array.

1. **"assembles thread with tail + semantic comments"** -- verify result has truncated body, tail comments from end, semantic comments from similarity search
2. **"handles issue with no comments"** -- zero comments, result has empty tailComments and semanticComments, body is present
3. **"handles issue with body exceeding 500 chars"** -- long body is truncated via truncateIssueBody
4. **"respects character budget"** -- total chars of body + tail + semantic does not exceed budget
  </action>
  <verify>bun test src/knowledge/thread-assembler.test.ts</verify>
  <done>
    All thread assembler tests pass: truncateIssueBody (5 cases), selectTailComments (6 cases), computeBudgetDistribution (4 cases), assembleIssueThread (4 cases).
    Tests use mock IssueStore and mock EmbeddingProvider -- no DB required.
  </done>
</task>

<task type="auto">
  <name>Task 2: Troubleshooting retrieval integration tests</name>
  <files>src/knowledge/troubleshooting-retrieval.test.ts</files>
  <action>
Create `src/knowledge/troubleshooting-retrieval.test.ts` using `bun:test`.

Import `retrieveTroubleshootingContext`, `extractKeywords` from `./troubleshooting-retrieval.ts`.

Build mock infrastructure:

**Mock IssueStore**: Implement all methods. Key behavior:
- `searchByEmbedding`: returns configurable results based on `stateFilter` param. When `stateFilter === 'closed'`, returns only closed issues. When no stateFilter, returns all.
- `searchByFullText`: same stateFilter behavior.
- `getByNumber`: returns issue records for known issue numbers.
- `getCommentsByIssue`: returns comment arrays per issue number.
- `searchCommentsByEmbedding`: returns mock comment search results.

**Mock WikiPageStore**: minimal object satisfying WikiPageStore type.

**Mock EmbeddingProvider**: `generate` returns a fixed Float32Array embedding (use makeEmbedding helper). Use deterministic seed.

**Default TroubleshootingConfig**:
```typescript
const defaultConfig: TroubleshootingConfig = {
  enabled: true,
  similarityThreshold: 0.65,
  maxResults: 3,
  totalBudgetChars: 12000,
};
```

**describe("extractKeywords")**:

1. **"extracts quoted error messages"** -- body containing `"TypeError: Cannot read property 'x'"` should include that text
2. **"extracts component-like names"** -- title "VideoPlayer crashes on HDR" extracts "VideoPlayer" and "HDR"
3. **"returns title when body is null"** -- null body, result includes title words
4. **"handles empty strings"** -- empty title and body returns empty or minimal string

**describe("retrieveTroubleshootingContext")**:

1. **"returns resolved issue matches with assembled threads"** -- mock store returns 2 closed issues with low distance (high similarity). Verify result has `source: "issues"`, matches array length 2, each match has title, body, tailComments.

2. **"filters by state='closed' -- only closed issues returned"** -- mock store has both open and closed issues in searchByEmbedding results (mock checks stateFilter param was 'closed'). Verify the stateFilter was passed through by asserting mock was called with correct params.

3. **"applies similarity floor"** -- mock returns 3 results: distances 0.2 (sim 0.8), 0.3 (sim 0.7), 0.5 (sim 0.5). Config threshold 0.65 means maxDistance 0.35. Only first 2 should pass (distance <= 0.35). Verify result.matches.length === 2.

4. **"excludes pull request records"** -- mock returns a closed issue with `isPullRequest: true`. Verify it is excluded from results.

5. **"respects maxResults config"** -- mock returns 5 valid closed issues. Config maxResults=2. Verify result.matches.length === 2.

6. **"falls back to wiki when no resolved issues match"** -- mock issueStore returns no results (or all above threshold). Mock wikiPageStore configured. Mock `searchWikiPages` behavior by having wikiPageStore return results. Verify result has `source: "wiki"` and wikiResults populated.

   For this test: since `searchWikiPages` is an imported function, not a method on the store, the mock approach should use a wikiPageStore whose `searchByEmbedding` returns results. Alternatively, mock at the module level if needed. Simplest: have the mock issueStore return empty results for closed state, and provide a wikiPageStore. The `searchWikiPages` function will call `store.searchByEmbedding` on the wiki store, so mock that method to return wiki page results.

7. **"returns null when both issues and wiki return nothing"** -- mock issueStore returns empty, mock wikiPageStore searchByEmbedding returns empty. Verify result is null.

8. **"returns null when embedding generation fails"** -- mock embeddingProvider.generate returns null. Verify result is null (fail-open).

9. **"budget is distributed by similarity weight"** -- mock returns 2 issues at different distances. Verify that the first (closer) match has more content (larger budget) than the second. This is an indirect test: check that the first match's `totalChars` is >= second match's `totalChars`.

10. **"wiki fallback uses dual query (original + keywords)"** -- Track calls to wiki search. Verify at least 2 wiki search calls are made (one with original query, one with extracted keywords). Use a spy/counter on the mock wikiPageStore.
  </action>
  <verify>bun test src/knowledge/troubleshooting-retrieval.test.ts</verify>
  <done>
    All troubleshooting retrieval tests pass: extractKeywords (4 cases), retrieveTroubleshootingContext (10 cases).
    Tests verify state filtering, similarity floor, PR exclusion, maxResults, wiki fallback, silent no-match, fail-open embedding, budget weighting, and dual wiki query.
    All tests use mock stores -- no DB required.
  </done>
</task>

</tasks>

<verification>
1. `bun test src/knowledge/thread-assembler.test.ts` -- all tests pass
2. `bun test src/knowledge/troubleshooting-retrieval.test.ts` -- all tests pass
3. `bun test src/knowledge/issue-store.test.ts` -- existing tests still pass (backward compat)
4. Combined: `bun test src/knowledge/` -- all knowledge tests pass
</verification>

<success_criteria>
- thread-assembler.test.ts has 19+ test cases covering all exported functions including edge cases
- troubleshooting-retrieval.test.ts has 14+ test cases covering the full retrieval pipeline
- All tests use mock stores (no database dependency)
- State filtering verified: stateFilter='closed' is passed to IssueStore search methods
- Similarity floor verified: distance > (1 - threshold) results are excluded
- PR filter verified: isPullRequest=true records are excluded
- Wiki fallback verified: fires when no issue matches, uses dual query
- Silent no-match verified: returns null when both sources empty
- Budget distribution verified: similarity-weighted allocation
- Existing issue-store.test.ts tests still pass
</success_criteria>

<output>
After completion, create `.planning/110-troubleshooting-retrieval-foundation/110-02-SUMMARY.md`
</output>
