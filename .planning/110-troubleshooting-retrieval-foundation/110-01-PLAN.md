---
phase: 110-troubleshooting-retrieval-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/knowledge/issue-types.ts
  - src/knowledge/issue-store.ts
  - src/knowledge/issue-retrieval.ts
  - src/knowledge/thread-assembler.ts
  - src/knowledge/troubleshooting-retrieval.ts
  - src/execution/config.ts
  - src/knowledge/index.ts
autonomous: true
requirements: [TSHOOT-01, TSHOOT-02, TSHOOT-03]

must_haves:
  truths:
    - "searchByEmbedding and searchByFullText accept optional stateFilter and return only matching-state issues when provided"
    - "Thread assembler produces resolution-focused context with tail comments guaranteed, semantic fill for remaining budget"
    - "Budget is distributed across matches weighted by similarity score"
    - "Bodies over 500 chars are truncated to first paragraph + last paragraph"
    - "When no resolved issues pass similarity floor, wiki fallback runs with dual query (original + keywords)"
    - "When both resolved issues and wiki return nothing, the function returns null (silent no-match)"
    - "Troubleshooting config is available as triage.troubleshooting sub-object with enabled, similarityThreshold, maxResults, totalBudgetChars"
  artifacts:
    - path: "src/knowledge/issue-types.ts"
      provides: "Extended IssueStore interface with stateFilter param on search methods"
      contains: "stateFilter"
    - path: "src/knowledge/issue-store.ts"
      provides: "SQL queries with conditional WHERE state clause"
      contains: "stateFilter"
    - path: "src/knowledge/thread-assembler.ts"
      provides: "truncateIssueBody, selectTailComments, selectSemanticComments, computeBudgetDistribution, assembleIssueThread"
      exports: ["truncateIssueBody", "selectTailComments", "computeBudgetDistribution", "assembleIssueThread"]
    - path: "src/knowledge/troubleshooting-retrieval.ts"
      provides: "retrieveTroubleshootingContext orchestrator with hybrid search, thread assembly, wiki fallback"
      exports: ["retrieveTroubleshootingContext", "TroubleshootingResult", "TroubleshootingConfig"]
    - path: "src/execution/config.ts"
      provides: "troubleshooting sub-object in triageSchema"
      contains: "troubleshooting"
    - path: "src/knowledge/index.ts"
      provides: "Re-exports for thread-assembler and troubleshooting-retrieval"
  key_links:
    - from: "src/knowledge/issue-store.ts"
      to: "src/knowledge/issue-types.ts"
      via: "stateFilter param on searchByEmbedding/searchByFullText"
      pattern: "stateFilter.*sql.*AND state"
    - from: "src/knowledge/thread-assembler.ts"
      to: "src/knowledge/issue-types.ts"
      via: "IssueStore.getCommentsByIssue() and searchCommentsByEmbedding()"
      pattern: "getCommentsByIssue|searchCommentsByEmbedding"
    - from: "src/knowledge/troubleshooting-retrieval.ts"
      to: "src/knowledge/thread-assembler.ts"
      via: "assembleIssueThread() call for each match"
      pattern: "assembleIssueThread"
    - from: "src/knowledge/troubleshooting-retrieval.ts"
      to: "src/knowledge/wiki-retrieval.ts"
      via: "searchWikiPages() fallback when no resolved issues found"
      pattern: "searchWikiPages"
    - from: "src/knowledge/troubleshooting-retrieval.ts"
      to: "src/knowledge/hybrid-search.ts"
      via: "hybridSearchMerge() for vector + BM25 issue results"
      pattern: "hybridSearchMerge"
---

<objective>
Extend IssueStore with state-filtered search, build a resolution-focused thread assembler, and create the troubleshooting retrieval orchestrator with wiki fallback and silent no-match.

Purpose: Phase 111 (troubleshooting agent) needs to retrieve similar resolved issues and assemble their resolution context. This plan provides the entire retrieval foundation: filtered search, thread assembly with budget management, and the fallback chain.

Output: Three new modules (thread-assembler.ts, troubleshooting-retrieval.ts) plus extensions to IssueStore, issue-store.ts, config.ts, and index.ts.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v0.23-ROADMAP.md
@.planning/110-troubleshooting-retrieval-foundation/110-CONTEXT.md
@.planning/110-troubleshooting-retrieval-foundation/110-RESEARCH.md

@src/knowledge/issue-types.ts
@src/knowledge/issue-store.ts
@src/knowledge/issue-retrieval.ts
@src/knowledge/wiki-retrieval.ts
@src/knowledge/hybrid-search.ts
@src/knowledge/retrieval.ts
@src/knowledge/issue-comment-chunker.ts
@src/execution/config.ts
@src/knowledge/index.ts

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/knowledge/issue-types.ts:
```typescript
export type IssueRecord = {
  id: number;
  repo: string;
  issueNumber: number;
  title: string;
  body: string | null;
  state: string;
  isPullRequest: boolean;
  locked: boolean;
  closedAt: string | null;
  // ... other fields
};

export type IssueSearchResult = {
  record: IssueRecord;
  distance: number;
};

export type IssueCommentRecord = {
  id: number;
  repo: string;
  issueNumber: number;
  commentGithubId: number;
  authorLogin: string;
  body: string;
  embedding: unknown;
  githubCreatedAt: string;
  // ... other fields
};

export type IssueCommentSearchResult = {
  record: IssueCommentRecord;
  distance: number;
};

export type IssueStore = {
  searchByEmbedding(params: {
    queryEmbedding: Float32Array;
    repo: string;
    topK: number;
  }): Promise<IssueSearchResult[]>;

  searchByFullText(params: {
    query: string;
    repo: string;
    topK: number;
  }): Promise<IssueSearchResult[]>;

  getByNumber(repo: string, issueNumber: number): Promise<IssueRecord | null>;

  getCommentsByIssue(repo: string, issueNumber: number): Promise<IssueCommentRecord[]>;

  searchCommentsByEmbedding(params: {
    queryEmbedding: Float32Array;
    repo: string;
    topK: number;
  }): Promise<IssueCommentSearchResult[]>;
};
```

From src/knowledge/wiki-retrieval.ts:
```typescript
export type WikiKnowledgeMatch = {
  chunkText: string;
  rawText: string;
  distance: number;
  pageId: number;
  pageTitle: string;
  pageUrl: string;
  source: "wiki";
  // ... other fields
};

export async function searchWikiPages(opts: {
  store: WikiPageStore;
  embeddingProvider: EmbeddingProvider;
  query: string;
  topK: number;
  namespace?: string;
  distanceThreshold?: number;
  logger: Logger;
}): Promise<WikiKnowledgeMatch[]>;
```

From src/knowledge/hybrid-search.ts:
```typescript
export function hybridSearchMerge<T>(params: {
  vectorResults: T[];
  bm25Results: T[];
  getKey: (item: T) => string;
  k?: number;
  topK?: number;
}): HybridSearchResult<T>[];
```

From src/knowledge/issue-retrieval.ts:
```typescript
export type IssueKnowledgeMatch = {
  chunkText: string;
  distance: number;
  repo: string;
  issueNumber: number;
  title: string;
  state: string;
  authorLogin: string;
  githubCreatedAt: string;
  source: "issue";
};

export async function searchIssues(opts: {
  store: IssueStore;
  embeddingProvider: EmbeddingProvider;
  query: string;
  repo: string;
  topK: number;
  distanceThreshold?: number;
  logger: Logger;
}): Promise<IssueKnowledgeMatch[]>;
```

From src/execution/config.ts (triageSchema at line 460):
```typescript
const triageSchema = z.object({
  enabled: z.boolean().default(false),
  autoTriageOnOpen: z.boolean().default(false),
  duplicateThreshold: z.number().min(0).max(100).default(75),
  // ... other fields
  cooldownMinutes: z.number().min(0).max(1440).default(30),
});
```

From src/knowledge/wiki-types.ts:
```typescript
export type WikiPageStore = { /* ... */ };
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend IssueStore with stateFilter, add troubleshooting config, and create thread assembler</name>
  <files>src/knowledge/issue-types.ts, src/knowledge/issue-store.ts, src/knowledge/issue-retrieval.ts, src/execution/config.ts, src/knowledge/thread-assembler.ts</files>
  <action>
**1a. Extend IssueStore interface** in `src/knowledge/issue-types.ts`:

Add optional `stateFilter?: string` to both search method param objects:

```typescript
searchByEmbedding(params: {
  queryEmbedding: Float32Array;
  repo: string;
  topK: number;
  stateFilter?: string;   // NEW
}): Promise<IssueSearchResult[]>;

searchByFullText(params: {
  query: string;
  repo: string;
  topK: number;
  stateFilter?: string;   // NEW
}): Promise<IssueSearchResult[]>;
```

**1b. Extend SQL queries** in `src/knowledge/issue-store.ts`:

In `searchByEmbedding` (line ~190), add the stateFilter param and conditional WHERE clause:
- Add `stateFilter?: string` to the params object
- After the `AND embedding IS NOT NULL` line, add:
  ```
  ${params.stateFilter ? sql`AND state = ${params.stateFilter}` : sql``}
  ```

In `searchByFullText` (line ~213), same pattern:
- Add `stateFilter?: string` to the params object
- After the `AND search_tsv @@ ...` line, add:
  ```
  ${params.stateFilter ? sql`AND state = ${params.stateFilter}` : sql``}
  ```

**1c. Update searchIssues** in `src/knowledge/issue-retrieval.ts`:

Add optional `stateFilter?: string` to the `searchIssues` opts type. Pass it through to `store.searchByEmbedding()`:
```typescript
const searchResults = await store.searchByEmbedding({
  queryEmbedding: embedResult.embedding,
  repo,
  topK,
  stateFilter: opts.stateFilter,  // NEW: passthrough
});
```

**1d. Extend triageSchema** in `src/execution/config.ts`:

Add a `troubleshooting` sub-object to the existing `triageSchema` (inside the `z.object({` at line 460, before the closing `})`):

```typescript
troubleshooting: z.object({
  enabled: z.boolean().default(false),
  similarityThreshold: z.number().min(0).max(1).default(0.65),
  maxResults: z.number().min(1).max(10).default(3),
  totalBudgetChars: z.number().min(1000).max(50000).default(12000),
}).default({
  enabled: false,
  similarityThreshold: 0.65,
  maxResults: 3,
  totalBudgetChars: 12000,
}),
```

Also update the `.default({` block for triageSchema (around line 487) to include:
```typescript
troubleshooting: {
  enabled: false,
  similarityThreshold: 0.65,
  maxResults: 3,
  totalBudgetChars: 12000,
},
```

And update the section-fallback parse block for `triage` in `loadRepoConfig` (~line 786) -- the existing `triageResult = triageSchema.safeParse(obj.triage)` handles this automatically since it's nested in triageSchema.

**1e. Create `src/knowledge/thread-assembler.ts`** with these exports:

1. **`truncateIssueBody(body: string, maxChars?: number): string`**
   - Default maxChars = 500
   - If `body.length <= maxChars`, return body as-is
   - Split on `\n\n+`, filter empty
   - If <= 2 paragraphs, hard truncate: `body.slice(0, maxChars) + "..."`
   - Otherwise: `first + "\n\n[...]\n\n" + last`
   - If result still > maxChars * 1.5, hard truncate

2. **`selectTailComments(comments: IssueCommentRecord[], charBudget: number): { selected: IssueCommentRecord[]; remaining: IssueCommentRecord[]; charsUsed: number }`**
   - Comments arrive ordered by `github_created_at` ASC (from `getCommentsByIssue`)
   - Reverse to iterate latest first
   - Take comments from the end while `charsUsed + comment.body.length <= charBudget`
   - Return `selected` in chronological order (unshift), `remaining` as comments not selected, `charsUsed`

3. **`computeBudgetDistribution(matches: Array<{ distance: number }>, totalBudget: number): number[]`**
   - If 0 matches: return []
   - If 1 match: return [totalBudget]
   - Convert distances to similarities: `1 - distance`
   - Sum similarities, proportionally allocate: `Math.floor((sim / totalSim) * totalBudget)`

4. **`assembleIssueThread(params: { issueStore: IssueStore; embeddingProvider: EmbeddingProvider; repo: string; issueNumber: number; queryEmbedding: Float32Array; charBudget: number; logger: Logger }): Promise<ThreadAssemblyResult>`**

   Type `ThreadAssemblyResult`:
   ```typescript
   export type ThreadAssemblyResult = {
     issueNumber: number;
     title: string;
     body: string;
     tailComments: string[];
     semanticComments: string[];
     totalChars: number;
   };
   ```

   Steps:
   a. Get issue record via `issueStore.getByNumber(repo, issueNumber)`. If null, throw.
   b. Truncate body via `truncateIssueBody(record.body ?? "")`
   c. Subtract body chars from budget: `remainingBudget = charBudget - body.length`
   d. Get all comments via `issueStore.getCommentsByIssue(repo, issueNumber)`
   e. If zero comments, return result with empty comment arrays
   f. Allocate ~60% of remaining budget to tail: `tailBudget = Math.floor(remainingBudget * 0.6)`
   g. Call `selectTailComments(comments, tailBudget)` to get tail selection
   h. Remaining budget after tail: `semanticBudget = remainingBudget - tailResult.charsUsed`
   i. If `tailResult.remaining.length > 0` and `semanticBudget > 0`:
      - Get comment embeddings by calling `issueStore.searchCommentsByEmbedding({ queryEmbedding, repo, topK: 20 })`
      - Filter to only comments in `remaining` set (by commentGithubId)
      - Sort by distance ascending (most similar first)
      - Take comments until semanticBudget exhausted
   j. Return `{ issueNumber, title: record.title, body, tailComments: tail.selected.map(c => c.body), semanticComments: semanticSelection.map(c => c.body), totalChars }`

Import types from `./issue-types.ts` and `./types.ts` (EmbeddingProvider).
  </action>
  <verify>
    bun build src/knowledge/thread-assembler.ts --no-bundle 2>&1 | head -10
    bun build src/knowledge/issue-store.ts --no-bundle 2>&1 | head -10
    bun build src/execution/config.ts --no-bundle 2>&1 | head -10
  </verify>
  <done>
    IssueStore interface has stateFilter on both search methods.
    issue-store.ts SQL queries conditionally filter by state.
    issue-retrieval.ts passes stateFilter through.
    triageSchema has troubleshooting sub-object with enabled, similarityThreshold, maxResults, totalBudgetChars.
    thread-assembler.ts exports truncateIssueBody, selectTailComments, computeBudgetDistribution, assembleIssueThread with ThreadAssemblyResult type.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create troubleshooting retrieval orchestrator with wiki fallback and update re-exports</name>
  <files>src/knowledge/troubleshooting-retrieval.ts, src/knowledge/index.ts</files>
  <action>
**2a. Create `src/knowledge/troubleshooting-retrieval.ts`**:

Define types:
```typescript
export type TroubleshootingConfig = {
  enabled: boolean;
  similarityThreshold: number;  // cosine similarity (0.65 default)
  maxResults: number;           // default 3
  totalBudgetChars: number;     // default 12000
};

export type TroubleshootingMatch = {
  issueNumber: number;
  title: string;
  body: string;           // truncated
  tailComments: string[];
  semanticComments: string[];
  similarity: number;     // cosine similarity (1 - distance)
  totalChars: number;
};

export type TroubleshootingResult = {
  matches: TroubleshootingMatch[];
  wikiResults: WikiKnowledgeMatch[];
  source: "issues" | "wiki" | "both";
};
```

Implement **`extractKeywords(title: string, body: string | null): string`**:
- Extract quoted strings (error messages) from body
- Extract capitalized words that look like component names (2+ consecutive caps-starting words)
- Extract words after "error:", "exception:", "crash" patterns
- Combine with title, deduplicate, join with spaces
- Keep it simple -- no LLM call, pure heuristic

Implement **`retrieveTroubleshootingContext(params: { ... }): Promise<TroubleshootingResult | null>`**:

Params:
```typescript
{
  issueStore: IssueStore;
  wikiPageStore?: WikiPageStore;
  embeddingProvider: EmbeddingProvider;
  repo: string;
  queryTitle: string;
  queryBody: string | null;
  config: TroubleshootingConfig;
  logger: Logger;
}
```

Steps:

1. **Generate query embedding**: `embeddingProvider.generate(queryTitle + "\n\n" + (queryBody ?? ""), "query")`. If null, log and return null (fail-open).

2. **Hybrid search with state='closed'**: Run vector and full-text in parallel:
   ```typescript
   const [vectorResults, fullTextResults] = await Promise.allSettled([
     params.issueStore.searchByEmbedding({
       queryEmbedding: embedding,
       repo: params.repo,
       topK: 10,
       stateFilter: "closed",
     }),
     params.issueStore.searchByFullText({
       query: params.queryTitle + " " + (params.queryBody ?? "").slice(0, 200),
       repo: params.repo,
       topK: 10,
       stateFilter: "closed",
     }),
   ]);
   ```

3. **Merge via hybridSearchMerge**: Use `hybridSearchMerge()` from `./hybrid-search.ts`:
   - `getKey: (r) => String(r.record.issueNumber)`
   - Extract settled results (fail-open: empty array on rejection)

4. **Apply similarity floor**: Convert config similarity to distance: `maxDistance = 1 - config.similarityThreshold`. Filter merged results to those with `vectorDistance <= maxDistance` (for items that appeared in vector results). For BM25-only items, include if their hybridScore is above median.

   Simpler approach: from the merged list, get the underlying `IssueSearchResult` items. For each, check if it appeared in vectorResults and if so whether `distance <= maxDistance`. BM25-only matches pass if they appeared in both lists (hybrid boost).

   Actually, simplest correct approach: take merged results sorted by hybridScore descending. For each, look up the original vector distance from vectorResults. If the item was in vector results, apply `distance <= maxDistance` filter. If the item was BM25-only (not in vector results), include it (BM25 match on a closed issue is still relevant).

5. **Post-filter PRs**: Remove items where `record.isPullRequest === true` (no merged_at column exists, so exclude all PRs per research recommendation).

6. **Apply maxResults**: Slice to `config.maxResults`.

7. **If matches found**:
   a. Compute budget distribution via `computeBudgetDistribution(matches, config.totalBudgetChars)`
   b. For each match, call `assembleIssueThread({ issueStore, embeddingProvider, repo, issueNumber, queryEmbedding: embedding, charBudget: budgets[i], logger })`
   c. Map to `TroubleshootingMatch[]`
   d. Return `{ matches, wikiResults: [], source: "issues" }`

8. **If no matches (wiki fallback)**:
   a. If `wikiPageStore` not available, return null (silent no-match)
   b. Build original query: `queryTitle + " " + (queryBody ?? "").slice(0, 500)`
   c. Build keyword query: `extractKeywords(queryTitle, queryBody)`
   d. Run both wiki searches in parallel via `Promise.allSettled()`:
      ```typescript
      searchWikiPages({ store: wikiPageStore, embeddingProvider, query: originalQuery, topK: 2, logger })
      searchWikiPages({ store: wikiPageStore, embeddingProvider, query: keywordQuery, topK: 2, logger })
      ```
   e. Merge results, deduplicate by `pageId`, keep top 2 sorted by distance ascending
   f. If wiki results empty, return null (silent no-match)
   g. Return `{ matches: [], wikiResults: deduped, source: "wiki" }`

Import: `Logger` from pino, `IssueStore`/`IssueSearchResult` from `./issue-types.ts`, `EmbeddingProvider` from `./types.ts`, `WikiPageStore` from `./wiki-types.ts`, `searchWikiPages`/`WikiKnowledgeMatch` from `./wiki-retrieval.ts`, `hybridSearchMerge` from `./hybrid-search.ts`, `assembleIssueThread`/`computeBudgetDistribution` from `./thread-assembler.ts`.

Export: `retrieveTroubleshootingContext`, `TroubleshootingResult`, `TroubleshootingConfig`, `TroubleshootingMatch`, `extractKeywords`.

**2b. Update `src/knowledge/index.ts`** -- add re-exports at the end:

```typescript
// Thread assembler
export {
  truncateIssueBody,
  selectTailComments,
  computeBudgetDistribution,
  assembleIssueThread,
  type ThreadAssemblyResult,
} from "./thread-assembler.ts";

// Troubleshooting retrieval
export {
  retrieveTroubleshootingContext,
  extractKeywords,
  type TroubleshootingResult,
  type TroubleshootingConfig,
  type TroubleshootingMatch,
} from "./troubleshooting-retrieval.ts";
```
  </action>
  <verify>
    bun build src/knowledge/troubleshooting-retrieval.ts --no-bundle 2>&1 | head -10
    bun build src/knowledge/index.ts --no-bundle 2>&1 | head -10
  </verify>
  <done>
    troubleshooting-retrieval.ts exports retrieveTroubleshootingContext with hybrid search (state='closed'), similarity floor conversion, PR post-filter, budget-weighted thread assembly, dual-query wiki fallback, and silent no-match.
    extractKeywords heuristic extracts error messages and component names without LLM.
    index.ts re-exports all new thread-assembler and troubleshooting-retrieval types and functions.
    Full pipeline: search closed issues -> filter by similarity -> assemble threads with tail+semantic -> fallback to wiki -> return null if nothing found.
  </done>
</task>

</tasks>

<verification>
1. `bun build src/knowledge/thread-assembler.ts --no-bundle` compiles clean
2. `bun build src/knowledge/troubleshooting-retrieval.ts --no-bundle` compiles clean
3. `bun build src/knowledge/index.ts --no-bundle` compiles clean
4. `bun build src/execution/config.ts --no-bundle` compiles clean
5. `bun test src/knowledge/issue-store.test.ts` still passes (stateFilter is optional, backward compatible)
6. Grep confirms stateFilter in issue-types.ts, issue-store.ts SQL, issue-retrieval.ts passthrough
7. Grep confirms troubleshooting in triageSchema
</verification>

<success_criteria>
- IssueStore.searchByEmbedding and searchByFullText accept stateFilter param
- issue-store.ts SQL conditionally adds `AND state = $stateFilter` WHERE clause
- thread-assembler.ts has truncateIssueBody, selectTailComments, computeBudgetDistribution, assembleIssueThread
- troubleshooting-retrieval.ts has retrieveTroubleshootingContext with hybrid search, similarity floor, PR filter, thread assembly, wiki fallback, silent no-match
- Config schema has triage.troubleshooting sub-object
- All new exports available from knowledge/index.ts
- Existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/110-troubleshooting-retrieval-foundation/110-01-SUMMARY.md`
</output>
