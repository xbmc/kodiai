---
phase: 91-cross-corpus-retrieval-integration
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/knowledge/hybrid-search.ts
  - src/knowledge/hybrid-search.test.ts
  - src/knowledge/review-comment-store.ts
  - src/knowledge/wiki-store.ts
  - src/knowledge/memory-store.ts
  - src/knowledge/review-comment-types.ts
  - src/knowledge/wiki-types.ts
  - src/knowledge/types.ts
autonomous: true
requirements: [KI-14]

must_haves:
  truths:
    - "Each corpus supports both vector and full-text search in a single call"
    - "Hybrid search combines vector cosine distance with tsvector ts_rank via RRF-style merge"
    - "Full-text search uses existing search_tsv columns with plainto_tsquery"
  artifacts:
    - path: "src/knowledge/hybrid-search.ts"
      provides: "Hybrid search combiner: merges vector + BM25 results per corpus"
      exports: ["hybridSearchMerge", "HybridSearchResult"]
    - path: "src/knowledge/hybrid-search.test.ts"
      provides: "Unit tests for hybrid search merge logic"
  key_links:
    - from: "src/knowledge/hybrid-search.ts"
      to: "review-comment-store.ts, wiki-store.ts, memory-store.ts"
      via: "stores provide dual result sets, hybrid-search merges them"
      pattern: "hybridSearchMerge"
---

<objective>
Add hybrid search (vector + BM25 full-text) capability to each knowledge corpus store.

Purpose: KI-14 requires combining pgvector semantic similarity with PostgreSQL tsvector full-text search per corpus. The tsvector columns and GIN indexes already exist on all three tables (learning_memories, review_comments, wiki_pages) from migrations 003, 005, and 006. This plan adds full-text search methods to each store and a hybrid merge function that combines vector and BM25 results using per-corpus RRF.

Output: Each store gains a `searchByFullText` method. A `hybridSearchMerge` function combines vector + BM25 ranked lists into a single scored list per corpus.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/91-cross-corpus-retrieval-integration/91-CONTEXT.md
@src/knowledge/memory-store.ts
@src/knowledge/review-comment-store.ts
@src/knowledge/wiki-store.ts
@src/knowledge/review-comment-types.ts
@src/knowledge/wiki-types.ts
@src/knowledge/types.ts
@src/db/migrations/003-tsvector-columns.sql
@src/db/migrations/005-review-comments.sql
@src/db/migrations/006-wiki-pages.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add full-text search methods to all three corpus stores</name>
  <files>
    src/knowledge/review-comment-store.ts
    src/knowledge/review-comment-types.ts
    src/knowledge/wiki-store.ts
    src/knowledge/wiki-types.ts
    src/knowledge/memory-store.ts
    src/knowledge/types.ts
  </files>
  <action>
Add a `searchByFullText` method to each store interface and implementation:

**ReviewCommentStore** (review-comment-types.ts interface, review-comment-store.ts impl):
```typescript
searchByFullText(params: {
  query: string;
  repo: string;
  topK: number;
}): Promise<ReviewCommentSearchResult[]>
```
SQL: `SELECT *, ts_rank(search_tsv, plainto_tsquery('english', $query)) AS rank FROM review_comments WHERE repo = $repo AND stale = false AND deleted = false AND search_tsv @@ plainto_tsquery('english', $query) ORDER BY rank DESC LIMIT $topK`
Map rank into the `distance` field as `1 - rank` (so lower = better, consistent with vector distance convention).

**WikiPageStore** (wiki-types.ts interface, wiki-store.ts impl):
```typescript
searchByFullText(params: {
  query: string;
  topK: number;
  namespace?: string;
}): Promise<WikiPageSearchResult[]>
```
Same pattern with optional namespace filter. Use `search_tsv @@ plainto_tsquery('english', $query)`.

**LearningMemoryStore** (types.ts interface, memory-store.ts impl):
```typescript
searchByFullText(params: {
  query: string;
  repo: string;
  topK: number;
}): Promise<{ memoryId: number; rank: number }[]>
```
SQL: `SELECT m.id AS memory_id, ts_rank(m.search_tsv, plainto_tsquery('english', $query)) AS rank FROM learning_memories m WHERE m.repo = $repo AND m.stale = false AND m.search_tsv @@ plainto_tsquery('english', $query) ORDER BY rank DESC LIMIT $topK`

For all stores: if the query is empty or the tsquery produces no matches, return empty array (graceful no-op).
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>Type interfaces match implementations, SQL uses search_tsv columns</manual>
  </verify>
  <done>All three stores have searchByFullText methods that query existing tsvector GIN indexes</done>
</task>

<task type="auto">
  <name>Task 2: Create hybrid search merge function with TDD</name>
  <files>
    src/knowledge/hybrid-search.ts
    src/knowledge/hybrid-search.test.ts
  </files>
  <action>
**RED phase first.** Create `src/knowledge/hybrid-search.test.ts` with tests for:

1. `hybridSearchMerge` with both vector and BM25 results â€” items in both lists get boosted score
2. Items only in vector list get vector-only score
3. Items only in BM25 list get BM25-only score
4. Empty inputs return empty output
5. Results sorted by hybrid score descending (best first)
6. Deduplication: same item appearing in both lists appears once in output
7. `topK` limit respected

Then **GREEN phase.** Create `src/knowledge/hybrid-search.ts`:

```typescript
export type HybridSearchResult<T> = {
  item: T;
  vectorRank: number | null;   // rank position in vector results (0-based)
  bm25Rank: number | null;     // rank position in BM25 results (0-based)
  hybridScore: number;         // RRF combined score
};

export function hybridSearchMerge<T>(params: {
  vectorResults: T[];           // sorted best-first (by distance asc)
  bm25Results: T[];             // sorted best-first (by rank desc)
  getKey: (item: T) => string;  // dedup key extractor
  k?: number;                   // RRF k parameter, default 60
  topK?: number;                // max results to return
}): HybridSearchResult<T>[]
```

Algorithm (standard RRF from Cormack, Clarke & Butt 2009):
- For each item in vectorResults at position i: `score += 1 / (k + i)`
- For each item in bm25Results at position j: `score += 1 / (k + j)`
- Items in both lists get summed scores
- Sort by hybridScore descending, return topK results

Use k=60 as default (per user decision in CONTEXT.md: "Standard RRF k-parameter of 60").

**REFACTOR phase:** Ensure types are generic so the same function works for all three corpus types.
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && npx vitest run src/knowledge/hybrid-search.test.ts 2>&1 | tail -20</automated>
  </verify>
  <done>hybridSearchMerge function passes all tests, combines vector + BM25 results via RRF with k=60</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes (no type errors)
- `npx vitest run src/knowledge/hybrid-search.test.ts` passes
- All three stores expose searchByFullText in their type interfaces
- hybridSearchMerge is generic and works with any item type + key extractor
</verification>

<success_criteria>
- KI-14 foundation: hybrid search combining vector + BM25 per corpus is implemented
- Each store has full-text search using existing tsvector GIN indexes
- RRF merge function combines ranked lists with k=60
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/91-cross-corpus-retrieval-integration/91-01-SUMMARY.md`
</output>
