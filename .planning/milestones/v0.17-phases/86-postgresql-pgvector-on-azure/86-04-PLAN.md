---
phase: 86-postgresql-pgvector-on-azure
plan: 04
type: execute
wave: 3
depends_on:
  - 86-02
  - 86-03
files_modified:
  - src/index.ts
  - scripts/migrate-sqlite-to-postgres.ts
  - Dockerfile
  - .github/workflows/ci.yml
  - package.json
autonomous: false
requirements:
  - DB-03
  - DB-05
  - DB-06
  - DB-07
user_setup:
  - service: azure-postgresql
    why: "Database must be provisioned before deploy"
    env_vars:
      - name: DATABASE_URL
        source: "Output of scripts/provision-postgres.sh or Azure Portal -> Connection strings"
    dashboard_config:
      - task: "Run provision-postgres.sh to create Flexible Server"
        location: "Terminal with Azure CLI authenticated"
      - task: "Add DATABASE_URL to Azure Container Apps secrets"
        location: "Azure Portal -> Container Apps -> Secrets"

must_haves:
  truths:
    - "Application boots and connects to PostgreSQL via DATABASE_URL"
    - "Existing SQLite data is migrated to PostgreSQL via migration script"
    - "CI runs tests against Dockerized PostgreSQL with pgvector"
    - "No bun:sqlite, sqlite-vec, or better-sqlite3 imports exist anywhere in src/"
    - "sqlite-vec removed from package.json dependencies"
    - "Dockerfile no longer creates /app/data for SQLite"
    - "Application works end-to-end on Azure after deploy"
  artifacts:
    - path: "scripts/migrate-sqlite-to-postgres.ts"
      provides: "One-time SQLite to PostgreSQL data migration"
    - path: "src/index.ts"
      provides: "Updated app bootstrap using postgres.js client"
    - path: ".github/workflows/ci.yml"
      provides: "CI with PostgreSQL service container"
    - path: "Dockerfile"
      provides: "Updated Docker image without SQLite data dir"
  key_links:
    - from: "src/index.ts"
      to: "src/db/client.ts"
      via: "createDbClient() at startup"
      pattern: "createDbClient"
    - from: "src/index.ts"
      to: "src/db/migrate.ts"
      via: "runMigrations() at startup"
      pattern: "runMigrations"
    - from: ".github/workflows/ci.yml"
      to: "docker-compose.yml"
      via: "PostgreSQL service in CI"
      pattern: "postgres"
---

<objective>
Wire everything together: update the application entry point to use PostgreSQL, create the SQLite-to-PostgreSQL migration script, update CI to test against PostgreSQL, remove all SQLite dependencies, update Dockerfile, and verify on Azure.

Purpose: Complete the infrastructure swap. After this plan, SQLite is fully gone and the application runs entirely on PostgreSQL.

Output: Working application on PostgreSQL, data migrated, CI green, SQLite dependencies removed.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/86-postgresql-pgvector-on-azure/86-01-SUMMARY.md
@.planning/phases/86-postgresql-pgvector-on-azure/86-02-SUMMARY.md
@.planning/phases/86-postgresql-pgvector-on-azure/86-03-SUMMARY.md
@src/index.ts
@src/db/client.ts
@src/db/migrate.ts
@Dockerfile
@.github/workflows/ci.yml
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update application entry point, create migration script, clean up SQLite</name>
  <files>
    src/index.ts
    scripts/migrate-sqlite-to-postgres.ts
    Dockerfile
    package.json
  </files>
  <action>
1. **Rewrite the database initialization section of `src/index.ts`**:
   - Remove `import { Database } from "bun:sqlite"`
   - Remove `import { resolveKnowledgeDbPath } from "./knowledge/db-path.ts"`
   - Add `import { createDbClient } from "./db/client.ts"`
   - Add `import { runMigrations } from "./db/migrate.ts"`
   - At startup (before creating stores):
     ```ts
     const { sql, close: closeDb } = createDbClient({ logger });
     await runMigrations(sql);
     ```
   - Pass `sql` to `createKnowledgeStore({ sql, logger })` instead of `{ dbPath, logger }`
   - Pass `sql` to `createTelemetryStore({ sql, logger, ... })` instead of `{ dbPath, logger, ... }`
   - Pass `sql` to `createLearningMemoryStore({ sql, logger })` instead of `{ db: learningDb, logger }`
   - Remove the separate `learningDb` Database instance creation
   - Remove the `resolveKnowledgeDbPath()` call
   - Remove the `telemetryDbPath` SQLite path resolution
   - Remove `TELEMETRY_DB_PATH` env var usage (no longer needed)
   - Remove `KNOWLEDGE_DB_PATH` env var usage (replaced by `DATABASE_URL`)
   - Remove the WAL checkpoint calls (`.checkpoint()`) -- PostgreSQL doesn't need them
   - Keep the embedding provider initialization unchanged
   - Keep all handler/route wiring unchanged
   - Update all callers of now-async store methods to use `await`

2. **Create `scripts/migrate-sqlite-to-postgres.ts`**:
   - A one-time migration script that reads from SQLite files and writes to PostgreSQL
   - Accept CLI args: `--knowledge-db <path>` (defaults to `./data/kodiai-knowledge.db`) and `--telemetry-db <path>` (defaults to `./data/kodiai-telemetry.db`)
   - Requires `DATABASE_URL` env var
   - Steps:
     a. Connect to PostgreSQL, run migrations to ensure schema exists
     b. Open SQLite knowledge DB with `bun:sqlite` (this is the ONLY remaining use of bun:sqlite, in a one-time script)
     c. Read all rows from each SQLite table, batch-insert into PostgreSQL using `sql.begin()` with chunks of 100 rows
     d. For `learning_memories` + `learning_memory_vec`: join the tables, extract embedding data, convert to pgvector format, insert as single rows in the new `learning_memories` table with vector column
     e. Open SQLite telemetry DB, repeat for telemetry tables
     f. Print row counts per table for verification
     g. Log success/failure
   - This script is explicitly a one-time tool, not part of the application runtime

3. **Update `Dockerfile`**:
   - Remove `RUN mkdir -p /app/data && chown bun:bun /app/data` (no more SQLite data directory)
   - Add `ENV DATABASE_URL=""` as documentation (actual value comes from Azure Container Apps secrets)
   - The rest stays the same (Bun image, git dependency, etc.)

4. **Update `package.json`**:
   - Remove `"sqlite-vec"` from dependencies
   - Add `"postgres": "^3.4.5"` if not already added in 86-01
   - Add script: `"migrate:sqlite-to-pg": "bun scripts/migrate-sqlite-to-postgres.ts"`
   - Verify no other SQLite-related dependencies remain
  </action>
  <verify>
`grep -r "bun:sqlite\|sqlite-vec\|better-sqlite3" src/` returns zero matches (only scripts/ may have bun:sqlite for the migration tool). `bunx tsc --noEmit` passes. `bun install` succeeds without sqlite-vec.
  </verify>
  <done>
Application entry point uses PostgreSQL. Migration script exists for one-time data transfer. Dockerfile updated. sqlite-vec removed from package.json. No SQLite imports in src/ directory.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update CI for PostgreSQL and run full integration test suite</name>
  <files>
    .github/workflows/ci.yml
  </files>
  <action>
1. **Update `.github/workflows/ci.yml`** to add PostgreSQL service container:
   ```yaml
   jobs:
     test:
       runs-on: ubuntu-latest
       services:
         postgres:
           image: pgvector/pgvector:pg17
           env:
             POSTGRES_DB: kodiai
             POSTGRES_USER: kodiai
             POSTGRES_PASSWORD: kodiai
           ports:
             - 5432:5432
           options: >-
             --health-cmd "pg_isready -U kodiai -d kodiai"
             --health-interval 10s
             --health-timeout 5s
             --health-retries 5
       env:
         DATABASE_URL: postgresql://kodiai:kodiai@localhost:5432/kodiai
       steps:
         - uses: actions/checkout@v4
         - uses: oven-sh/setup-bun@v2
           with:
             bun-version: latest
         - run: bun install
         - run: bun test
         - run: bunx tsc --noEmit
   ```

2. **Verify locally** that the full test suite passes:
   - `docker compose up -d` (start local PostgreSQL)
   - Wait for health check
   - `DATABASE_URL=postgresql://kodiai:kodiai@localhost:5432/kodiai bun test`
   - Confirm all tests pass, including knowledge, telemetry, and learning store tests
   - `bunx tsc --noEmit` passes

3. **Final verification sweep:**
   - `grep -rn "bun:sqlite" src/` -> must return ZERO matches
   - `grep -rn "sqlite-vec" src/` -> must return ZERO matches
   - `grep -rn "better-sqlite3" src/` -> must return ZERO matches
   - `grep -rn "\.sqlite" src/` -> check for any stray SQLite file references (db-path patterns)
   - Confirm `node_modules/sqlite-vec` does NOT exist after `bun install`
  </action>
  <verify>
`docker compose up -d && DATABASE_URL=postgresql://kodiai:kodiai@localhost:5432/kodiai bun test` -- ALL tests pass. `bunx tsc --noEmit` passes. `grep -rn "bun:sqlite\|sqlite-vec" src/` returns zero matches.
  </verify>
  <done>
CI configured with PostgreSQL service container. Full test suite passes against PostgreSQL locally and in CI. No SQLite imports or dependencies remain in src/.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify PostgreSQL swap and approve Azure deploy</name>
  <files>none</files>
  <action>
Human verifies the complete PostgreSQL infrastructure swap works end-to-end. This is a verification checkpoint, not an implementation task.
  </action>
  <verify>
1. Run `docker compose up -d` to start local PostgreSQL
2. Run `DATABASE_URL=postgresql://kodiai:kodiai@localhost:5432/kodiai bun test` -- all tests should pass
3. Run `grep -rn "bun:sqlite\|sqlite-vec" src/` -- should return nothing
4. Check `package.json` -- `sqlite-vec` should NOT be in dependencies, `postgres` should be present
5. Review `scripts/provision-postgres.sh` for Azure provisioning readiness
6. When ready to deploy:
   a. Run `bash scripts/provision-postgres.sh` to provision Azure PostgreSQL
   b. Run `DATABASE_URL=<azure-connection-string> bun scripts/migrate-sqlite-to-postgres.ts` to migrate data
   c. Add `DATABASE_URL` to Azure Container Apps secrets
   d. Deploy and verify the health endpoint returns 200
  </verify>
  <done>
User has confirmed all tests pass against PostgreSQL, no SQLite remnants exist, and the application is ready for Azure deploy (or has been deployed and verified).
  </done>
</task>

</tasks>

<verification>
1. Application boots with `DATABASE_URL` pointing to PostgreSQL
2. `bun test` passes entirely against PostgreSQL (no SQLite)
3. CI workflow uses PostgreSQL service container with pgvector
4. Migration script successfully transfers data from SQLite to PostgreSQL
5. No bun:sqlite, sqlite-vec, or better-sqlite3 references in src/
6. Dockerfile no longer creates SQLite data directory
7. After Azure deploy: health endpoint returns 200, reviews process correctly
</verification>

<success_criteria>
- Zero SQLite imports or dependencies in the application (src/ directory)
- Full test suite green against PostgreSQL in CI
- Migration script transfers all existing data
- Application boots and runs on Azure with PostgreSQL
- DB-07 verified: live reads/writes work on Azure after deploy
</success_criteria>

<output>
After completion, create `.planning/phases/86-postgresql-pgvector-on-azure/86-04-SUMMARY.md`
</output>
