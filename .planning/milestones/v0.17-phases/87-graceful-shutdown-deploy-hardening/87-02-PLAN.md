---
phase: 87-graceful-shutdown-deploy-hardening
plan: 02
type: execute
wave: 2
depends_on: ["87-01"]
files_modified:
  - src/routes/health.ts
  - src/index.ts
  - deploy.sh
  - docs/GRACEFUL-RESTART-RUNBOOK.md
autonomous: true
requirements: [DEP-04, DEP-05, DEP-06]

must_haves:
  truths:
    - "Liveness probe at /healthz checks process is up AND PostgreSQL connection pool is healthy"
    - "Readiness probe stays healthy during drain so single replica keeps accepting webhooks into the queue"
    - "On startup after deploy, queued webhooks are replayed before accepting new traffic"
    - "Azure Container Apps configured with health probes and auto-rollback on failed deployment"
    - "Graceful restart runbook documents the deploy procedure and troubleshooting"
  artifacts:
    - path: "src/routes/health.ts"
      provides: "Updated health probes with /healthz PostgreSQL check"
      exports: ["createHealthRoutes"]
    - path: "deploy.sh"
      provides: "Azure Container Apps deploy with health probes, SHUTDOWN_GRACE_MS, auto-rollback"
      contains: "SHUTDOWN_GRACE_MS"
    - path: "docs/GRACEFUL-RESTART-RUNBOOK.md"
      provides: "Operator runbook for graceful deploy procedure"
      contains: "SIGTERM"
  key_links:
    - from: "src/routes/health.ts"
      to: "src/db/client.ts"
      via: "/healthz endpoint queries PostgreSQL to verify pool health"
      pattern: "sql.*SELECT 1"
    - from: "src/index.ts"
      to: "src/lifecycle/webhook-queue-store.ts"
      via: "Startup replays queued webhooks before serving new traffic"
      pattern: "dequeuePending|replayQueued"
    - from: "deploy.sh"
      to: "src/routes/health.ts"
      via: "Azure probes point to /healthz and /readiness"
      pattern: "/healthz"
---

<objective>
Update health probes for PostgreSQL-aware liveness, implement startup webhook queue replay, configure Azure deploy for auto-rollback, and document the graceful restart procedure.

Purpose: Complete the deploy hardening story: health probes catch unhealthy containers, queued webhooks from the drain period are replayed on startup, Azure is configured for safe single-replica deploys, and operators have a runbook.

Output: Updated health routes, startup queue replay in index.ts, deploy.sh with health probes and SHUTDOWN_GRACE_MS, graceful restart runbook.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/87-graceful-shutdown-deploy-hardening/87-CONTEXT.md
@.planning/phases/87-graceful-shutdown-deploy-hardening/87-01-SUMMARY.md

@src/index.ts
@src/routes/health.ts
@src/db/client.ts
@src/lifecycle/types.ts
@src/lifecycle/shutdown-manager.ts
@src/lifecycle/request-tracker.ts
@src/lifecycle/webhook-queue-store.ts
@deploy.sh
@Dockerfile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update health probes and implement startup webhook queue replay</name>
  <files>
    src/routes/health.ts
    src/index.ts
  </files>
  <action>
    **Health routes (src/routes/health.ts):**
    Update `createHealthRoutes` to accept `sql` (Sql type from db/client.ts) and `shutdownManager` in deps.

    Replace the existing `/health` endpoint with `/healthz`:
    - Run `SELECT 1` against PostgreSQL via the sql tagged template
    - If query succeeds: return 200 `{ status: "ok", db: "connected" }`
    - If query fails: return 503 `{ status: "unhealthy", db: "unreachable" }`
    - Keep it simple — no GitHub API check in liveness (that's readiness)

    Keep `/readiness` as-is (checks GitHub API connectivity). Per user decision, readiness stays healthy during drain so the single replica keeps accepting webhooks into the queue. Do NOT add any drain-awareness to readiness.

    Keep `/health` as an alias for `/healthz` for backward compatibility during deploy transition (both return same response).

    **Startup queue replay (src/index.ts):**
    After all stores are initialized and migrations applied, but BEFORE the server starts accepting traffic:
    1. Call `webhookQueueStore.dequeuePending()` to get any queued webhooks from previous shutdown
    2. For each queued webhook:
       - If source === 'github': reconstruct the request and dispatch through `eventRouter.dispatch()`
       - If source === 'slack': reconstruct and dispatch through `slackAssistantHandler.handle()` (or just re-parse the Slack event payload and call the bootstrap handler)
       - Call `webhookQueueStore.markCompleted(id)` on success, `markFailed(id)` on error
       - Process sequentially (not parallel) to avoid overwhelming the system on cold start
    3. Log structured startup summary: `{ startupDurationMs, queuedWebhooksProcessed, queuedWebhooksFailed, dbStatus: "connected" }`

    The replay happens synchronously before `export default { port, fetch }` — Bun starts the HTTP server when the module exports, so replay completes before new requests arrive.

    **Wire updated health routes:**
    Update the `createHealthRoutes` call in index.ts to pass `sql` and `shutdownManager`.
  </action>
  <verify>
    - `bun test` passes
    - `bunx tsc --noEmit` passes
    - `grep -r '/healthz' src/routes/health.ts` shows new endpoint
    - `grep -r 'SELECT 1' src/routes/health.ts` shows PostgreSQL check
    - `grep -r 'dequeuePending\|replayQueued' src/index.ts` shows startup replay
  </verify>
  <done>
    /healthz endpoint checks PostgreSQL health, /readiness unchanged, /health backward-compatible alias. On startup, queued webhooks from previous shutdown are replayed sequentially with structured summary log.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update deploy script and create graceful restart runbook</name>
  <files>
    deploy.sh
    docs/GRACEFUL-RESTART-RUNBOOK.md
  </files>
  <action>
    **Deploy script (deploy.sh):**

    1. Add `DATABASE_URL` to required env vars validation and secret set:
       - Add to the `missing=()` check block
       - Add `database-url="$DATABASE_URL"` to `az containerapp secret set`
       - Add `DATABASE_URL=secretref:database-url` to `--set-env-vars` / `--env-vars`

    2. Add `SHUTDOWN_GRACE_MS` as an optional env var:
       - Default to 300000 (5 minutes) if not set: `SHUTDOWN_GRACE_MS=${SHUTDOWN_GRACE_MS:-300000}`
       - Pass through as a plain env var (not a secret): `SHUTDOWN_GRACE_MS="$SHUTDOWN_GRACE_MS"`

    3. Update health probe configuration:
       - Change liveness probe path from `/health` to `/healthz`
       - Keep startup probe on `/healthz`
       - Keep readiness probe on `/readiness`
       - Liveness: periodSeconds=30, failureThreshold=3 (current values are fine)
       - Readiness: periodSeconds=10, failureThreshold=3
       - Startup: periodSeconds=5, failureThreshold=40 (give ~200s for cold start with queue replay)

    4. Add `--termination-grace-period` to the `az containerapp update` / `create` commands:
       - Set to 330 seconds (5 min grace + 30s buffer for cleanup) to match SHUTDOWN_GRACE_MS default
       - This tells Azure to wait before force-killing the container

    5. Add revision mode configuration for auto-rollback:
       - Use `--revision-suffix` (already present for updates)
       - After deploy, add a post-deploy health check: curl the /healthz endpoint and verify 200
       - If health check fails after deploy, print warning about manual rollback

    **Graceful restart runbook (docs/GRACEFUL-RESTART-RUNBOOK.md):**
    Create operator documentation covering:

    1. **How Graceful Shutdown Works:**
       - SIGTERM → stop new work → drain in-flight → queue new webhooks to PostgreSQL → close DB → exit
       - Grace window: SHUTDOWN_GRACE_MS (default 5 min), extends once on timeout, force-exit after
       - Queued webhooks replayed on next startup

    2. **Deploy Procedure:**
       - Pre-deploy: check active reviews in logs (`grep "Job execution started"`)
       - Deploy command: `./deploy.sh` (builds image, updates container app)
       - Azure sends SIGTERM, waits termination grace period, then starts new revision
       - Brief downtime gap acceptable (GitHub/Slack retry webhooks)
       - Post-deploy: verify `/healthz` returns 200, check logs for startup summary

    3. **Troubleshooting:**
       - Container stuck in drain: check logs for "still draining" messages, consider reducing SHUTDOWN_GRACE_MS
       - Queued webhooks not replaying: check for "queued webhooks processed" in startup logs
       - Health check failing: verify DATABASE_URL is correct, check PostgreSQL connectivity
       - Rollback: `az containerapp revision list` to find previous revision, `az containerapp ingress traffic set` to route back

    4. **Environment Variables:**
       - `SHUTDOWN_GRACE_MS`: Grace window in ms (default 300000 = 5 min)
       - `DATABASE_URL`: PostgreSQL connection string (required)

    5. **Monitoring:**
       - Key log messages to watch: "SIGTERM received", "drain complete", "force exit", "queued webhooks processed"
       - Exit code 0 = clean shutdown, exit code 1 = forced shutdown (some work abandoned)
  </action>
  <verify>
    - `grep 'SHUTDOWN_GRACE_MS' deploy.sh` shows env var passthrough
    - `grep '/healthz' deploy.sh` shows updated probe path
    - `grep 'termination-grace-period\|terminationGracePeriodSeconds' deploy.sh` shows grace period config
    - `test -f docs/GRACEFUL-RESTART-RUNBOOK.md` confirms runbook exists
    - `grep 'SIGTERM' docs/GRACEFUL-RESTART-RUNBOOK.md` confirms runbook documents shutdown
  </verify>
  <done>
    Deploy script passes SHUTDOWN_GRACE_MS and DATABASE_URL, uses /healthz for liveness probes, configures termination grace period. Runbook documents the full deploy lifecycle, troubleshooting, and monitoring.
  </done>
</task>

</tasks>

<verification>
1. `bun test` — all tests pass
2. `bunx tsc --noEmit` — no type errors
3. /healthz endpoint queries PostgreSQL and returns db status
4. /readiness unchanged (no drain awareness per user decision)
5. Startup replays queued webhooks from previous shutdown
6. deploy.sh passes SHUTDOWN_GRACE_MS, DATABASE_URL, uses /healthz probes
7. deploy.sh configures termination grace period matching SHUTDOWN_GRACE_MS
8. Runbook exists at docs/GRACEFUL-RESTART-RUNBOOK.md with deploy procedure and troubleshooting
</verification>

<success_criteria>
- /healthz returns 200 with PostgreSQL connectivity check, 503 if DB unreachable
- /readiness stays healthy during drain (single replica keeps accepting)
- Queued webhooks are replayed on startup with structured log summary
- deploy.sh configures health probes pointing to /healthz and /readiness
- Azure termination grace period matches SHUTDOWN_GRACE_MS
- Operator runbook documents graceful shutdown, deploy procedure, troubleshooting, and monitoring
</success_criteria>

<output>
After completion, create `.planning/phases/87-graceful-shutdown-deploy-hardening/87-02-SUMMARY.md`
</output>
