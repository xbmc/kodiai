---
phase: 112-outcome-capture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/migrations/017-issue-outcome-feedback.sql
  - src/db/migrations/017-issue-outcome-feedback.down.sql
  - src/handlers/issue-closed.ts
  - src/handlers/issue-closed.test.ts
  - src/index.ts
autonomous: true
requirements: [OUTCOME-01, OUTCOME-02, OUTCOME-03, OUTCOME-04, OUTCOME-05]

must_haves:
  truths:
    - "When an issue is closed, a record is inserted into issue_outcome_feedback with the correct outcome classification"
    - "Pull request closure events are silently filtered out (no outcome record created)"
    - "Duplicate closures are detected from state_reason=duplicate OR exact-match 'duplicate' label (not 'possible-duplicate')"
    - "Outcome records link to the original triage record via triage_id FK when one exists"
    - "Redelivered webhooks with the same delivery ID produce no duplicate rows (ON CONFLICT DO NOTHING)"
    - "Handler fails open -- errors are logged but do not propagate"
  artifacts:
    - path: "src/db/migrations/017-issue-outcome-feedback.sql"
      provides: "issue_outcome_feedback table and comment_github_id column on issue_triage_state"
      contains: "CREATE TABLE IF NOT EXISTS issue_outcome_feedback"
    - path: "src/db/migrations/017-issue-outcome-feedback.down.sql"
      provides: "Rollback for migration 017"
      contains: "DROP TABLE IF EXISTS issue_outcome_feedback"
    - path: "src/handlers/issue-closed.ts"
      provides: "createIssueClosedHandler factory with outcome classification and triage linkage"
      exports: ["createIssueClosedHandler"]
    - path: "src/handlers/issue-closed.test.ts"
      provides: "Unit tests for issue-closed handler"
      contains: "createIssueClosedHandler"
    - path: "src/index.ts"
      provides: "Handler wiring for issue-closed"
      contains: "createIssueClosedHandler"
  key_links:
    - from: "src/handlers/issue-closed.ts"
      to: "src/db/migrations/017-issue-outcome-feedback.sql"
      via: "INSERT INTO issue_outcome_feedback"
      pattern: "issue_outcome_feedback"
    - from: "src/handlers/issue-closed.ts"
      to: "src/db/migrations/016-issue-triage-state.sql"
      via: "SELECT from issue_triage_state for triage linkage"
      pattern: "issue_triage_state"
    - from: "src/index.ts"
      to: "src/handlers/issue-closed.ts"
      via: "createIssueClosedHandler called with deps inside issueStore && embeddingProvider gate"
      pattern: "createIssueClosedHandler"
---

<objective>
Create the database migration for outcome capture, implement the issue-closed webhook handler with outcome classification and triage linkage, and wire it into the application.

Purpose: Closes the feedback loop by recording how issues are resolved. The outcome data feeds into Phase 113's Beta-Binomial threshold learning and Phase 114's reaction tracking. Without outcome capture, auto-triage has no signal to learn from.

Output: Migration 017, `src/handlers/issue-closed.ts` with factory, tests, and wiring in `src/index.ts`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v0.23-ROADMAP.md
@.planning/112-outcome-capture/112-RESEARCH.md

@src/handlers/issue-opened.ts
@src/handlers/issue-opened.test.ts
@src/db/migrations/016-issue-triage-state.sql
@src/db/migrations/014-issues.sql
@src/db/migrate.ts
@src/webhook/types.ts
@src/index.ts

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/webhook/types.ts:
```typescript
export interface WebhookEvent {
  id: string;
  name: string;
  payload: Record<string, unknown>;
  installationId: number;
}

export type EventHandler = (event: WebhookEvent) => Promise<void>;

export interface EventRouter {
  register(eventKey: string, handler: EventHandler): void;
  dispatch(event: WebhookEvent): Promise<void>;
}
```

From src/db/client.ts:
```typescript
export type Sql = postgres.Sql;
```

From src/db/migrations/016-issue-triage-state.sql:
```sql
CREATE TABLE IF NOT EXISTS issue_triage_state (
  id BIGSERIAL PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  repo TEXT NOT NULL,
  issue_number INTEGER NOT NULL,
  triaged_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  delivery_id TEXT NOT NULL,
  duplicate_count INTEGER NOT NULL DEFAULT 0,
  UNIQUE(repo, issue_number)
);
```

From src/handlers/issue-opened.ts (factory pattern to follow):
```typescript
export function createIssueOpenedHandler(deps: {
  eventRouter: EventRouter;
  jobQueue: JobQueue;
  githubApp: GitHubApp;
  workspaceManager: WorkspaceManager;
  issueStore: IssueStore;
  embeddingProvider: EmbeddingProvider;
  sql: Sql;
  logger: Logger;
}): void;
```

From src/index.ts (wiring location, lines 481-506):
```typescript
if (issueStore && embeddingProvider) {
  createIssueOpenedHandler({ ... });
  createTroubleshootingHandler({ ... });
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration 017 for outcome feedback table and comment_github_id column</name>
  <files>src/db/migrations/017-issue-outcome-feedback.sql, src/db/migrations/017-issue-outcome-feedback.down.sql</files>
  <action>
**1a. Create `src/db/migrations/017-issue-outcome-feedback.sql`:**

```sql
-- 017-issue-outcome-feedback.sql
-- Outcome feedback table for issue closure events + comment_github_id for reaction tracking.

-- Add comment_github_id to issue_triage_state for reaction tracking (REACT-01)
ALTER TABLE issue_triage_state
  ADD COLUMN IF NOT EXISTS comment_github_id BIGINT;

-- Outcome feedback table for issue closure events
CREATE TABLE IF NOT EXISTS issue_outcome_feedback (
  id BIGSERIAL PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  repo TEXT NOT NULL,
  issue_number INTEGER NOT NULL,

  -- Link to triage record (NULL if never triaged)
  triage_id BIGINT REFERENCES issue_triage_state(id) ON DELETE SET NULL,

  -- Outcome classification
  outcome TEXT NOT NULL,  -- "duplicate" | "completed" | "not_planned" | "unknown"
  kodiai_predicted_duplicate BOOLEAN NOT NULL DEFAULT false,
  confirmed_duplicate BOOLEAN NOT NULL DEFAULT false,
  duplicate_of_issue_number INTEGER,

  -- Raw signals
  state_reason TEXT,
  label_names TEXT[] NOT NULL DEFAULT '{}',

  -- Idempotency
  delivery_id TEXT NOT NULL,

  UNIQUE(repo, issue_number),
  UNIQUE(delivery_id)
);

CREATE INDEX IF NOT EXISTS idx_issue_outcome_feedback_repo
  ON issue_outcome_feedback (repo);

CREATE INDEX IF NOT EXISTS idx_issue_outcome_feedback_triage
  ON issue_outcome_feedback (triage_id)
  WHERE triage_id IS NOT NULL;
```

**1b. Create `src/db/migrations/017-issue-outcome-feedback.down.sql`:**

```sql
DROP TABLE IF EXISTS issue_outcome_feedback;
ALTER TABLE issue_triage_state DROP COLUMN IF EXISTS comment_github_id;
```

The migration follows the sequential numbering convention (016 is current highest). The `comment_github_id` column is intentionally nullable -- existing triage records will have NULL, which Phase 114's reaction sync job must handle gracefully.
  </action>
  <verify>
    ls -la src/db/migrations/017-issue-outcome-feedback.sql src/db/migrations/017-issue-outcome-feedback.down.sql
  </verify>
  <done>
    Migration 017 creates issue_outcome_feedback table with all columns (outcome, confirmed_duplicate, kodiai_predicted_duplicate, triage_id FK, delivery_id UNIQUE, state_reason, label_names).
    Migration 017 adds comment_github_id BIGINT to issue_triage_state.
    Rollback drops the table and column.
    Indexes on repo and triage_id (partial) exist.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create issue-closed handler with outcome classification, triage linkage, and tests</name>
  <files>src/handlers/issue-closed.ts, src/handlers/issue-closed.test.ts</files>
  <action>
**2a. Create `src/handlers/issue-closed.ts`**

Follow the `createIssueOpenedHandler` factory pattern exactly. Minimal deps -- only `eventRouter`, `sql`, `logger`.

```typescript
import type { Logger } from "pino";
import type { Sql } from "../db/client.ts";
import type { EventRouter, WebhookEvent } from "../webhook/types.ts";

export function createIssueClosedHandler(deps: {
  eventRouter: EventRouter;
  sql: Sql;
  logger: Logger;
}): void {
  const { eventRouter, sql, logger } = deps;

  async function handleIssueClosed(event: WebhookEvent): Promise<void> {
    try {
      // 1. Extract and validate payload
      const payload = event.payload as {
        action: "closed";
        issue?: {
          number: number;
          title: string;
          body: string | null;
          state: "closed";
          state_reason: "completed" | "not_planned" | "duplicate" | null;
          labels: Array<{ name: string }>;
          pull_request?: unknown;
          user?: { login: string };
          closed_at: string;
        };
        repository?: {
          full_name: string;
          name: string;
          owner?: { login: string };
        };
      };

      const issue = payload.issue;
      const repository = payload.repository;

      if (!issue || !repository || !repository.owner) {
        logger.debug({ deliveryId: event.id }, "Missing issue or repo in payload");
        return;
      }

      const repo = repository.full_name;
      const issueNumber = issue.number;
      const deliveryId = event.id;

      const handlerLogger = logger.child({
        handler: "issue-closed",
        repo,
        issueNumber,
        deliveryId,
      });

      // 2. Filter out pull requests (OUTCOME-04)
      // GitHub fires issues.closed for PRs too
      if (issue.pull_request) {
        handlerLogger.debug("Pull request closure, skipping");
        return;
      }

      // 3. Classify outcome (OUTCOME-01, OUTCOME-02)
      const stateReason = issue.state_reason;
      const labels: Array<{ name: string }> = issue.labels ?? [];
      let outcome: string;
      let confirmedDuplicate = false;

      if (stateReason === "duplicate") {
        outcome = "duplicate";
        confirmedDuplicate = true;
      } else if (stateReason === "completed") {
        outcome = "completed";
      } else if (stateReason === "not_planned") {
        outcome = "not_planned";
      } else {
        // state_reason is null -- fallback to label check
        // Use exact match for "duplicate" label (not substring, not "possible-duplicate")
        const hasDuplicateLabel = labels.some((l) => l.name === "duplicate");
        if (hasDuplicateLabel) {
          outcome = "duplicate";
          confirmedDuplicate = true;
        } else {
          outcome = "unknown";
        }
      }

      // 4. Look up triage record for linkage (OUTCOME-03)
      const triageRows = await sql`
        SELECT id, duplicate_count
        FROM issue_triage_state
        WHERE repo = ${repo} AND issue_number = ${issueNumber}
      `;

      const triageId = triageRows.length > 0 ? (triageRows[0].id as number) : null;
      const kodiaiPredictedDuplicate = triageRows.length > 0 && (triageRows[0].duplicate_count as number) > 0;

      // 5. Extract label names for raw signal storage
      const labelNames = labels.map((l) => l.name);

      // 6. Insert outcome record with delivery-ID idempotency (OUTCOME-05)
      const result = await sql`
        INSERT INTO issue_outcome_feedback (
          repo, issue_number, triage_id, outcome,
          kodiai_predicted_duplicate, confirmed_duplicate,
          state_reason, label_names, delivery_id
        )
        VALUES (
          ${repo}, ${issueNumber}, ${triageId}, ${outcome},
          ${kodiaiPredictedDuplicate}, ${confirmedDuplicate},
          ${stateReason}, ${labelNames}, ${deliveryId}
        )
        ON CONFLICT (delivery_id) DO NOTHING
        RETURNING id
      `;

      if (result.length === 0) {
        handlerLogger.info("Outcome already recorded (delivery-ID dedup), skipping");
        return;
      }

      handlerLogger.info(
        { outcome, confirmedDuplicate, kodiaiPredictedDuplicate, triageId },
        "Issue outcome captured",
      );
    } catch (err) {
      logger.error(
        { err, deliveryId: event.id },
        "Issue closed handler failed (non-fatal)",
      );
    }
  }

  eventRouter.register("issues.closed", handleIssueClosed);
}
```

Key implementation details:
- PR filtering checks `payload.issue.pull_request` at handler top before any DB queries.
- Outcome classification: `state_reason` primary, exact `"duplicate"` label fallback (NOT `"possible-duplicate"`).
- `triage_id` is nullable FK -- if no triage record exists, stores NULL.
- `kodiai_predicted_duplicate` derived from `duplicate_count > 0` on the triage record.
- `ON CONFLICT (delivery_id) DO NOTHING` for idempotency (Layer 2 -- Layer 1 is the in-memory deduplicator at webhook route level).
- Entire handler wrapped in try/catch with fail-open error logging.

**2b. Create `src/handlers/issue-closed.test.ts`**

Follow the test pattern from `issue-opened.test.ts`. Create mock helpers and test all key behaviors.

Test helpers needed:
- `createMockLogger()` -- same pattern as issue-opened.test.ts
- `createMockEventRouter()` -- captures registered handlers
- `createMockSql(opts)` -- configurable: triage lookup results, insert results. Use Proxy pattern from issue-opened.test.ts but with tagged template support that inspects the SQL string to return appropriate results based on the query (SELECT vs INSERT).

Tests to write:

1. **"registers on issues.closed event"** -- creates handler, checks router has 1 captured handler with key "issues.closed".

2. **"skips pull request closure events"** (OUTCOME-04) -- event with `issue.pull_request: {}`, verify no SQL INSERT called.

3. **"records completed outcome from state_reason"** (OUTCOME-01) -- event with `state_reason: "completed"`, verify INSERT with `outcome = "completed"`, `confirmed_duplicate = false`.

4. **"records duplicate outcome from state_reason"** (OUTCOME-02) -- event with `state_reason: "duplicate"`, verify INSERT with `outcome = "duplicate"`, `confirmed_duplicate = true`.

5. **"records duplicate from label fallback when state_reason is null"** (OUTCOME-02) -- event with `state_reason: null`, labels: `[{ name: "duplicate" }]`, verify `outcome = "duplicate"`, `confirmed_duplicate = true`.

6. **"records unknown outcome when no state_reason and no duplicate label"** -- event with `state_reason: null`, labels: `[]`, verify `outcome = "unknown"`.

7. **"does not treat possible-duplicate label as confirmed duplicate"** -- event with `state_reason: null`, labels: `[{ name: "possible-duplicate" }]`, verify `outcome = "unknown"`, `confirmed_duplicate = false`.

8. **"links to triage record when one exists"** (OUTCOME-03) -- mock SQL returns triage row with `id: 42, duplicate_count: 2`, verify INSERT includes `triage_id = 42`, `kodiai_predicted_duplicate = true`.

9. **"sets triage_id null when no triage record"** (OUTCOME-03) -- mock SQL returns empty triage rows, verify INSERT includes `triage_id = null`.

10. **"skips insert on delivery-ID conflict"** (OUTCOME-05) -- mock SQL INSERT returns empty array (ON CONFLICT DO NOTHING), verify handler logs dedup message and returns without error.

11. **"fails open on handler error"** -- mock SQL that throws, verify handler does not throw (catches and logs).

12. **"skips events with missing payload fields"** -- event with no issue or no repository, verify early return.

For the mock SQL proxy, use a pattern that inspects the template strings array to determine query type:
- If first string contains "SELECT" and "issue_triage_state" -> return configured triage rows
- If first string contains "INSERT" and "issue_outcome_feedback" -> return configured insert result
- Default: return empty array

Track calls to the SQL mock to verify what was passed (use a `calls` array on the mock).
  </action>
  <verify>
    bun test src/handlers/issue-closed.test.ts
  </verify>
  <done>
    createIssueClosedHandler registers on "issues.closed".
    PR closures filtered out before any DB queries.
    Outcome classification handles all 4 cases: completed, not_planned, duplicate (state_reason), duplicate (label fallback), unknown.
    Exact match for "duplicate" label -- "possible-duplicate" does NOT trigger confirmed_duplicate.
    Triage linkage looks up triage record, sets triage_id=NULL when none exists.
    kodiai_predicted_duplicate derived from duplicate_count > 0.
    ON CONFLICT (delivery_id) DO NOTHING prevents duplicate inserts.
    Handler fails open on errors.
    All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire issue-closed handler in src/index.ts</name>
  <files>src/index.ts</files>
  <action>
**3a. Add import** near the top of `src/index.ts`, adjacent to the `createIssueOpenedHandler` import:

```typescript
import { createIssueClosedHandler } from "./handlers/issue-closed.ts";
```

**3b. Add handler wiring** inside the existing `if (issueStore && embeddingProvider)` block (around line 481-506), after the `createIssueOpenedHandler` call and before or after the `createTroubleshootingHandler` call:

```typescript
  createIssueClosedHandler({
    eventRouter,
    sql,
    logger,
  });
```

The handler only needs `eventRouter`, `sql`, and `logger` -- no `githubApp`, `workspaceManager`, `issueStore`, or `embeddingProvider`. However, it must be inside the `if (issueStore && embeddingProvider)` block because outcome capture is only meaningful when auto-triage is active (logical gate, not technical dependency).

Do NOT create a separate conditional block. Place it as a sibling call within the existing guard.
  </action>
  <verify>
    bun build src/index.ts --no-bundle 2>&1 | head -10
  </verify>
  <done>
    src/index.ts imports createIssueClosedHandler.
    Handler wired inside `if (issueStore && embeddingProvider)` block with minimal deps (eventRouter, sql, logger).
    Compiles clean with no type errors.
  </done>
</task>

</tasks>

<verification>
1. `ls src/db/migrations/017-issue-outcome-feedback.sql src/db/migrations/017-issue-outcome-feedback.down.sql` -- both files exist
2. `bun test src/handlers/issue-closed.test.ts` -- all tests pass
3. `bun build src/handlers/issue-closed.ts --no-bundle` -- compiles clean
4. `bun build src/index.ts --no-bundle` -- compiles clean
5. Grep confirms `createIssueClosedHandler` in src/index.ts
6. Grep confirms `ON CONFLICT (delivery_id) DO NOTHING` in issue-closed.ts
7. Grep confirms `issue.pull_request` check in issue-closed.ts (PR filtering)
8. Grep confirms exact match `l.name === "duplicate"` (not substring) in issue-closed.ts
</verification>

<success_criteria>
- Migration 017 creates issue_outcome_feedback table and adds comment_github_id to issue_triage_state
- Handler registers on issues.closed and classifies outcomes from state_reason + label fallback
- Pull requests filtered out at handler top
- Exact "duplicate" label match (not "possible-duplicate")
- Triage linkage with nullable triage_id
- Delivery-ID idempotency via ON CONFLICT DO NOTHING
- Handler wired in src/index.ts inside issueStore && embeddingProvider gate
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/112-outcome-capture/112-01-SUMMARY.md`
</output>
