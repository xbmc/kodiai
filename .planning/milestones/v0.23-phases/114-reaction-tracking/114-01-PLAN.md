---
phase: 114-reaction-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/migrations/019-triage-comment-reactions.sql
  - src/db/migrations/019-triage-comment-reactions.down.sql
  - scripts/sync-triage-reactions.ts
  - .github/workflows/nightly-reaction-sync.yml
autonomous: true
requirements: [REACT-02, REACT-03]

must_haves:
  truths:
    - "A nightly cron job polls GitHub reactions on recent triage comments and stores thumbs_up/thumbs_down counts"
    - "Reaction data feeds into the Bayesian threshold learning system via recordObservation as a secondary signal"
    - "Reaction-based observations are only recorded when reaction counts have changed AND no issue_outcome_feedback closure record exists (avoids double-counting)"
    - "Pre-Phase 112 triage records with NULL comment_github_id are gracefully skipped"
    - "Bot reactions are filtered out (only human thumbs up/down counted)"
    - "The sync script follows the standalone script pattern from backfill-issues.ts"
    - "The GitHub Actions workflow follows the nightly-issue-sync.yml pattern"
  artifacts:
    - path: "src/db/migrations/019-triage-comment-reactions.sql"
      provides: "triage_comment_reactions table for reaction snapshots"
      contains: "CREATE TABLE IF NOT EXISTS triage_comment_reactions"
    - path: "src/db/migrations/019-triage-comment-reactions.down.sql"
      provides: "Rollback for migration 019"
      contains: "DROP TABLE IF EXISTS triage_comment_reactions"
    - path: "scripts/sync-triage-reactions.ts"
      provides: "Standalone nightly sync script for triage comment reactions"
      exports: []
    - path: ".github/workflows/nightly-reaction-sync.yml"
      provides: "GitHub Actions cron workflow running the sync script"
      contains: "nightly-reaction-sync"
  key_links:
    - from: "scripts/sync-triage-reactions.ts"
      to: "src/db/migrations/019-triage-comment-reactions.sql"
      via: "INSERT/UPDATE into triage_comment_reactions"
      pattern: "triage_comment_reactions"
    - from: "scripts/sync-triage-reactions.ts"
      to: "src/triage/threshold-learner.ts"
      via: "import and call recordObservation"
      pattern: "recordObservation"
    - from: "scripts/sync-triage-reactions.ts"
      to: "src/db/migrations/016-issue-triage-state.sql"
      via: "SELECT from issue_triage_state WHERE comment_github_id IS NOT NULL"
      pattern: "issue_triage_state"
    - from: ".github/workflows/nightly-reaction-sync.yml"
      to: "scripts/sync-triage-reactions.ts"
      via: "bun scripts/sync-triage-reactions.ts"
      pattern: "sync-triage-reactions"
---

<objective>
Create the reaction tracking infrastructure: a PostgreSQL table for reaction snapshots, a standalone sync script that polls GitHub reactions on triage comments and feeds them into the Bayesian threshold learner, and a GitHub Actions nightly cron workflow.

Purpose: Reactions on triage comments provide a secondary feedback signal for threshold learning. When users thumbs-down a duplicate prediction, it's a false positive signal. When they thumbs-up, it confirms the prediction. This supplements the primary closure-based signal from the issue-closed handler (Phase 112/113), especially for issues that remain open.

Output: Migration 019, `scripts/sync-triage-reactions.ts`, `.github/workflows/nightly-reaction-sync.yml`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v0.23-ROADMAP.md
@.planning/phases/114-reaction-tracking/114-RESEARCH.md

@src/triage/threshold-learner.ts
@src/handlers/feedback-sync.ts
@src/handlers/issue-opened.ts
@src/handlers/issue-closed.ts
@src/db/migrations/017-issue-outcome-feedback.sql
@src/db/migrations/018-triage-threshold-state.sql
@src/db/migrations/016-issue-triage-state.sql
@scripts/backfill-issues.ts
@.github/workflows/nightly-issue-sync.yml
@src/auth/github-app.ts
@src/db/client.ts
@src/db/migrate.ts

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/triage/threshold-learner.ts:
```typescript
export async function recordObservation(params: {
  sql: Sql;
  repo: string;
  kodiaiPredictedDuplicate: boolean;
  confirmedDuplicate: boolean;
  logger: Logger;
}): Promise<void>;
```

From src/db/client.ts:
```typescript
export type Sql = postgres.Sql;
export function createDbClient(opts: {
  connectionString?: string;
  logger: Logger;
}): { sql: Sql; close: () => Promise<void> };
```

From src/auth/github-app.ts:
```typescript
export interface GitHubApp {
  initialize(): Promise<void>;
  getAppSlug(): string;
  getInstallationOctokit(installationId: number): Promise<Octokit>;
  getRepoInstallationContext(owner: string, repo: string): Promise<{ installationId: number; defaultBranch: string } | null>;
}
export function createGitHubApp(config: AppConfig, logger: Logger): GitHubApp;
```

From src/config.ts:
```typescript
export type AppConfig = z.infer<typeof configSchema>;
// Includes: githubAppId, githubPrivateKey, webhookSecret, slackSigningSecret,
// slackBotToken, slackBotUserId, slackKodiaiChannelId, slackDefaultRepo,
// slackAssistantModel, port, logLevel, botAllowList
```

From src/db/migrate.ts:
```typescript
export async function runMigrations(sql: Sql): Promise<void>;
// Note: takes only sql, no logger parameter
```

From src/handlers/feedback-sync.ts (reaction filtering pattern):
```typescript
type ReactionEntry = {
  id: number;
  content: string;  // "+1", "-1", "laugh", "heart", etc.
  user?: { login?: string; type?: string } | null;
  created_at?: string | null;
};

function isHumanThumbReaction(reaction: ReactionEntry, appSlug: string): boolean;
```

From src/db/migrations/016-issue-triage-state.sql (with 017 ALTER):
```sql
CREATE TABLE issue_triage_state (
  id BIGSERIAL PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  repo TEXT NOT NULL,
  issue_number INTEGER NOT NULL,
  triaged_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  delivery_id TEXT NOT NULL,
  duplicate_count INTEGER NOT NULL DEFAULT 0,
  comment_github_id BIGINT,  -- Added by migration 017 (nullable)
  UNIQUE(repo, issue_number)
);
```

From src/db/migrations/017-issue-outcome-feedback.sql:
```sql
CREATE TABLE issue_outcome_feedback (
  id BIGSERIAL PRIMARY KEY,
  repo TEXT NOT NULL,
  issue_number INTEGER NOT NULL,
  triage_id BIGINT REFERENCES issue_triage_state(id),
  outcome TEXT NOT NULL,
  kodiai_predicted_duplicate BOOLEAN NOT NULL DEFAULT false,
  confirmed_duplicate BOOLEAN NOT NULL DEFAULT false,
  delivery_id TEXT NOT NULL,
  UNIQUE(repo, issue_number),
  UNIQUE(delivery_id)
);
```

From scripts/backfill-issues.ts (standalone script pattern):
```typescript
import { parseArgs } from "node:util";
import pino from "pino";
import { createDbClient } from "../src/db/client.ts";
import { runMigrations } from "../src/db/migrate.ts";
import { createGitHubApp } from "../src/auth/github-app.ts";

const logger = pino({ level: process.env.LOG_LEVEL ?? "info" });
const { values } = parseArgs({ ... });
const db = createDbClient({ logger });
await runMigrations(db.sql);

// Private key loading (supports inline PEM, file path, or base64)
async function loadPrivateKey(): Promise<string> {
  const keyEnv = process.env.GITHUB_PRIVATE_KEY!;
  if (keyEnv.startsWith("-----BEGIN")) return keyEnv;
  if (keyEnv.startsWith("/") || keyEnv.startsWith("./")) return await Bun.file(keyEnv).text();
  return atob(keyEnv);
}

const privateKey = await loadPrivateKey();
const githubApp = createGitHubApp(
  {
    githubAppId: process.env.GITHUB_APP_ID!,
    githubPrivateKey: privateKey,
    webhookSecret: "unused",
    slackSigningSecret: "unused",
    slackBotToken: "unused",
    slackBotUserId: "unused",
    slackKodiaiChannelId: "unused",
    slackDefaultRepo: "xbmc/xbmc",
    slackAssistantModel: "unused",
    port: 0,
    logLevel: "info",
    botAllowList: [],
  },
  logger,
);
await githubApp.initialize();
// ... process ...
await db.close();
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration 019 for triage_comment_reactions table</name>
  <files>src/db/migrations/019-triage-comment-reactions.sql, src/db/migrations/019-triage-comment-reactions.down.sql</files>
  <action>
**1a. Create `src/db/migrations/019-triage-comment-reactions.sql`:**

```sql
-- 019-triage-comment-reactions.sql
-- Stores reaction snapshots for triage comments to feed secondary signal into threshold learning.

CREATE TABLE IF NOT EXISTS triage_comment_reactions (
  id BIGSERIAL PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  synced_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  repo TEXT NOT NULL,
  issue_number INTEGER NOT NULL,
  triage_id BIGINT NOT NULL REFERENCES issue_triage_state(id) ON DELETE CASCADE,
  comment_github_id BIGINT NOT NULL,

  thumbs_up INTEGER NOT NULL DEFAULT 0,
  thumbs_down INTEGER NOT NULL DEFAULT 0,

  -- Whether a threshold observation has been recorded from these reactions
  observation_recorded BOOLEAN NOT NULL DEFAULT false,
  -- The net direction when observation was recorded: 'up', 'down', or NULL
  observation_direction TEXT,

  UNIQUE(repo, issue_number)
);

CREATE INDEX IF NOT EXISTS idx_triage_comment_reactions_triage
  ON triage_comment_reactions (triage_id);
```

Key design choices:
- `triage_id NOT NULL REFERENCES issue_triage_state(id) ON DELETE CASCADE` -- every reaction record links to a triage record. CASCADE because if triage record is deleted, reaction record is meaningless.
- `observation_recorded` + `observation_direction` track whether we've already fed this reaction signal into threshold learning. Prevents re-recording on every nightly sync.
- `UNIQUE(repo, issue_number)` -- one reaction snapshot per triaged issue. UPSERT on sync.

**1b. Create `src/db/migrations/019-triage-comment-reactions.down.sql`:**

```sql
DROP TABLE IF EXISTS triage_comment_reactions;
```
  </action>
  <verify>
    ls -la src/db/migrations/019-triage-comment-reactions.sql src/db/migrations/019-triage-comment-reactions.down.sql
  </verify>
  <done>
    Migration 019 creates triage_comment_reactions table with triage_id FK, thumbs_up/down counts, observation_recorded tracking, and UNIQUE(repo, issue_number).
    Rollback drops the table.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create sync-triage-reactions.ts standalone script</name>
  <files>scripts/sync-triage-reactions.ts</files>
  <action>
**Create `scripts/sync-triage-reactions.ts`**

Follow the `backfill-issues.ts` standalone script pattern exactly. The script:

1. Parses CLI args (--days, --dry-run, --help)
2. Initializes DB client, runs migrations, initializes GitHub App
3. Queries triage records with non-null comment_github_id from the last N days
4. Groups records by repo for efficient octokit reuse
5. For each triage comment: polls reactions, filters to human thumbs, counts up/down
6. UPSERTs into triage_comment_reactions
7. For changed reactions with clear direction and no existing closure outcome: calls recordObservation

```typescript
/**
 * Nightly sync script for triage comment reactions.
 *
 * Polls GitHub reactions on recent triage comments and feeds them into
 * the Bayesian threshold learning system as a secondary signal.
 *
 * Usage:
 *   bun scripts/sync-triage-reactions.ts                # Sync last 30 days
 *   bun scripts/sync-triage-reactions.ts --days 7       # Sync last 7 days
 *   bun scripts/sync-triage-reactions.ts --dry-run      # Fetch and log, don't store
 *
 * Environment variables required:
 *   DATABASE_URL          - PostgreSQL connection string
 *   GITHUB_APP_ID         - GitHub App ID
 *   GITHUB_PRIVATE_KEY    - GitHub App private key (PEM, file path, or base64)
 */

import { parseArgs } from "node:util";
import pino from "pino";
import { createDbClient } from "../src/db/client.ts";
import { runMigrations } from "../src/db/migrate.ts";
import { createGitHubApp } from "../src/auth/github-app.ts";
import { recordObservation } from "../src/triage/threshold-learner.ts";
import type { Sql } from "../src/db/client.ts";
import type { Logger } from "pino";

const logger = pino({ level: process.env.LOG_LEVEL ?? "info" });

// ── Validate environment ────────────────────────────────────────────────────

if (!process.env.DATABASE_URL) {
  console.error("ERROR: DATABASE_URL environment variable is required.");
  process.exit(1);
}
if (!process.env.GITHUB_APP_ID) {
  console.error("ERROR: GITHUB_APP_ID environment variable is required.");
  process.exit(1);
}
if (!process.env.GITHUB_PRIVATE_KEY) {
  console.error("ERROR: GITHUB_PRIVATE_KEY environment variable is required.");
  process.exit(1);
}

// ── Load private key ────────────────────────────────────────────────────────

async function loadPrivateKey(): Promise<string> {
  const keyEnv = process.env.GITHUB_PRIVATE_KEY!;
  if (keyEnv.startsWith("-----BEGIN")) return keyEnv;
  if (keyEnv.startsWith("/") || keyEnv.startsWith("./")) {
    return await Bun.file(keyEnv).text();
  }
  return atob(keyEnv);
}

// ── Parse arguments ─────────────────────────────────────────────────────────

const { values } = parseArgs({
  args: process.argv.slice(2),
  options: {
    days: { type: "string", default: "30" },
    "dry-run": { type: "boolean", default: false },
    help: { type: "boolean", default: false },
  },
});

if (values.help) {
  console.log(`
Usage: bun scripts/sync-triage-reactions.ts [options]

Options:
  --days <number>       Look-back window in days (default: 30)
  --dry-run             Fetch and log but don't store
  --help                Show this help

Environment:
  DATABASE_URL          PostgreSQL connection string (required)
  GITHUB_APP_ID         GitHub App ID (required)
  GITHUB_PRIVATE_KEY    GitHub App private key (required)
`);
  process.exit(0);
}

const lookbackDays = parseInt(values.days!, 10) || 30;
const dryRun = values["dry-run"]!;

// ── Reaction filtering ──────────────────────────────────────────────────────

type ReactionEntry = {
  id: number;
  content: string;
  user?: { login?: string; type?: string } | null;
};

function normalizeLogin(login: string | undefined): string {
  return (login ?? "").trim().toLowerCase().replace(/\[bot\]$/i, "");
}

function isHumanThumbReaction(reaction: ReactionEntry, appSlug: string): boolean {
  if (reaction.content !== "+1" && reaction.content !== "-1") return false;

  const userType = (reaction.user?.type ?? "").toLowerCase();
  if (userType === "bot") return false;

  const reactorLogin = normalizeLogin(reaction.user?.login);
  if (reactorLogin.length === 0) return false;
  if (reactorLogin === normalizeLogin(appSlug)) return false;

  return true;
}

// ── Main ────────────────────────────────────────────────────────────────────

async function main(): Promise<void> {
  // 1. Initialize database
  const db = createDbClient({ logger });
  const { sql } = db;

  try {
    await runMigrations(sql);

    // 2. Initialize GitHub App
    const privateKey = await loadPrivateKey();
    const githubApp = createGitHubApp(
      {
        githubAppId: process.env.GITHUB_APP_ID!,
        githubPrivateKey: privateKey,
        webhookSecret: "unused",
        slackSigningSecret: "unused",
        slackBotToken: "unused",
        slackBotUserId: "unused",
        slackKodiaiChannelId: "unused",
        slackDefaultRepo: "xbmc/xbmc",
        slackAssistantModel: "unused",
        port: 0,
        logLevel: "info",
        botAllowList: [],
      },
      logger,
    );
    await githubApp.initialize();
    const appSlug = githubApp.getAppSlug();

    // 3. Query triage records with comment_github_id from the lookback window
    const triageRecords = await sql`
      SELECT
        ts.id AS triage_id,
        ts.repo,
        ts.issue_number,
        ts.comment_github_id,
        ts.duplicate_count
      FROM issue_triage_state ts
      WHERE ts.comment_github_id IS NOT NULL
        AND ts.triaged_at > now() - make_interval(days => ${lookbackDays})
      ORDER BY ts.repo, ts.issue_number
    `;

    logger.info(
      { triageCount: triageRecords.length, lookbackDays, dryRun },
      "Fetched triage records for reaction sync",
    );

    if (triageRecords.length === 0) {
      logger.info("No triage records with comment IDs found, nothing to sync");
      return;
    }

    // 4. Group by repo for efficient octokit reuse
    const byRepo = new Map<string, typeof triageRecords>();
    for (const record of triageRecords) {
      const repo = record.repo as string;
      if (!byRepo.has(repo)) byRepo.set(repo, []);
      byRepo.get(repo)!.push(record);
    }

    let synced = 0;
    let observationsRecorded = 0;
    let skippedNoReactions = 0;
    let skippedAmbiguous = 0;
    let skippedAlreadyRecorded = 0;
    let skippedClosureExists = 0;
    let errors = 0;

    // 5. Process each repo
    for (const [repo, records] of byRepo) {
      const [owner, repoName] = repo.split("/");
      if (!owner || !repoName) {
        logger.warn({ repo }, "Invalid repo format, skipping");
        continue;
      }

      let octokit;
      try {
        const ctx = await githubApp.getRepoInstallationContext(owner, repoName);
        if (!ctx) {
          logger.warn({ repo }, "No installation found for repo, skipping");
          continue;
        }
        octokit = await githubApp.getInstallationOctokit(ctx.installationId);
      } catch (err) {
        logger.error({ err, repo }, "Failed to get octokit for repo, skipping");
        errors++;
        continue;
      }

      for (const record of records) {
        const commentGithubId = record.comment_github_id as number;
        const issueNumber = record.issue_number as number;
        const triageId = record.triage_id as number;

        try {
          // 5a. Fetch reactions on the triage comment
          const response = await octokit.rest.reactions.listForIssueComment({
            owner,
            repo: repoName,
            comment_id: commentGithubId,
            per_page: 100,
          });

          // 5b. Filter to human thumbs reactions
          const humanReactions = response.data.filter((r: any) =>
            isHumanThumbReaction(r as ReactionEntry, appSlug),
          );

          const thumbsUp = humanReactions.filter((r: any) => r.content === "+1").length;
          const thumbsDown = humanReactions.filter((r: any) => r.content === "-1").length;

          logger.debug(
            { repo, issueNumber, commentGithubId, thumbsUp, thumbsDown, totalReactions: response.data.length },
            "Fetched reactions for triage comment",
          );

          if (dryRun) {
            logger.info(
              { repo, issueNumber, thumbsUp, thumbsDown },
              "[DRY RUN] Would sync reaction counts",
            );
            synced++;
            continue;
          }

          // 5c. UPSERT reaction counts
          await sql`
            INSERT INTO triage_comment_reactions (
              repo, issue_number, triage_id, comment_github_id,
              thumbs_up, thumbs_down, synced_at
            )
            VALUES (
              ${repo}, ${issueNumber}, ${triageId}, ${commentGithubId},
              ${thumbsUp}, ${thumbsDown}, now()
            )
            ON CONFLICT (repo, issue_number) DO UPDATE SET
              thumbs_up = ${thumbsUp},
              thumbs_down = ${thumbsDown},
              synced_at = now()
          `;

          synced++;

          // 5d. Determine if we should record a threshold observation
          const shouldRecord = await shouldRecordObservation({
            sql,
            repo,
            issueNumber,
            thumbsUp,
            thumbsDown,
            logger,
          });

          if (!shouldRecord.record) {
            switch (shouldRecord.reason) {
              case "no_reactions": skippedNoReactions++; break;
              case "ambiguous": skippedAmbiguous++; break;
              case "already_recorded": skippedAlreadyRecorded++; break;
              case "closure_exists": skippedClosureExists++; break;
            }
            continue;
          }

          // 5e. Record observation into threshold learner
          // kodiaiPredictedDuplicate is always true (triage comment exists = duplicates were found)
          const confirmedDuplicate = shouldRecord.direction === "up";

          await recordObservation({
            sql,
            repo,
            kodiaiPredictedDuplicate: true,
            confirmedDuplicate,
            logger,
          });

          // 5f. Mark observation as recorded with direction
          await sql`
            UPDATE triage_comment_reactions
            SET observation_recorded = true,
                observation_direction = ${shouldRecord.direction}
            WHERE repo = ${repo} AND issue_number = ${issueNumber}
          `;

          observationsRecorded++;

          logger.info(
            { repo, issueNumber, thumbsUp, thumbsDown, direction: shouldRecord.direction, confirmedDuplicate },
            "Reaction-based threshold observation recorded",
          );
        } catch (err) {
          logger.error(
            { err, repo, issueNumber, commentGithubId },
            "Failed to sync reactions for triage comment (non-fatal)",
          );
          errors++;
        }
      }
    }

    logger.info(
      {
        synced,
        observationsRecorded,
        skippedNoReactions,
        skippedAmbiguous,
        skippedAlreadyRecorded,
        skippedClosureExists,
        errors,
        totalTriageRecords: triageRecords.length,
      },
      "Reaction sync complete",
    );
  } finally {
    await db.close();
  }
}

// ── Observation decision logic ──────────────────────────────────────────────

type ObservationDecision =
  | { record: false; reason: "no_reactions" | "ambiguous" | "already_recorded" | "closure_exists" }
  | { record: true; direction: "up" | "down" };

async function shouldRecordObservation(params: {
  sql: Sql;
  repo: string;
  issueNumber: number;
  thumbsUp: number;
  thumbsDown: number;
  logger: Logger;
}): Promise<ObservationDecision> {
  const { sql, repo, issueNumber, thumbsUp, thumbsDown, logger: _logger } = params;

  // No reactions = no signal
  if (thumbsUp === 0 && thumbsDown === 0) {
    return { record: false, reason: "no_reactions" };
  }

  // Ambiguous = equal votes, skip
  if (thumbsUp === thumbsDown) {
    return { record: false, reason: "ambiguous" };
  }

  const direction: "up" | "down" = thumbsUp > thumbsDown ? "up" : "down";

  // Check if we already recorded an observation with the same direction
  const existing = await sql`
    SELECT observation_recorded, observation_direction
    FROM triage_comment_reactions
    WHERE repo = ${repo} AND issue_number = ${issueNumber}
  `;

  if (
    existing.length > 0 &&
    existing[0].observation_recorded === true &&
    existing[0].observation_direction === direction
  ) {
    return { record: false, reason: "already_recorded" };
  }

  // Check if a closure-based outcome already exists (primary signal takes precedence)
  const outcomeRows = await sql`
    SELECT id FROM issue_outcome_feedback
    WHERE repo = ${repo} AND issue_number = ${issueNumber}
  `;

  if (outcomeRows.length > 0) {
    return { record: false, reason: "closure_exists" };
  }

  return { record: true, direction };
}

main().catch((err) => {
  logger.fatal({ err }, "Reaction sync failed");
  process.exit(1);
});
```

Key implementation details:

- **Reaction filtering:** Inline `isHumanThumbReaction` and `normalizeLogin` copied from `feedback-sync.ts` (private functions, not exported). Filters out bot reactions and the app's own reactions.
- **Observation dedup:** Tracks `observation_recorded` + `observation_direction` in `triage_comment_reactions`. Only re-records if direction has changed (e.g., previously thumbs up, now thumbs down after more votes).
- **Closure dedup:** Checks `issue_outcome_feedback` for existing closure-based outcome. If present, skips reaction observation (primary signal from issue-closed handler takes precedence).
- **kodiaiPredictedDuplicate is always true:** Triage comments only exist when duplicates were found. So the observation is always either TP (thumbs_up, confirmed=true) or FP (thumbs_down, confirmed=false).
- **Error handling:** Per-comment errors are caught and logged without aborting the run. Summary stats logged at end.
- **No VOYAGE_API_KEY needed:** This script doesn't generate embeddings, only polls reactions and writes to DB.
  </action>
  <verify>
    bun build scripts/sync-triage-reactions.ts --no-bundle 2>&1 | head -10
  </verify>
  <done>
    scripts/sync-triage-reactions.ts follows the standalone script pattern.
    Queries triage records with non-null comment_github_id.
    Polls reactions via listForIssueComment.
    Filters to human thumbs via isHumanThumbReaction.
    UPSERTs into triage_comment_reactions.
    Records observations via recordObservation with dedup guards (direction unchanged, closure exists).
    Comprehensive structured logging with stats summary.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create GitHub Actions nightly-reaction-sync workflow</name>
  <files>.github/workflows/nightly-reaction-sync.yml</files>
  <action>
**Create `.github/workflows/nightly-reaction-sync.yml`:**

Follow the `nightly-issue-sync.yml` pattern exactly.

```yaml
name: nightly-reaction-sync

on:
  schedule:
    - cron: '30 3 * * *'  # 3:30 AM UTC daily (30 min after issue sync)
  workflow_dispatch:       # Manual trigger for testing

jobs:
  sync:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v4
      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest
      - run: bun install --frozen-lockfile
      - name: Sync triage comment reactions
        run: bun scripts/sync-triage-reactions.ts
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          GITHUB_APP_ID: ${{ secrets.GITHUB_APP_ID }}
          GITHUB_PRIVATE_KEY: ${{ secrets.GITHUB_PRIVATE_KEY }}
```

Key details:
- Runs at 3:30 AM UTC, 30 minutes after the issue sync (3:00 AM). This ensures issue data is fresh before reaction sync runs.
- `timeout-minutes: 15` -- shorter than issue sync (30 min) because reaction sync is lighter (no embeddings).
- No `VOYAGE_API_KEY` needed -- this script doesn't generate embeddings.
- `workflow_dispatch` enables manual trigger for testing.
  </action>
  <verify>
    cat .github/workflows/nightly-reaction-sync.yml | head -20
  </verify>
  <done>
    nightly-reaction-sync.yml follows the nightly-issue-sync.yml pattern.
    Runs at 3:30 AM UTC daily (offset from issue sync).
    15-minute timeout (lighter workload).
    Only needs DATABASE_URL, GITHUB_APP_ID, GITHUB_PRIVATE_KEY (no VOYAGE_API_KEY).
    Manual trigger via workflow_dispatch.
  </done>
</task>

</tasks>

<verification>
1. `ls src/db/migrations/019-triage-comment-reactions.sql src/db/migrations/019-triage-comment-reactions.down.sql` -- both files exist
2. `bun build scripts/sync-triage-reactions.ts --no-bundle` -- compiles clean
3. `cat .github/workflows/nightly-reaction-sync.yml` -- valid YAML structure
4. Grep confirms `recordObservation` imported and called in sync-triage-reactions.ts
5. Grep confirms `listForIssueComment` in sync-triage-reactions.ts
6. Grep confirms `comment_github_id IS NOT NULL` in the triage query
7. Grep confirms `issue_outcome_feedback` check (closure dedup) in sync-triage-reactions.ts
8. Grep confirms `isHumanThumbReaction` filtering in sync-triage-reactions.ts
9. Grep confirms `ON CONFLICT (repo, issue_number) DO UPDATE` in sync-triage-reactions.ts
10. Grep confirms `observation_recorded` tracking in both migration and script
</verification>

<success_criteria>
- Migration 019 creates triage_comment_reactions table with FK to issue_triage_state, reaction counts, and observation tracking
- Sync script polls GitHub reactions on recent triage comments with human-only filtering
- Reaction counts are UPSERTed into triage_comment_reactions on each sync run
- Threshold observations are recorded via recordObservation only when:
  - Reactions have a clear net direction (not tied, not zero)
  - Direction has changed since last observation (or no observation yet)
  - No closure-based outcome exists in issue_outcome_feedback (avoids double-counting)
- kodiaiPredictedDuplicate is always true (triage comments only exist for predicted duplicates)
- confirmedDuplicate = thumbsUp > thumbsDown (users agree with prediction)
- GitHub Actions workflow runs nightly at 3:30 AM UTC with proper secrets
- Script handles errors per-comment without aborting the full run
- Pre-Phase 112 triage records (NULL comment_github_id) are gracefully filtered out
</success_criteria>

<output>
After completion, create `.planning/phases/114-reaction-tracking/114-01-SUMMARY.md`
</output>
