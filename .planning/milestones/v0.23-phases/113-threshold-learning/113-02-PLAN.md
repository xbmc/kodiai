---
phase: 113-threshold-learning
plan: 02
type: execute
wave: 2
depends_on: [113-01]
files_modified:
  - src/handlers/issue-opened.ts
  - src/handlers/issue-closed.ts
  - src/handlers/issue-closed.test.ts
  - src/handlers/issue-opened.test.ts
autonomous: true
requirements: [LEARN-01, LEARN-04]

must_haves:
  truths:
    - "issue-opened handler reads effective threshold from getEffectiveThreshold() instead of static config value"
    - "issue-opened handler falls back to config threshold when Bayesian state unavailable or insufficient"
    - "issue-closed handler calls recordObservation() after outcome insert when triage_id IS NOT NULL"
    - "issue-closed handler does NOT call recordObservation() when triage_id is NULL (untriaged issues)"
    - "Structured log emitted during threshold resolution showing source, value, and alpha/beta when learned"
    - "getEffectiveThreshold failure is fail-open (falls back to config, does not crash handler)"
  artifacts:
    - path: "src/handlers/issue-opened.ts"
      provides: "Dynamic threshold resolution via getEffectiveThreshold"
      contains: "getEffectiveThreshold"
    - path: "src/handlers/issue-closed.ts"
      provides: "Observation recording via recordObservation after outcome insert"
      contains: "recordObservation"
    - path: "src/handlers/issue-closed.test.ts"
      provides: "Tests for recordObservation wiring"
      contains: "recordObservation"
    - path: "src/handlers/issue-opened.test.ts"
      provides: "Tests for effective threshold resolution"
      contains: "getEffectiveThreshold"
  key_links:
    - from: "src/handlers/issue-opened.ts"
      to: "src/triage/threshold-learner.ts"
      via: "import and call getEffectiveThreshold"
      pattern: "getEffectiveThreshold"
    - from: "src/handlers/issue-closed.ts"
      to: "src/triage/threshold-learner.ts"
      via: "import and call recordObservation"
      pattern: "recordObservation"
    - from: "src/handlers/issue-opened.ts"
      to: "src/triage/duplicate-detector.ts"
      via: "passes resolved threshold to findDuplicateCandidates"
      pattern: "threshold:"
---

<objective>
Wire the threshold-learner module into the issue-opened and issue-closed handlers. The issue-opened handler reads the effective threshold (learned or config fallback) instead of the static config value. The issue-closed handler records observations into the Bayesian state after inserting outcomes.

Purpose: Connects the learning engine to the live system. Without this wiring, the threshold-learner module exists but is never called -- thresholds remain static and no observations accumulate.

Output: Modified `issue-opened.ts` and `issue-closed.ts` with threshold-learner integration, structured logging, and updated tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/113-threshold-learning/113-RESEARCH.md
@.planning/phases/113-threshold-learning/113-01-SUMMARY.md

@src/handlers/issue-opened.ts
@src/handlers/issue-opened.test.ts
@src/handlers/issue-closed.ts
@src/handlers/issue-closed.test.ts
@src/triage/threshold-learner.ts

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from 113-01 output. -->

From src/triage/threshold-learner.ts:
```typescript
export type EffectiveThresholdResult = {
  threshold: number;
  source: "learned" | "config";
  alpha?: number;
  beta?: number;
  sampleCount?: number;
};

export async function getEffectiveThreshold(params: {
  sql: Sql;
  repo: string;
  configThreshold: number;
  minSamples?: number;   // default: 20
  floor?: number;        // default: 50
  ceiling?: number;      // default: 95
  logger: Logger;
}): Promise<EffectiveThresholdResult>;

export async function recordObservation(params: {
  sql: Sql;
  repo: string;
  kodiaiPredictedDuplicate: boolean;
  confirmedDuplicate: boolean;
  logger: Logger;
}): Promise<void>;
```

From src/handlers/issue-opened.ts (current threshold usage at line 164):
```typescript
threshold: config.triage.duplicateThreshold ?? 75,
```

From src/handlers/issue-closed.ts (after outcome INSERT, around line 125-135):
```typescript
if (result.length === 0) {
  handlerLogger.info("Outcome already recorded (delivery-ID dedup), skipping");
  return;
}

handlerLogger.info(
  { outcome, confirmedDuplicate, kodiaiPredictedDuplicate, triageId },
  "Issue outcome captured",
);
```

From src/db/client.ts:
```typescript
export type Sql = postgres.Sql;
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire getEffectiveThreshold into issue-opened handler with structured logging</name>
  <files>src/handlers/issue-opened.ts, src/handlers/issue-opened.test.ts</files>
  <action>
**1a. Modify `src/handlers/issue-opened.ts`**

Add import at the top, near other triage imports:

```typescript
import { getEffectiveThreshold } from "../triage/threshold-learner.ts";
```

Replace the static threshold read at line 164. The current code is:

```typescript
// 5. Run duplicate detection
const candidates = await findDuplicateCandidates({
  issueStore,
  embeddingProvider,
  title: issue.title,
  body: issue.body,
  repo,
  excludeIssueNumber: issueNumber,
  threshold: config.triage.duplicateThreshold ?? 75,
  maxCandidates: config.triage.maxDuplicateCandidates ?? 3,
  logger: handlerLogger,
});
```

Change to:

```typescript
// 5. Resolve effective threshold (Bayesian learned or config fallback)
let effectiveThreshold: number;
try {
  const thresholdResult = await getEffectiveThreshold({
    sql,
    repo,
    configThreshold: config.triage.duplicateThreshold ?? 75,
    logger: handlerLogger,
  });
  effectiveThreshold = thresholdResult.threshold;

  // Structured logging on threshold resolution (LEARN-04)
  handlerLogger.info({
    thresholdSource: thresholdResult.source,
    effectiveThreshold: thresholdResult.threshold,
    configThreshold: config.triage.duplicateThreshold ?? 75,
    ...(thresholdResult.source === "learned" ? {
      alpha: thresholdResult.alpha,
      beta: thresholdResult.beta,
      sampleCount: thresholdResult.sampleCount,
    } : {}),
  }, "Duplicate detection threshold resolved");
} catch (err) {
  // Fail-open: if threshold learning fails, use config value
  effectiveThreshold = config.triage.duplicateThreshold ?? 75;
  handlerLogger.warn({ err }, "Threshold learning failed, using config fallback");
}

// 6. Run duplicate detection
const candidates = await findDuplicateCandidates({
  issueStore,
  embeddingProvider,
  title: issue.title,
  body: issue.body,
  repo,
  excludeIssueNumber: issueNumber,
  threshold: effectiveThreshold,
  maxCandidates: config.triage.maxDuplicateCandidates ?? 3,
  logger: handlerLogger,
});
```

Key details:
- `getEffectiveThreshold` is called with defaults for `minSamples` (20), `floor` (50), `ceiling` (95) -- these are the module defaults per LEARN-02 and LEARN-03.
- Fail-open: if `getEffectiveThreshold` throws (DB issue, etc.), fall back to config threshold silently.
- Structured log includes `thresholdSource`, `effectiveThreshold`, `configThreshold`, and Bayesian state (alpha, beta, sampleCount) when source is "learned".
- Adjust subsequent comment numbers (5 -> 5 threshold, 6 -> duplicate detection, etc.) to keep numbering logical.
- Do NOT modify `duplicate-detector.ts` -- it already accepts threshold as a parameter.

**1b. Add tests to `src/handlers/issue-opened.test.ts`**

Add two new tests to the existing `describe("createIssueOpenedHandler")` block.

**Test: "uses learned threshold when available"**

This test verifies that when `getEffectiveThreshold` would return a learned threshold, the handler uses it. Since we cannot easily mock an imported function, the approach is to use the SQL mock to return threshold state data:

Create a mock SQL that:
- Call 1 (INSERT claim): returns `[{ id: 1 }]`
- Call 2 (SELECT triage_threshold_state): returns `[{ alpha: 18, beta_: 4, sample_count: 25 }]` (enough samples for learned threshold)
- Subsequent calls: return `[]`

Use issue store with search results that have a similarity of 90% (distance 0.1). With the default config threshold of 75, these would be returned. With a learned threshold, they should also be returned (the learned threshold from alpha=18, beta=4 would be clamped to 50).

Verify the handler completes successfully (comment is posted).

The important thing to verify is that the SQL query for `triage_threshold_state` is executed. Track calls and check that one contains the string "triage_threshold_state".

**Test: "falls back to config threshold when getEffectiveThreshold query returns no rows"**

Create a mock SQL that:
- Call 1 (INSERT claim): returns `[{ id: 1 }]`
- Call 2 (SELECT triage_threshold_state): returns `[]` (no Bayesian state)
- Subsequent calls: return `[]`

Use search results above threshold=75 (90% similarity). Verify comment is posted (threshold resolution fell back to config, duplicates still found).

Track SQL calls to verify `triage_threshold_state` was queried but returned no rows, and the handler still continued.
  </action>
  <verify>
    bun test src/handlers/issue-opened.test.ts
  </verify>
  <done>
    issue-opened.ts imports and calls getEffectiveThreshold before findDuplicateCandidates.
    Structured log emitted with threshold source, value, and Bayesian state when learned.
    Fail-open: config fallback on getEffectiveThreshold failure.
    New tests verify learned threshold path and config fallback path.
    All existing tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire recordObservation into issue-closed handler with triage gate</name>
  <files>src/handlers/issue-closed.ts, src/handlers/issue-closed.test.ts</files>
  <action>
**2a. Modify `src/handlers/issue-closed.ts`**

Add import at the top:

```typescript
import { recordObservation } from "../triage/threshold-learner.ts";
```

After the successful outcome INSERT (after `result.length === 0` dedup check, before the final `handlerLogger.info`), add the threshold learning observation call. The current code at line 127-135 is:

```typescript
if (result.length === 0) {
  handlerLogger.info("Outcome already recorded (delivery-ID dedup), skipping");
  return;
}

handlerLogger.info(
  { outcome, confirmedDuplicate, kodiaiPredictedDuplicate, triageId },
  "Issue outcome captured",
);
```

Add AFTER the dedup check and BEFORE the final info log:

```typescript
if (result.length === 0) {
  handlerLogger.info("Outcome already recorded (delivery-ID dedup), skipping");
  return;
}

// Update threshold learning state (LEARN-01)
// Only when triage_id exists -- means Kodiai actually triaged this issue
if (triageId !== null) {
  try {
    await recordObservation({
      sql,
      repo,
      kodiaiPredictedDuplicate,
      confirmedDuplicate,
      logger: handlerLogger,
    });
  } catch (err) {
    handlerLogger.warn({ err, repo }, "Threshold learning observation failed (non-fatal)");
  }
}

handlerLogger.info(
  { outcome, confirmedDuplicate, kodiaiPredictedDuplicate, triageId },
  "Issue outcome captured",
);
```

Key details:
- Gate on `triageId !== null` -- only learn from issues that Kodiai actually triaged (research pitfall #2).
- Wrapped in try/catch -- threshold learning failure must NOT prevent outcome capture from completing.
- Log at `warn` level on failure (non-fatal, same pattern as comment_github_id storage).
- `recordObservation` internally skips pure TN (predicted=false, confirmed=false), so we don't need to check here.
- This goes AFTER the dedup early-return (line 127-129) so we only learn from new outcomes, not redelivered ones.

**2b. Add tests to `src/handlers/issue-closed.test.ts`**

The existing test file (if created by 112-01) should already have mock SQL patterns. Add new tests.

First, create a SQL mock helper if not already present. The mock needs to:
- Distinguish SELECT (triage lookup) vs INSERT (outcome) vs INSERT/UPSERT (threshold state) calls by inspecting template strings.

Create `createTrackingSqlForClosed` helper:
```typescript
function createTrackingSqlForClosed(opts: {
  triageRows?: any[];
  insertReturns?: any[];
}): { sql: Sql; calls: Array<{ strings: string[]; values: unknown[] }> } {
  const calls: Array<{ strings: string[]; values: unknown[] }> = [];
  const fn = (...args: any[]) => {
    if (Array.isArray(args[0])) {
      const strings = Array.from(args[0]) as string[];
      const joined = strings.join("");
      calls.push({ strings, values: args.slice(1) });

      if (joined.includes("SELECT") && joined.includes("issue_triage_state")) {
        return Promise.resolve(opts.triageRows ?? []);
      }
      if (joined.includes("INSERT") && joined.includes("issue_outcome_feedback")) {
        return Promise.resolve(opts.insertReturns ?? [{ id: 1 }]);
      }
      // triage_threshold_state UPSERT or any other call
      return Promise.resolve([]);
    }
    return Promise.resolve([]);
  };
  const sql = new Proxy(fn, {
    apply: (_target, _thisArg, args) => fn(...args),
  }) as unknown as Sql;
  return { sql, calls };
}
```

**Test: "calls recordObservation after outcome insert when triage_id is not null"**

Setup:
- `triageRows: [{ id: 42, duplicate_count: 2 }]` (triage exists, predicted duplicate)
- Event with `state_reason: "duplicate"` (confirmed duplicate)
- `insertReturns: [{ id: 1 }]` (insert succeeds, not a dedup)

Assertions:
- Verify a SQL call contains `triage_threshold_state` in the template strings (the UPSERT from recordObservation).
- The call exists after the outcome INSERT call.

**Test: "does NOT call recordObservation when triage_id is null"**

Setup:
- `triageRows: []` (no triage record)
- Event with `state_reason: "completed"`
- `insertReturns: [{ id: 1 }]`

Assertions:
- Verify NO SQL call contains `triage_threshold_state`.

**Test: "does NOT call recordObservation on delivery-ID dedup"**

Setup:
- `triageRows: [{ id: 42, duplicate_count: 2 }]`
- Event with `state_reason: "duplicate"`
- `insertReturns: []` (dedup -- ON CONFLICT returned nothing)

Assertions:
- Verify NO SQL call contains `triage_threshold_state` (handler returned early before recordObservation).

**Test: "continues when recordObservation fails (fail-open)"**

Setup:
- `triageRows: [{ id: 42, duplicate_count: 2 }]`
- Event with `state_reason: "duplicate"`
- Override the SQL mock: make it throw when `triage_threshold_state` is in the template.

Create a modified mock that throws on threshold state calls:
```typescript
const fn = (...args: any[]) => {
  if (Array.isArray(args[0])) {
    const joined = Array.from(args[0]).join("");
    if (joined.includes("triage_threshold_state")) {
      return Promise.reject(new Error("DB connection lost"));
    }
    // ... normal routing for SELECT/INSERT
  }
};
```

Assertions:
- Handler does not throw.
- The outcome was still successfully inserted (verify the INSERT call for issue_outcome_feedback exists in calls).
  </action>
  <verify>
    bun test src/handlers/issue-closed.test.ts && bun test src/handlers/issue-opened.test.ts
  </verify>
  <done>
    issue-closed.ts imports and calls recordObservation after outcome insert.
    Gate: only when triageId is not null (Kodiai triaged the issue).
    Fail-open: recordObservation failure logged at warn, does not crash handler.
    Not called on delivery-ID dedup (early return before observation).
    issue-opened.ts uses getEffectiveThreshold with structured logging.
    All tests pass in both test files.
  </done>
</task>

</tasks>

<verification>
1. `bun test src/handlers/issue-opened.test.ts` -- all tests pass
2. `bun test src/handlers/issue-closed.test.ts` -- all tests pass
3. `bun build src/handlers/issue-opened.ts --no-bundle` -- compiles clean
4. `bun build src/handlers/issue-closed.ts --no-bundle` -- compiles clean
5. Grep confirms `getEffectiveThreshold` imported and called in issue-opened.ts
6. Grep confirms `recordObservation` imported and called in issue-closed.ts
7. Grep confirms `triageId !== null` gate before recordObservation in issue-closed.ts
8. Grep confirms `thresholdSource` in structured log in issue-opened.ts
9. Grep confirms `config.triage.duplicateThreshold ?? 75` is ONLY used as configThreshold parameter, not directly passed to findDuplicateCandidates
</verification>

<success_criteria>
- issue-opened handler resolves threshold via getEffectiveThreshold (learned or config fallback)
- Structured log on every threshold resolution with source, value, and Bayesian state
- getEffectiveThreshold failure is fail-open (config fallback)
- issue-closed handler calls recordObservation after outcome insert, gated on triageId != null
- recordObservation failure is fail-open (logged, not thrown)
- No recordObservation on delivery-ID dedup (early return)
- All tests pass in both handler test files
- No modifications to duplicate-detector.ts
</success_criteria>

<output>
After completion, create `.planning/phases/113-threshold-learning/113-02-SUMMARY.md`
</output>
