---
phase: 113-threshold-learning
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/migrations/018-triage-threshold-state.sql
  - src/db/migrations/018-triage-threshold-state.down.sql
  - src/triage/threshold-learner.ts
  - src/triage/threshold-learner.test.ts
autonomous: true
requirements: [LEARN-01, LEARN-02, LEARN-03]

must_haves:
  truths:
    - "Beta-Binomial state (alpha, beta_, sample_count) is stored per repo in triage_threshold_state"
    - "classifyOutcome correctly maps all four confusion matrix quadrants (TP, FP, FN, TN)"
    - "recordObservation atomically increments alpha or beta_ via SQL UPSERT (no read-then-write race)"
    - "getEffectiveThreshold returns config fallback when sample_count < 20 (LEARN-02)"
    - "getEffectiveThreshold clamps returned threshold to [50, 95] range (LEARN-03)"
    - "With uniform prior (alpha=1, beta=1) and no observations, getEffectiveThreshold returns config fallback"
  artifacts:
    - path: "src/db/migrations/018-triage-threshold-state.sql"
      provides: "triage_threshold_state table with per-repo Bayesian state"
      contains: "CREATE TABLE IF NOT EXISTS triage_threshold_state"
    - path: "src/db/migrations/018-triage-threshold-state.down.sql"
      provides: "Rollback for migration 018"
      contains: "DROP TABLE IF EXISTS triage_threshold_state"
    - path: "src/triage/threshold-learner.ts"
      provides: "Pure Beta-Binomial functions and DB-boundary functions"
      exports: ["classifyOutcome", "recordObservation", "getEffectiveThreshold", "posteriorMean", "posteriorToThreshold"]
    - path: "src/triage/threshold-learner.test.ts"
      provides: "Unit tests for all threshold-learner functions"
      contains: "classifyOutcome"
  key_links:
    - from: "src/triage/threshold-learner.ts"
      to: "src/db/migrations/018-triage-threshold-state.sql"
      via: "INSERT INTO triage_threshold_state ON CONFLICT DO UPDATE"
      pattern: "triage_threshold_state"
    - from: "src/triage/threshold-learner.ts"
      to: "src/db/migrations/018-triage-threshold-state.sql"
      via: "SELECT alpha, beta_, sample_count FROM triage_threshold_state"
      pattern: "triage_threshold_state"
---

<objective>
Create the database migration for per-repo Bayesian threshold state and implement the pure threshold-learner module with Beta-Binomial updating, sample gate, and clamping.

Purpose: This is the learning engine for duplicate detection. Without it, the threshold is a static config value that cannot adapt to a repo's actual false positive/negative rate. The Beta-Binomial model is the simplest Bayesian approach -- two counters (alpha, beta) that update with each observation.

Output: Migration 018, `src/triage/threshold-learner.ts` with pure functions + DB-boundary functions, and comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/113-threshold-learning/113-RESEARCH.md

@src/db/migrations/017-issue-outcome-feedback.sql
@src/db/migrations/016-issue-triage-state.sql
@src/triage/duplicate-detector.ts
@src/knowledge/adaptive-threshold.ts
@src/handlers/issue-opened.test.ts

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/db/client.ts:
```typescript
export type Sql = postgres.Sql;
```

From src/db/migrations/017-issue-outcome-feedback.sql (Phase 112 -- the outcome table this module reads from conceptually):
```sql
CREATE TABLE IF NOT EXISTS issue_outcome_feedback (
  id BIGSERIAL PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  repo TEXT NOT NULL,
  issue_number INTEGER NOT NULL,
  triage_id BIGINT REFERENCES issue_triage_state(id) ON DELETE SET NULL,
  outcome TEXT NOT NULL,
  kodiai_predicted_duplicate BOOLEAN NOT NULL DEFAULT false,
  confirmed_duplicate BOOLEAN NOT NULL DEFAULT false,
  state_reason TEXT,
  label_names TEXT[] NOT NULL DEFAULT '{}',
  delivery_id TEXT NOT NULL,
  UNIQUE(repo, issue_number),
  UNIQUE(delivery_id)
);
```

From src/knowledge/adaptive-threshold.ts (clamp pattern already in codebase):
```typescript
function clamp(value: number, min: number, max: number): number {
  return Math.max(min, Math.min(max, value));
}
```

From src/handlers/issue-opened.test.ts (mock SQL pattern to follow):
```typescript
function createMockSql(claimSuccess: boolean = true): Sql {
  const fn = async (...args: any[]) => {
    return claimSuccess ? [{ id: 1 }] : [];
  };
  return new Proxy(fn, {
    apply: (_target, _thisArg, args) => fn(...args),
  }) as unknown as Sql;
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration 018 for triage_threshold_state table</name>
  <files>src/db/migrations/018-triage-threshold-state.sql, src/db/migrations/018-triage-threshold-state.down.sql</files>
  <action>
**1a. Create `src/db/migrations/018-triage-threshold-state.sql`:**

```sql
-- 018-triage-threshold-state.sql
-- Per-repo Bayesian state for duplicate detection threshold learning (LEARN-01)

CREATE TABLE IF NOT EXISTS triage_threshold_state (
  id BIGSERIAL PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  repo TEXT NOT NULL,

  -- Beta-Binomial parameters (uniform prior: alpha=1, beta=1)
  alpha DOUBLE PRECISION NOT NULL DEFAULT 1.0,
  beta_ DOUBLE PRECISION NOT NULL DEFAULT 1.0,

  -- Bookkeeping
  sample_count INTEGER NOT NULL DEFAULT 0,

  UNIQUE(repo)
);

CREATE INDEX IF NOT EXISTS idx_triage_threshold_state_repo
  ON triage_threshold_state (repo);
```

Column naming: `beta_` with trailing underscore because `beta` can clash with reserved words in some SQL contexts. This matches the research recommendation.

**1b. Create `src/db/migrations/018-triage-threshold-state.down.sql`:**

```sql
DROP TABLE IF EXISTS triage_threshold_state;
```
  </action>
  <verify>
    ls -la src/db/migrations/018-triage-threshold-state.sql src/db/migrations/018-triage-threshold-state.down.sql
  </verify>
  <done>
    Migration 018 creates triage_threshold_state with repo (UNIQUE), alpha, beta_, sample_count, timestamps.
    Rollback drops the table.
    Index on repo exists.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement threshold-learner module with pure functions and DB-boundary functions</name>
  <files>src/triage/threshold-learner.ts, src/triage/threshold-learner.test.ts</files>
  <action>
**2a. Create `src/triage/threshold-learner.ts`**

The module has two layers: pure computation (no DB, no side effects) and DB-boundary functions.

**Pure functions:**

```typescript
import type { Sql } from "../db/client.ts";
import type { Logger } from "pino";

// ── Pure computation (no DB, no side effects) ────────────────────────────

export type OutcomeClassification = {
  correct: boolean;
  quadrant: "TP" | "FP" | "FN" | "TN";
};

/**
 * Classify a prediction outcome into the confusion matrix.
 * TP/TN = correct (alpha++), FP/FN = incorrect (beta++).
 */
export function classifyOutcome(
  kodiaiPredictedDuplicate: boolean,
  confirmedDuplicate: boolean,
): OutcomeClassification {
  if (kodiaiPredictedDuplicate && confirmedDuplicate) {
    return { correct: true, quadrant: "TP" };
  }
  if (kodiaiPredictedDuplicate && !confirmedDuplicate) {
    return { correct: false, quadrant: "FP" };
  }
  if (!kodiaiPredictedDuplicate && confirmedDuplicate) {
    return { correct: false, quadrant: "FN" };
  }
  return { correct: true, quadrant: "TN" };
}

/**
 * Posterior mean of the Beta distribution: alpha / (alpha + beta).
 * Represents the estimated probability that predictions are correct.
 */
export function posteriorMean(alpha: number, beta: number): number {
  return alpha / (alpha + beta);
}

/**
 * Convert Beta posterior to a similarity threshold in [floor, ceiling].
 *
 * High accuracy (mean near 1) -> lower threshold (catch more duplicates).
 * Low accuracy (mean near 0) -> higher threshold (be more selective).
 *
 * Formula: raw = 100 * (1 - mean), then clamp to [floor, ceiling].
 */
export function posteriorToThreshold(
  alpha: number,
  beta: number,
  floor: number,
  ceiling: number,
): number {
  const mean = posteriorMean(alpha, beta);
  const raw = Math.round(100 * (1 - mean));
  return Math.max(floor, Math.min(ceiling, raw));
}
```

**DB-boundary functions:**

```typescript
// ── DB-boundary functions ────────────────────────────────────────────────

/**
 * Atomically record an observation into triage_threshold_state.
 * Uses UPSERT with SQL-side increment to avoid read-then-write race conditions.
 *
 * Only call when the outcome is relevant to duplicate detection accuracy:
 * - kodiaiPredictedDuplicate=true (TP or FP), OR
 * - confirmedDuplicate=true (TP or FN)
 * Skip pure TN (predicted=false, confirmed=false) to avoid drowning the signal.
 */
export async function recordObservation(params: {
  sql: Sql;
  repo: string;
  kodiaiPredictedDuplicate: boolean;
  confirmedDuplicate: boolean;
  logger: Logger;
}): Promise<void> {
  const { sql, repo, kodiaiPredictedDuplicate, confirmedDuplicate, logger } = params;

  // Skip pure TN -- no signal for duplicate detection tuning
  if (!kodiaiPredictedDuplicate && !confirmedDuplicate) {
    logger.debug({ repo }, "Skipping TN observation for threshold learning (no signal)");
    return;
  }

  const { correct, quadrant } = classifyOutcome(kodiaiPredictedDuplicate, confirmedDuplicate);
  const alphaInc = correct ? 1 : 0;
  const betaInc = correct ? 0 : 1;

  await sql`
    INSERT INTO triage_threshold_state (repo, alpha, beta_, sample_count)
    VALUES (${repo}, ${1.0 + alphaInc}, ${1.0 + betaInc}, 1)
    ON CONFLICT (repo) DO UPDATE SET
      alpha = triage_threshold_state.alpha + ${alphaInc},
      beta_ = triage_threshold_state.beta_ + ${betaInc},
      sample_count = triage_threshold_state.sample_count + 1,
      updated_at = now()
  `;

  logger.info(
    { repo, quadrant, correct, alphaInc, betaInc },
    "Threshold learning observation recorded",
  );
}

export type EffectiveThresholdResult = {
  threshold: number;
  source: "learned" | "config";
  alpha?: number;
  beta?: number;
  sampleCount?: number;
};

/**
 * Resolve the effective duplicate detection threshold for a repo.
 *
 * Resolution chain:
 * 1. Query triage_threshold_state for this repo
 * 2. If no row or sample_count < minSamples (LEARN-02: 20), return configThreshold
 * 3. Compute from alpha/beta, clamp to [floor, ceiling] (LEARN-03: [50, 95])
 */
export async function getEffectiveThreshold(params: {
  sql: Sql;
  repo: string;
  configThreshold: number;
  minSamples?: number;
  floor?: number;
  ceiling?: number;
  logger: Logger;
}): Promise<EffectiveThresholdResult> {
  const {
    sql,
    repo,
    configThreshold,
    minSamples = 20,
    floor = 50,
    ceiling = 95,
    logger,
  } = params;

  const rows = await sql`
    SELECT alpha, beta_, sample_count
    FROM triage_threshold_state
    WHERE repo = ${repo}
  `;

  if (rows.length === 0 || (rows[0].sample_count as number) < minSamples) {
    return { threshold: configThreshold, source: "config" };
  }

  const alpha = rows[0].alpha as number;
  const beta = rows[0].beta_ as number;
  const sampleCount = rows[0].sample_count as number;
  const threshold = posteriorToThreshold(alpha, beta, floor, ceiling);

  logger.info(
    { repo, threshold, alpha, beta, sampleCount, source: "learned" },
    "Using learned threshold for duplicate detection",
  );

  return { threshold, source: "learned", alpha, beta, sampleCount };
}
```

Key design decisions:
- Pure TN observations are SKIPPED (research recommendation #2) -- they flood alpha with no duplicate-detection signal.
- `recordObservation` uses atomic SQL-side increment (`alpha = triage_threshold_state.alpha + $inc`) to avoid race conditions (research pitfall #5).
- `getEffectiveThreshold` defaults: `minSamples=20` (LEARN-02), `floor=50`, `ceiling=95` (LEARN-03).
- Do NOT import or modify `duplicate-detector.ts` -- it already accepts threshold as a parameter.

**2b. Create `src/triage/threshold-learner.test.ts`**

Use `bun:test`. Pure function tests need no mocks. DB-boundary function tests use the Proxy-based mock SQL pattern from `issue-opened.test.ts`.

**Pure function tests:**

1. **"classifyOutcome: TP -- predicted=true, confirmed=true"** -- returns `{ correct: true, quadrant: "TP" }`
2. **"classifyOutcome: FP -- predicted=true, confirmed=false"** -- returns `{ correct: false, quadrant: "FP" }`
3. **"classifyOutcome: FN -- predicted=false, confirmed=true"** -- returns `{ correct: false, quadrant: "FN" }`
4. **"classifyOutcome: TN -- predicted=false, confirmed=false"** -- returns `{ correct: true, quadrant: "TN" }`
5. **"posteriorMean: uniform prior"** -- `posteriorMean(1, 1)` returns `0.5`
6. **"posteriorMean: strong alpha"** -- `posteriorMean(10, 2)` returns approximately `0.833`
7. **"posteriorToThreshold: uniform prior clamps to floor"** -- `posteriorToThreshold(1, 1, 50, 95)` returns `50` (raw = 50, equals floor)
8. **"posteriorToThreshold: high accuracy lowers threshold"** -- `posteriorToThreshold(20, 2, 50, 95)` should return a value near 50 (floor), because high mean -> low raw threshold
9. **"posteriorToThreshold: low accuracy raises threshold"** -- `posteriorToThreshold(2, 20, 50, 95)` should return a value near 95 (ceiling), because low mean -> high raw threshold
10. **"posteriorToThreshold: clamps above ceiling"** -- `posteriorToThreshold(1, 100, 50, 95)` returns `95` (raw would be 99, clamped to 95)
11. **"posteriorToThreshold: clamps below floor"** -- `posteriorToThreshold(100, 1, 50, 95)` returns `50` (raw would be 1, clamped to 50)

**DB-boundary function tests (mock SQL):**

Create a `createTrackingSql` helper that returns a mock Sql and a `calls` array. Each call captures `{ strings: string[], values: unknown[] }`. Configure return values per-call.

12. **"recordObservation: skips TN (no signal)"** -- Call with `predicted=false, confirmed=false`. Verify SQL was NOT called (calls array empty).

13. **"recordObservation: TP increments alpha atomically"** -- Call with `predicted=true, confirmed=true`. Verify SQL called once, template contains `triage_threshold_state`, values include `alphaInc=1` and `betaInc=0` (check that the passed values include `1` for alpha increment and `0` for beta increment at the correct positions).

14. **"recordObservation: FP increments beta atomically"** -- Call with `predicted=true, confirmed=false`. Verify SQL called once, values include `alphaInc=0` and `betaInc=1`.

15. **"recordObservation: FN increments beta atomically"** -- Call with `predicted=false, confirmed=true`. Verify SQL called once, values include `betaInc=1`.

16. **"getEffectiveThreshold: returns config fallback when no rows"** -- Mock SQL returns empty array. Verify returns `{ threshold: 75, source: "config" }` (given configThreshold=75).

17. **"getEffectiveThreshold: returns config fallback when sample_count < minSamples"** -- Mock SQL returns `[{ alpha: 15, beta_: 3, sample_count: 10 }]`. Verify returns `{ threshold: 75, source: "config" }`.

18. **"getEffectiveThreshold: returns learned threshold when sample_count >= 20"** -- Mock SQL returns `[{ alpha: 18, beta_: 4, sample_count: 25 }]`. Compute expected: `mean = 18/22 = 0.818`, `raw = round(100 * (1 - 0.818)) = round(18.18) = 18`, clamped to `[50, 95]` = `50`. Verify returns `{ threshold: 50, source: "learned", alpha: 18, beta: 4, sampleCount: 25 }`.

19. **"getEffectiveThreshold: returns clamped threshold at ceiling"** -- Mock SQL returns `[{ alpha: 2, beta_: 20, sample_count: 21 }]`. Compute expected: `mean = 2/22 = 0.0909`, `raw = round(100 * 0.909) = 91`, clamped to `[50, 95]` = `91`. Verify returns `{ threshold: 91, source: "learned" }`.

20. **"getEffectiveThreshold: exact boundary at minSamples=20"** -- Mock SQL returns `[{ alpha: 10, beta_: 10, sample_count: 20 }]` (exactly 20). Verify source is `"learned"` (>= gate, not > gate).

For the mock SQL helper:
```typescript
function createTrackingSql(returnValues: any[][] = [[]]): { sql: Sql; calls: Array<{ strings: string[]; values: unknown[] }> } {
  const calls: Array<{ strings: string[]; values: unknown[] }> = [];
  let callIndex = 0;
  const fn = (...args: any[]) => {
    if (Array.isArray(args[0])) {
      calls.push({ strings: Array.from(args[0]), values: args.slice(1) });
    }
    const result = returnValues[callIndex] ?? [];
    callIndex++;
    return Promise.resolve(result);
  };
  const sql = new Proxy(fn, {
    apply: (_target, _thisArg, args) => fn(...args),
  }) as unknown as Sql;
  return { sql, calls };
}
```

For the mock logger, reuse the same pattern from issue-opened.test.ts:
```typescript
function createMockLogger(): Logger {
  return {
    warn: () => {},
    info: () => {},
    debug: () => {},
    error: () => {},
    child: () => createMockLogger(),
  } as unknown as Logger;
}
```
  </action>
  <verify>
    bun test src/triage/threshold-learner.test.ts
  </verify>
  <done>
    classifyOutcome maps all 4 quadrants correctly (TP, FP, FN, TN).
    posteriorMean computes alpha/(alpha+beta).
    posteriorToThreshold converts posterior to [floor, ceiling] range.
    recordObservation uses atomic UPSERT, skips TN, increments correct counter.
    getEffectiveThreshold applies 20-sample gate, clamps to [50, 95], falls back to config.
    All 20 tests pass.
  </done>
</task>

</tasks>

<verification>
1. `ls src/db/migrations/018-triage-threshold-state.sql src/db/migrations/018-triage-threshold-state.down.sql` -- both exist
2. `bun test src/triage/threshold-learner.test.ts` -- all tests pass
3. `bun build src/triage/threshold-learner.ts --no-bundle` -- compiles clean
4. Grep confirms `ON CONFLICT (repo) DO UPDATE SET` in threshold-learner.ts (atomic UPSERT)
5. Grep confirms `sample_count` comparison against `minSamples` in threshold-learner.ts
6. Grep confirms `Math.max(floor, Math.min(ceiling` in threshold-learner.ts (clamping)
7. Grep confirms TN skip logic (`!kodiaiPredictedDuplicate && !confirmedDuplicate`) in threshold-learner.ts
</verification>

<success_criteria>
- Migration 018 creates triage_threshold_state with repo UNIQUE, alpha, beta_, sample_count
- Pure functions (classifyOutcome, posteriorMean, posteriorToThreshold) are fully tested
- recordObservation uses atomic SQL UPSERT, skips TN, logs quadrant
- getEffectiveThreshold applies 20-sample gate (LEARN-02), clamps to [50,95] (LEARN-03), falls back to config
- All tests pass
- No modifications to duplicate-detector.ts
</success_criteria>

<output>
After completion, create `.planning/phases/113-threshold-learning/113-01-SUMMARY.md`
</output>
