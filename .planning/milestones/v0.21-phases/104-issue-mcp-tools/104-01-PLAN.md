---
phase: 104-issue-mcp-tools
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/execution/mcp/issue-label-server.ts
  - src/execution/mcp/issue-label-server.test.ts
autonomous: true
requirements: [MCPT-01]

must_haves:
  truths:
    - "github_issue_label tool applies valid labels to an issue"
    - "Invalid labels are reported but valid labels still applied (partial application)"
    - "Label matching is case-insensitive against repo's canonical casing"
    - "Missing labels produce LABEL_NOT_FOUND error code in response"
    - "Closed issues get a warning flag but labels still applied"
    - "Rate-limited requests retry with exponential backoff"
  artifacts:
    - path: "src/execution/mcp/issue-label-server.ts"
      provides: "github_issue_label MCP server factory"
      exports: ["createIssueLabelServer"]
    - path: "src/execution/mcp/issue-label-server.test.ts"
      provides: "Unit tests for label tool"
      min_lines: 100
  key_links:
    - from: "src/execution/mcp/issue-label-server.ts"
      to: "octokit.rest.issues.addLabels"
      via: "GitHub API call"
      pattern: "addLabels"
    - from: "src/execution/mcp/issue-label-server.ts"
      to: "octokit.rest.issues.listLabelsForRepo"
      via: "Label pre-validation"
      pattern: "listLabelsForRepo"
---

<objective>
Implement the `github_issue_label` MCP tool using TDD.

Purpose: Give the triage agent the ability to apply labels to GitHub issues with pre-validation, case-insensitive matching, and partial application semantics.
Output: `issue-label-server.ts` and `issue-label-server.test.ts`
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
@/home/keith/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/104-issue-mcp-tools/104-CONTEXT.md
@.planning/phases/104-issue-mcp-tools/104-RESEARCH.md

<interfaces>
<!-- Existing MCP server pattern from the codebase -->

From src/execution/mcp/ci-status-server.ts (pattern reference):
```typescript
import { tool, createSdkMcpServer } from "@anthropic-ai/claude-agent-sdk";
import { z } from "zod";
import type { Octokit } from "@octokit/rest";

export function createCIStatusServer(
  getOctokit: () => Promise<Octokit>,
  owner: string,
  repo: string,
  prNumber: number,
) {
  return createSdkMcpServer({
    name: "github_ci",
    version: "0.1.0",
    tools: [
      tool("tool_name", "description", { /* zod schema */ }, async (params) => {
        // Return { content: [{ type: "text", text: JSON.stringify(result) }] }
        // On error: { content: [{ type: "text", text: "Error: ..." }], isError: true }
      }),
    ],
  });
}
```

From src/execution/mcp/index.ts (registration pattern):
```typescript
export function buildMcpServers(deps: {
  getOctokit: () => Promise<Octokit>;
  owner: string;
  repo: string;
  // ...
}): Record<string, McpServerConfig> {
  const servers: Record<string, McpServerConfig> = {};
  // Conditionally add servers based on flags
  return servers;
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write tests for github_issue_label MCP tool</name>
  <files>src/execution/mcp/issue-label-server.test.ts</files>
  <action>
Create test file using bun:test with describe/it/expect. Mock Octokit via manual mock objects (follow existing comment-server.test.ts pattern).

Test cases:
1. **Happy path**: Apply labels ["bug", "priority:high"] to issue #42, repo has both labels. Expect: calls addLabels with both, returns success with applied labels list.
2. **Case-insensitive matching**: Request ["BUG"] when repo has "bug". Expect: resolves to canonical "bug" and applies.
3. **Partial application**: Request ["bug", "nonexistent"]. Repo has "bug" but not "nonexistent". Expect: applies "bug", returns success with `applied: ["bug"]` and `invalid: ["nonexistent"]` with LABEL_NOT_FOUND error code for invalid ones.
4. **All labels invalid**: Request ["fake1", "fake2"]. Expect: returns error with LABEL_NOT_FOUND, no addLabels call.
5. **Closed issue warning**: Issue state is "closed". Expect: labels still applied but response includes `warning: "Issue is closed"`.
6. **Issue not found (404)**: Octokit throws 404. Expect: ISSUE_NOT_FOUND error code.
7. **Permission denied (403)**: Octokit throws 403. Expect: PERMISSION_DENIED error code.
8. **Rate limited (429)**: First call throws 429 with Retry-After, second succeeds. Expect: retry and return success.
9. **Config gating - disabled**: When triageConfig.label.enabled is false, return TOOL_DISABLED error.
10. **Empty labels array**: Request []. Expect: validation error.
11. **Response includes metadata**: Success response includes issue_number, repo, timestamp.

Factory signature:
```typescript
export function createIssueLabelServer(
  getOctokit: () => Promise<Octokit>,
  owner: string,
  repo: string,
  getTriageConfig: () => { enabled: boolean; label: { enabled: boolean } },
)
```

The `getTriageConfig` function is called on every tool invocation (hot-reload support).
  </action>
  <verify>
    <automated>bun test src/execution/mcp/issue-label-server.test.ts 2>&1 | tail -5</automated>
  </verify>
  <done>All test cases written and failing (RED phase - implementation doesn't exist yet)</done>
</task>

<task type="auto">
  <name>Task 2: Implement github_issue_label MCP server</name>
  <files>src/execution/mcp/issue-label-server.ts</files>
  <action>
Create `createIssueLabelServer` factory function following the existing MCP server pattern.

**Tool: `add_labels`**

Zod schema:
```typescript
{
  issue_number: z.number().describe("The issue number"),
  labels: z.array(z.string().min(1)).min(1).describe("Labels to apply (case-insensitive)"),
}
```

Handler logic:
1. Check `getTriageConfig()` -- if `!config.enabled || !config.label.enabled`, return `{ success: false, error_code: "TOOL_DISABLED", message: "Issue label tool is disabled for this repository" }` (not isError, structured JSON).
2. Fetch repo labels via `octokit.rest.issues.listLabelsForRepo({ owner, repo, per_page: 100 })`. Paginate if needed (use `octokit.paginate`).
3. Build case-insensitive map: `Map<lowercase_name, canonical_name>`.
4. For each requested label, look up in map. Split into `validLabels` (resolved to canonical casing) and `invalidLabels`.
5. If ALL labels invalid, return `{ success: false, error_code: "LABEL_NOT_FOUND", message, invalid_labels }`.
6. If some valid, call `octokit.rest.issues.addLabels({ owner, repo, issue_number, labels: validLabels })`.
7. Check issue state: fetch issue via `octokit.rest.issues.get()` and check `data.state`. If "closed", set `warning: "Issue is closed"`.
8. Return rich response:
   ```json
   {
     "success": true,
     "issue_number": 42,
     "repo": "owner/repo",
     "applied": ["bug", "priority:high"],
     "invalid": [],
     "warning": null,
     "timestamp": "2026-02-26T..."
   }
   ```
   If partial: include both `applied` and `invalid` arrays.

**Error handling:**
- Wrap in try/catch. Check `error.status` for HTTP codes:
  - 404 -> `ISSUE_NOT_FOUND`
  - 403 -> `PERMISSION_DENIED`
  - 429 -> retry with exponential backoff (1s, 2s, 4s, max 3 retries). Use `Retry-After` header if present.
  - Other -> `UNKNOWN_ERROR` with message

**Rate limit retry helper:**
```typescript
async function withRetry<T>(fn: () => Promise<T>, maxRetries = 3): Promise<T> {
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try { return await fn(); }
    catch (error) {
      if (error?.status === 429 && attempt < maxRetries) {
        const retryAfter = error?.response?.headers?.['retry-after'];
        const delayMs = retryAfter ? parseInt(retryAfter) * 1000 : Math.pow(2, attempt) * 1000;
        await new Promise(r => setTimeout(r, delayMs));
        continue;
      }
      throw error;
    }
  }
  throw new Error("unreachable");
}
```

Return format follows existing pattern: `{ content: [{ type: "text" as const, text: JSON.stringify(result) }] }`. Only set `isError: true` for unexpected failures, not for structured error responses (TOOL_DISABLED, LABEL_NOT_FOUND, etc.).
  </action>
  <verify>
    <automated>bun test src/execution/mcp/issue-label-server.test.ts 2>&1 | tail -5</automated>
  </verify>
  <done>All 11 test cases pass (GREEN phase)</done>
</task>

</tasks>

<verification>
- `bun test src/execution/mcp/issue-label-server.test.ts` -- all tests pass
- `bun build src/execution/mcp/issue-label-server.ts --no-bundle` -- compiles without errors
</verification>

<success_criteria>
- createIssueLabelServer factory exported
- add_labels tool accepts issue_number + labels array
- Labels pre-validated against repo's label list (case-insensitive)
- Partial application: valid labels applied, invalid reported
- Structured error codes: TOOL_DISABLED, LABEL_NOT_FOUND, ISSUE_NOT_FOUND, PERMISSION_DENIED, RATE_LIMITED
- Closed issue warning included in response
- Rate limit retry with exponential backoff
- Config gating via getTriageConfig() (hot-reload)
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/104-issue-mcp-tools/104-01-SUMMARY.md`
</output>
