---
phase: 103-issue-corpus-schema-store
plan: 02
type: tdd
wave: 2
depends_on: [01]
files_modified:
  - src/knowledge/issue-store.ts
  - src/knowledge/issue-store.test.ts
autonomous: true
requirements: [ICORP-02]

must_haves:
  truths:
    - IssueStore provides typed CRUD (upsert, delete, getByNumber) for issues
    - IssueStore provides hybrid search (vector + BM25) matching ReviewCommentStore pattern
    - IssueStore provides findSimilar method for duplicate detection
    - IssueStore provides comment CRUD (upsertComment, deleteComment, getCommentsByIssue)
    - All store methods have passing tests against real PostgreSQL
  artifacts:
    - src/knowledge/issue-store.ts
    - src/knowledge/issue-store.test.ts
  key_links:
    - issue-store.ts exports createIssueStore factory function
    - issue-store.ts implements IssueStore interface from issue-types.ts
---

<objective>
Implement the IssueStore using TDD — tests first, then implementation.

Purpose: The store is the typed interface for all issue corpus operations. Phase 105 triage agent depends on this.
Output: issue-store.ts factory and comprehensive test suite.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
@/home/keith/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/103-issue-corpus-schema-store/103-RESEARCH.md
@.planning/phases/103-issue-corpus-schema-store/103-01-SUMMARY.md

<interfaces>
<!-- Types from Plan 01 that this plan implements -->

From src/knowledge/issue-types.ts:
```typescript
export type IssueStore = {
  upsert(issue: IssueInput): Promise<void>;
  delete(repo: string, issueNumber: number): Promise<void>;
  getByNumber(repo: string, issueNumber: number): Promise<IssueRecord | null>;
  searchByEmbedding(params: { queryEmbedding: Float32Array; repo: string; topK: number }): Promise<IssueSearchResult[]>;
  searchByFullText(params: { query: string; repo: string; topK: number }): Promise<IssueSearchResult[]>;
  findSimilar(repo: string, issueNumber: number, threshold?: number): Promise<IssueSearchResult[]>;
  countByRepo(repo: string): Promise<number>;
  upsertComment(comment: IssueCommentInput): Promise<void>;
  deleteComment(repo: string, commentGithubId: number): Promise<void>;
  getCommentsByIssue(repo: string, issueNumber: number): Promise<IssueCommentRecord[]>;
  searchCommentsByEmbedding(params: { queryEmbedding: Float32Array; repo: string; topK: number }): Promise<IssueCommentSearchResult[]>;
};
```

From src/knowledge/review-comment-store.ts (reference implementation pattern):
```typescript
export function createReviewCommentStore(opts: { sql: Sql; logger: Logger }): ReviewCommentStore { ... }
// Uses float32ArrayToVectorString() helper for pgvector conversion
// Uses postgres.js tagged template literals
// Vector search: embedding <=> ${queryStr}::vector AS distance, ORDER BY distance, LIMIT topK
// Full-text: ts_rank(search_tsv, plainto_tsquery('english', query)) AS rank
```

From src/db/client.ts:
```typescript
export type Sql = ReturnType<typeof postgres>;
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write tests for IssueStore (RED phase)</name>
  <files>src/knowledge/issue-store.test.ts</files>
  <action>
Create `src/knowledge/issue-store.test.ts` following the pattern from `review-comment-store.test.ts`.

Test setup:
- Connect to `postgresql://kodiai:kodiai@localhost:5432/kodiai`
- Run migrations in beforeAll
- Clean `issue_comments` then `issues` tables in beforeEach (comments first due to potential FK queries)
- Close DB in afterAll
- Use same mockLogger pattern as review-comment-store.test.ts

Helper functions:
```typescript
function makeIssue(overrides: Partial<IssueInput> = {}): IssueInput {
  return {
    repo: "xbmc/xbmc",
    owner: "xbmc",
    issueNumber: 100,
    title: "Playback crashes on HDR content",
    body: "When playing HDR content on Android TV, the app crashes immediately.",
    state: "open",
    authorLogin: "alice",
    authorAssociation: "NONE",
    labelNames: ["bug", "playback"],
    templateSlug: "bug_report",
    commentCount: 2,
    assignees: [{ id: 1, login: "bob" }],
    milestone: "v21.0",
    reactionCount: 5,
    isPullRequest: false,
    locked: false,
    githubCreatedAt: new Date("2025-01-15T10:00:00Z"),
    githubUpdatedAt: null,
    closedAt: null,
    ...overrides,
  };
}

function makeComment(overrides: Partial<IssueCommentInput> = {}): IssueCommentInput {
  return {
    repo: "xbmc/xbmc",
    issueNumber: 100,
    commentGithubId: 5000,
    authorLogin: "bob",
    authorAssociation: "MEMBER",
    body: "I can reproduce this on Android 14.",
    githubCreatedAt: new Date("2025-01-16T10:00:00Z"),
    githubUpdatedAt: null,
    ...overrides,
  };
}

function makeEmbedding(seed: number = 42): Float32Array {
  // Same deterministic embedding generator as review-comment-store.test.ts
  const arr = new Float32Array(1024);
  let val = seed;
  for (let i = 0; i < 1024; i++) {
    val = ((val * 1664525 + 1013904223) & 0xffffffff) >>> 0;
    arr[i] = (val / 0xffffffff) * 2 - 1;
  }
  let norm = 0;
  for (let i = 0; i < 1024; i++) norm += arr[i]! * arr[i]!;
  norm = Math.sqrt(norm);
  for (let i = 0; i < 1024; i++) arr[i] = arr[i]! / norm;
  return arr;
}
```

Test cases (describe "IssueStore (pgvector)"):

**Issue CRUD tests:**
1. `upsert creates a new issue` — upsert, getByNumber, verify all fields
2. `upsert updates existing issue on conflict` — upsert, change title+state, upsert again, verify update
3. `delete removes issue` — upsert, delete, getByNumber returns null
4. `getByNumber returns null for missing issue` — getByNumber on nonexistent returns null
5. `countByRepo returns correct count` — upsert 2 issues (different numbers), countByRepo returns 2

**Issue search tests:**
6. `searchByEmbedding returns closest vectors` — upsert 2 issues with different embeddings (seeds 42 and 99), search with seed-42 embedding, verify first result is that issue
7. `searchByFullText finds issues by title and body` — upsert issue with "HDR playback crash", search "HDR crash", verify found
8. `searchByFullText finds issues by label names` — upsert issue with labels ["bug", "playback"], search "playback", verify found
9. `findSimilar finds related issues excluding self` — upsert 3 issues (seeds 42, 43, 99), call findSimilar on issue #100 (seed 42), verify issue with seed 43 appears but issue #100 does not

**Comment CRUD tests:**
10. `upsertComment creates a new comment` — upsertComment, getCommentsByIssue, verify fields
11. `upsertComment updates on conflict` — upsertComment, change body, upsertComment again, verify update
12. `deleteComment removes comment` — upsertComment, deleteComment, getCommentsByIssue returns empty
13. `getCommentsByIssue returns comments ordered by creation time` — upsert 3 comments with different dates, verify order

**Comment search tests:**
14. `searchCommentsByEmbedding returns closest vectors` — upsertComment with embedding, search, verify found

All tests should initially FAIL because issue-store.ts doesn't exist yet. Create a minimal stub file `src/knowledge/issue-store.ts` that exports `createIssueStore` returning an object with all methods throwing "not implemented" so TypeScript compiles.
  </action>
  <verify>
    <automated>bun test src/knowledge/issue-store.test.ts 2>&1 | tail -5</automated>
  </verify>
  <done>All test cases written. Tests compile but fail (RED state). Stub issue-store.ts exists with unimplemented methods.</done>
</task>

<task type="auto">
  <name>Task 2: Implement IssueStore (GREEN phase)</name>
  <files>src/knowledge/issue-store.ts</files>
  <action>
Implement `src/knowledge/issue-store.ts` following the `createReviewCommentStore` pattern exactly.

**Factory function:**
```typescript
export function createIssueStore(opts: { sql: Sql; logger: Logger }): IssueStore
```

**Implementation details:**

1. `float32ArrayToVectorString()` helper — same as in review-comment-store.ts

2. `rowToRecord()` helper — maps snake_case DB row to camelCase IssueRecord. Parse `assignees` from JSONB, `label_names` from text[].

3. `commentRowToRecord()` helper — maps DB row to IssueCommentRecord.

4. `upsert(issue)`:
   - INSERT INTO issues with all columns
   - ON CONFLICT (repo, issue_number) DO UPDATE SET all mutable columns (title, body, state, label_names, template_slug, comment_count, assignees, milestone, reaction_count, is_pull_request, locked, embedding, embedding_model, github_updated_at, closed_at)
   - Cast embedding via `${embeddingValue}::vector`
   - Set embedding_model to "voyage-code-3" when embedding provided, null otherwise

5. `delete(repo, issueNumber)`:
   - DELETE FROM issue_comments WHERE repo AND issue_number (clean up comments first)
   - DELETE FROM issues WHERE repo AND issue_number

6. `getByNumber(repo, issueNumber)`:
   - SELECT * FROM issues WHERE repo = $1 AND issue_number = $2
   - Return null if no rows

7. `searchByEmbedding(params)`:
   - SELECT *, embedding <=> ${queryStr}::vector AS distance
   - WHERE repo = $1 AND embedding IS NOT NULL
   - ORDER BY distance LIMIT topK
   - Return IssueSearchResult[]

8. `searchByFullText(params)`:
   - SELECT *, ts_rank(search_tsv, plainto_tsquery('english', $1)) AS rank
   - WHERE repo = $1 AND search_tsv @@ plainto_tsquery('english', $1)
   - ORDER BY rank DESC LIMIT topK
   - Return IssueSearchResult[] with distance = 1 - rank

9. `findSimilar(repo, issueNumber, threshold = 0.7)`:
   - First: SELECT embedding FROM issues WHERE repo AND issue_number
   - If no embedding: return []
   - Then: SELECT *, embedding <=> ${issueEmbedding}::vector AS distance
   - WHERE repo = $1 AND issue_number != $2 AND embedding IS NOT NULL
   - AND embedding <=> ${issueEmbedding}::vector <= ${threshold}
   - ORDER BY distance LIMIT 10
   - Return IssueSearchResult[]

10. `countByRepo(repo)`:
    - SELECT COUNT(*)::int AS cnt FROM issues WHERE repo = $1

11. `upsertComment(comment)`:
    - INSERT INTO issue_comments with all columns
    - ON CONFLICT (repo, comment_github_id) DO UPDATE SET body, embedding, embedding_model, github_updated_at
    - Cast embedding via `${embeddingValue}::vector`

12. `deleteComment(repo, commentGithubId)`:
    - DELETE FROM issue_comments WHERE repo AND comment_github_id

13. `getCommentsByIssue(repo, issueNumber)`:
    - SELECT * FROM issue_comments WHERE repo AND issue_number ORDER BY github_created_at ASC

14. `searchCommentsByEmbedding(params)`:
    - SELECT *, embedding <=> ${queryStr}::vector AS distance
    - WHERE repo = $1 AND embedding IS NOT NULL
    - ORDER BY distance LIMIT topK

Log at debug level: "IssueStore initialized with pgvector HNSW index"

Run tests after implementation: `bun test src/knowledge/issue-store.test.ts`
All tests must pass (GREEN state).
  </action>
  <verify>
    <automated>bun test src/knowledge/issue-store.test.ts 2>&1 | tail -5</automated>
  </verify>
  <done>All IssueStore tests pass. Store provides typed CRUD, hybrid search, findSimilar, and comment operations against PostgreSQL with pgvector.</done>
</task>

</tasks>

<verification>
- [ ] `bun test src/knowledge/issue-store.test.ts` — all tests pass
- [ ] Issue upsert creates and updates records correctly
- [ ] Issue delete removes issue and its comments
- [ ] searchByEmbedding returns results sorted by cosine distance
- [ ] searchByFullText returns results using weighted tsvector (title > body > labels)
- [ ] findSimilar finds related issues and excludes the source issue
- [ ] Comment CRUD (upsert, delete, getByIssue) works correctly
- [ ] searchCommentsByEmbedding returns comment results sorted by distance
</verification>

<success_criteria>
IssueStore provides typed CRUD (upsert, delete, getByNumber) and hybrid search (vector + BM25) matching the ReviewCommentStore interface pattern. All methods have passing tests. findSimilar is a first-class store method for duplicate detection.
</success_criteria>

<output>
After completion, create `.planning/phases/103-issue-corpus-schema-store/103-02-SUMMARY.md`
</output>
