---
phase: 96-code-snippet-embedding
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/knowledge/code-snippet-types.ts
  - src/db/migrations/009-code-snippets.sql
  - src/db/migrations/009-code-snippets.down.sql
  - src/execution/config.ts
  - src/execution/config.test.ts
  - src/knowledge/cross-corpus-rrf.ts
autonomous: true
requirements: [SNIP-02, SNIP-05]

must_haves:
  truths:
    - code_snippets table exists with content_hash unique constraint, embedding vector(1024), language, and tsvector columns
    - code_snippet_occurrences junction table links content_hash to repo/pr/file/line metadata
    - SourceType union includes "snippet" alongside code, review_comment, wiki
    - .kodiai.yml schema accepts retrieval.hunkEmbedding.enabled and retrieval.hunkEmbedding.maxHunksPerPr
  artifacts:
    - src/knowledge/code-snippet-types.ts
    - src/db/migrations/009-code-snippets.sql
    - src/db/migrations/009-code-snippets.down.sql
  key_links:
    - cross-corpus-rrf.ts SourceType extended with "snippet"
    - config.ts hunkEmbeddingSchema wired into retrievalSchema
---

<objective>
Create the foundation types, database schema, and config extension for code snippet embedding.

Purpose: Establish the data layer and type contracts that all subsequent plans build on.
Output: Migration SQL, TypeScript types, extended SourceType, config schema for hunkEmbedding.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/knowledge/types.ts
@src/knowledge/review-comment-types.ts
@src/knowledge/cross-corpus-rrf.ts
@src/execution/config.ts
@src/db/migrations/007-language-column.sql
@src/db/migrations/005-review-comments.sql

<interfaces>
<!-- From src/knowledge/types.ts — embedding and store patterns -->
export type EmbeddingResult = { embedding: Float32Array; model: string; dimensions: number } | null;
export type EmbeddingProvider = { generate(text: string, inputType: "document" | "query"): Promise<EmbeddingResult>; readonly model: string; readonly dimensions: number; };

<!-- From src/knowledge/cross-corpus-rrf.ts — SourceType to extend -->
export type SourceType = "code" | "review_comment" | "wiki";
export type UnifiedRetrievalChunk = { id: string; text: string; source: SourceType; sourceLabel: string; sourceUrl: string | null; vectorDistance: number | null; rrfScore: number; createdAt: string | null; metadata: Record<string, unknown>; alternateSources?: string[]; };

<!-- From src/execution/config.ts — schema patterns -->
const retrievalSchema = z.object({ enabled: z.boolean().default(true), topK: z.number().min(1).max(20).default(5), distanceThreshold: z.number().min(0).max(2).default(0.3), adaptive: z.boolean().default(true), maxContextChars: z.number().min(0).max(5000).default(2000) }).default({...});
const knowledgeSchema = z.object({ shareGlobal, sharing, embeddings, retrieval }).default({...});
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create code snippet types and database migration</name>
  <files>
    src/knowledge/code-snippet-types.ts
    src/db/migrations/009-code-snippets.sql
    src/db/migrations/009-code-snippets.down.sql
  </files>
  <action>
Create `src/knowledge/code-snippet-types.ts` following the pattern from `review-comment-types.ts`:

**Types to define:**

```typescript
export type CodeSnippetRecord = {
  id: number;
  contentHash: string;          // SHA-256 of embeddedText
  embeddedText: string;         // file path + function context + PR title + added lines
  language: string;             // classified from filePath
  embeddingModel: string | null;
  stale: boolean;
  createdAt: string;
};

export type CodeSnippetOccurrence = {
  id: number;
  contentHash: string;
  repo: string;
  owner: string;
  prNumber: number;
  prTitle: string | null;
  filePath: string;
  startLine: number;
  endLine: number;
  functionContext: string | null;  // from @@ hunk header
  createdAt: string;
};

export type CodeSnippetSearchResult = {
  contentHash: string;
  embeddedText: string;
  distance: number;
  language: string;
  // Best occurrence metadata (most recent PR)
  repo: string;
  prNumber: number;
  prTitle: string | null;
  filePath: string;
  startLine: number;
  endLine: number;
  createdAt: string;
};

export type CodeSnippetStore = {
  writeSnippet(record: { contentHash: string; embeddedText: string; language: string; embeddingModel: string; }, embedding: Float32Array): Promise<void>;
  writeOccurrence(occurrence: Omit<CodeSnippetOccurrence, 'id' | 'createdAt'>): Promise<void>;
  searchByEmbedding(params: { queryEmbedding: Float32Array; repo: string; topK: number; distanceThreshold?: number; }): Promise<CodeSnippetSearchResult[]>;
  searchByFullText?(params: { query: string; repo: string; topK: number; }): Promise<CodeSnippetSearchResult[]>;
  close(): void;
};
```

**Migration `009-code-snippets.sql`:**

```sql
-- 009-code-snippets.sql
-- Code snippet embedding storage with content-hash deduplication.

-- Main snippets table: one row per unique hunk content
CREATE TABLE IF NOT EXISTS code_snippets (
  id SERIAL PRIMARY KEY,
  content_hash TEXT NOT NULL UNIQUE,
  embedded_text TEXT NOT NULL,
  language TEXT NOT NULL DEFAULT 'unknown',
  embedding vector(1024),
  embedding_model TEXT,
  tsv tsvector GENERATED ALWAYS AS (to_tsvector('english', embedded_text)) STORED,
  stale BOOLEAN NOT NULL DEFAULT false,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_code_snippets_hash ON code_snippets(content_hash);
CREATE INDEX IF NOT EXISTS idx_code_snippets_language ON code_snippets(language);
CREATE INDEX IF NOT EXISTS idx_code_snippets_tsv ON code_snippets USING gin(tsv);

-- Junction table: links snippet content to PR/file/line occurrences
CREATE TABLE IF NOT EXISTS code_snippet_occurrences (
  id SERIAL PRIMARY KEY,
  content_hash TEXT NOT NULL REFERENCES code_snippets(content_hash),
  repo TEXT NOT NULL,
  owner TEXT NOT NULL,
  pr_number INTEGER NOT NULL,
  pr_title TEXT,
  file_path TEXT NOT NULL,
  start_line INTEGER NOT NULL,
  end_line INTEGER NOT NULL,
  function_context TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_snippet_occ_hash ON code_snippet_occurrences(content_hash);
CREATE INDEX IF NOT EXISTS idx_snippet_occ_repo_pr ON code_snippet_occurrences(repo, pr_number);
CREATE INDEX IF NOT EXISTS idx_snippet_occ_repo ON code_snippet_occurrences(repo);
```

HNSW index will be created in a separate statement (follows pattern from 002-pgvector-indexes.sql):
```sql
CREATE INDEX IF NOT EXISTS idx_code_snippets_embedding ON code_snippets USING hnsw (embedding vector_cosine_ops) WITH (m = 16, ef_construction = 64);
```

**Down migration `009-code-snippets.down.sql`:**
```sql
DROP TABLE IF EXISTS code_snippet_occurrences;
DROP TABLE IF EXISTS code_snippets;
```
  </action>
  <verify>
    <automated>npx tsx -e "import './src/knowledge/code-snippet-types.ts'; console.log('types OK')"</automated>
    Check that 009-code-snippets.sql is valid SQL syntax. Verify content_hash UNIQUE constraint and vector(1024) column.
  </verify>
  <done>
    - code-snippet-types.ts compiles with all types exported
    - 009-code-snippets.sql has code_snippets table with content_hash UNIQUE, embedding vector(1024), language, tsv, and HNSW index
    - 009-code-snippets.sql has code_snippet_occurrences junction table with FK to content_hash
    - Down migration drops both tables
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend SourceType and config schema</name>
  <files>
    src/knowledge/cross-corpus-rrf.ts
    src/execution/config.ts
    src/execution/config.test.ts
  </files>
  <action>
**1. Extend `SourceType` in `src/knowledge/cross-corpus-rrf.ts`:**

Change:
```typescript
export type SourceType = "code" | "review_comment" | "wiki";
```
To:
```typescript
export type SourceType = "code" | "review_comment" | "wiki" | "snippet";
```

**2. Add hunkEmbedding schema in `src/execution/config.ts`:**

Add a new schema BEFORE the `retrievalSchema`:
```typescript
const hunkEmbeddingSchema = z
  .object({
    enabled: z.boolean().default(true),
    maxHunksPerPr: z.number().min(1).max(1000).default(100),
    minChangedLines: z.number().min(1).max(50).default(3),
    excludePatterns: z.array(z.string()).default([
      "*.lock",
      "vendor/**",
      "generated/**",
      "*.generated.*",
      "*.min.js",
      "*.min.css",
      "dist/**",
      "build/**",
      "node_modules/**",
    ]),
  })
  .default({
    enabled: true,
    maxHunksPerPr: 100,
    minChangedLines: 3,
    excludePatterns: [
      "*.lock", "vendor/**", "generated/**", "*.generated.*",
      "*.min.js", "*.min.css", "dist/**", "build/**", "node_modules/**",
    ],
  });
```

Add `hunkEmbedding` to the `retrievalSchema`:
```typescript
const retrievalSchema = z
  .object({
    enabled: z.boolean().default(true),
    topK: z.number().min(1).max(20).default(5),
    distanceThreshold: z.number().min(0).max(2).default(0.3),
    adaptive: z.boolean().default(true),
    maxContextChars: z.number().min(0).max(5000).default(2000),
    hunkEmbedding: hunkEmbeddingSchema,
  })
  .default({
    enabled: true,
    topK: 5,
    distanceThreshold: 0.3,
    adaptive: true,
    maxContextChars: 2000,
    hunkEmbedding: {
      enabled: true,
      maxHunksPerPr: 100,
      minChangedLines: 3,
      excludePatterns: ["*.lock", "vendor/**", "generated/**", "*.generated.*", "*.min.js", "*.min.css", "dist/**", "build/**", "node_modules/**"],
    },
  });
```

**3. Update config tests** in `config.test.ts`:

Add test cases:
- Default config has `knowledge.retrieval.hunkEmbedding.enabled === true`
- Default maxHunksPerPr is 100
- Custom `.kodiai.yml` with `retrieval.hunkEmbedding.enabled: false` is parsed correctly
- Custom maxHunksPerPr and excludePatterns override defaults
  </action>
  <verify>
    <automated>npx vitest run src/execution/config.test.ts --reporter=verbose 2>&1 | tail -20</automated>
    Verify SourceType now includes "snippet". Verify config tests pass.
  </verify>
  <done>
    - SourceType union is "code" | "review_comment" | "wiki" | "snippet"
    - config.ts accepts retrieval.hunkEmbedding.enabled (default: true) and retrieval.hunkEmbedding.maxHunksPerPr (default: 100)
    - Config test validates hunkEmbedding defaults and overrides
    - All existing config tests still pass
  </done>
</task>

</tasks>

<verification>
- `npx vitest run src/execution/config.test.ts` passes
- `npx tsx -e "import { type SourceType } from './src/knowledge/cross-corpus-rrf.ts'; const s: SourceType = 'snippet'; console.log('OK')"` compiles
- Migration SQL is syntactically valid
</verification>

<success_criteria>
- Types, migration, and config extension form a complete foundation for Plans 02-04
- No runtime dependencies — all changes are pure types/schema/SQL
- Backward-compatible: existing 3-corpus pipeline unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/96-code-snippet-embedding/96-01-SUMMARY.md`
</output>
