---
phase: 96-code-snippet-embedding
plan: 03
type: execute
wave: 2
depends_on: [01, 02]
files_modified:
  - src/knowledge/code-snippet-store.ts
  - src/knowledge/code-snippet-store.test.ts
  - src/knowledge/code-snippet-retrieval.ts
  - src/knowledge/code-snippet-retrieval.test.ts
autonomous: true
requirements: [SNIP-02, SNIP-03]

must_haves:
  truths:
    - writeSnippet uses UPSERT on content_hash — identical content is not re-embedded
    - writeOccurrence creates junction table entries linking content_hash to PR/file/line metadata
    - searchByEmbedding returns CodeSnippetSearchResult with best occurrence metadata joined
    - Embedding provider failure returns empty results (fail-open)
    - searchByFullText uses tsvector index for BM25 ranking
  artifacts:
    - src/knowledge/code-snippet-store.ts
    - src/knowledge/code-snippet-store.test.ts
    - src/knowledge/code-snippet-retrieval.ts
    - src/knowledge/code-snippet-retrieval.test.ts
  key_links:
    - code-snippet-store.ts implements CodeSnippetStore interface from code-snippet-types.ts
    - code-snippet-retrieval.ts is consumed by retrieval.ts in Plan 04
---

<objective>
Implement the code snippet store (PostgreSQL + pgvector) and retrieval search module.

Purpose: Provide persistent storage with content-hash deduplication and vector similarity search for hunk embeddings.
Output: Store module with UPSERT dedup logic, retrieval module with fail-open search.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/96-code-snippet-embedding/96-01-SUMMARY.md
@src/knowledge/code-snippet-types.ts
@src/knowledge/review-comment-store.ts
@src/knowledge/review-comment-retrieval.ts
@src/knowledge/memory-store.ts
@src/knowledge/embeddings.ts
@src/db/client.ts

<interfaces>
<!-- From code-snippet-types.ts (Plan 01) -->
export type CodeSnippetStore = {
  writeSnippet(record, embedding): Promise<void>;
  writeOccurrence(occurrence): Promise<void>;
  searchByEmbedding(params): Promise<CodeSnippetSearchResult[]>;
  searchByFullText?(params): Promise<CodeSnippetSearchResult[]>;
  close(): void;
};

<!-- From memory-store.ts — float32ArrayToVectorString pattern -->
function float32ArrayToVectorString(arr: Float32Array): string {
  const parts: string[] = new Array(arr.length);
  for (let i = 0; i < arr.length; i++) { parts[i] = String(arr[i]); }
  return `[${parts.join(",")}]`;
}

<!-- From review-comment-retrieval.ts — search pattern -->
export async function searchReviewComments(opts: {
  store: ReviewCommentStore; embeddingProvider: EmbeddingProvider;
  query: string; repo: string; topK: number; distanceThreshold?: number; logger: Logger;
}): Promise<ReviewCommentMatch[]>;

<!-- From src/db/client.ts -->
export type Sql = /* postgres.js Sql instance */;
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement code-snippet-store.ts with tests</name>
  <files>
    src/knowledge/code-snippet-store.ts
    src/knowledge/code-snippet-store.test.ts
  </files>
  <action>
Create `src/knowledge/code-snippet-store.ts` following the pattern from `review-comment-store.ts` and `memory-store.ts`.

**Factory function:**
```typescript
export function createCodeSnippetStore(opts: { sql: Sql; logger: Logger; }): CodeSnippetStore
```

**writeSnippet implementation:**
- Convert embedding Float32Array to vector string using `float32ArrayToVectorString()`
- Use UPSERT: `INSERT INTO code_snippets (content_hash, embedded_text, language, embedding, embedding_model) VALUES (...) ON CONFLICT (content_hash) DO NOTHING`
- This ensures identical hunk content is never re-embedded — satisfies SNIP-03
- Log at debug level whether insert was new or skipped (content_hash already exists)

**writeOccurrence implementation:**
- `INSERT INTO code_snippet_occurrences (content_hash, repo, owner, pr_number, pr_title, file_path, start_line, end_line, function_context) VALUES (...)`
- No UPSERT needed — same content can legitimately appear in multiple PRs at different locations

**searchByEmbedding implementation:**
- Use pgvector cosine distance: `cs.embedding <=> ${queryEmbeddingString}::vector`
- JOIN with code_snippet_occurrences to get PR/file metadata
- Filter by repo through the occurrences table: `WHERE cso.repo = ${repo}`
- Apply distance threshold: `HAVING MIN(cs.embedding <=> ...) < ${distanceThreshold}`
- Return results with the most recent occurrence's metadata (ORDER BY cso.created_at DESC LIMIT 1 in a lateral join or subquery)
- LIMIT topK
- Default distanceThreshold: 0.7 (same as review comments)

**searchByFullText implementation (optional method):**
- Use tsvector: `ts_rank(cs.tsv, plainto_tsquery('english', ${query}))` as rank
- JOIN occurrences for repo filter
- Return same CodeSnippetSearchResult shape

**Tests (`code-snippet-store.test.ts`):**
- Test that the store factory returns an object with all required methods
- Mock the sql template tag to verify SQL is structured correctly
- Test float32ArrayToVectorString produces correct format
- Test that writeSnippet uses ON CONFLICT DO NOTHING
- Test searchByEmbedding filters by repo

Follow the same test approach as `review-comment-store.test.ts` — mock the sql dependency.
  </action>
  <verify>
    <automated>npx vitest run src/knowledge/code-snippet-store.test.ts --reporter=verbose 2>&1 | tail -20</automated>
  </verify>
  <done>
    - createCodeSnippetStore returns a CodeSnippetStore with all methods
    - writeSnippet uses ON CONFLICT (content_hash) DO NOTHING for dedup
    - writeOccurrence inserts junction table rows
    - searchByEmbedding uses pgvector cosine distance with repo filter
    - Tests pass with mocked sql dependency
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement code-snippet-retrieval.ts with tests</name>
  <files>
    src/knowledge/code-snippet-retrieval.ts
    src/knowledge/code-snippet-retrieval.test.ts
  </files>
  <action>
Create `src/knowledge/code-snippet-retrieval.ts` following the pattern from `review-comment-retrieval.ts`.

**Export type:**
```typescript
export type CodeSnippetMatch = {
  embeddedText: string;
  distance: number;
  contentHash: string;
  repo: string;
  prNumber: number;
  prTitle: string | null;
  filePath: string;
  startLine: number;
  endLine: number;
  language: string;
  createdAt: string;
  source: "snippet";
};
```

**Search function:**
```typescript
export async function searchCodeSnippets(opts: {
  store: CodeSnippetStore;
  embeddingProvider: EmbeddingProvider;
  query: string;
  repo: string;
  topK: number;
  distanceThreshold?: number;
  logger: Logger;
}): Promise<CodeSnippetMatch[]>
```

Implementation:
1. Generate query embedding via `embeddingProvider.generate(query, "query")`
2. If embedding is null (fail-open), return []
3. Call `store.searchByEmbedding({ queryEmbedding, repo, topK, distanceThreshold })`
4. Map results to CodeSnippetMatch with `source: "snippet"`
5. Wrap entire function in try/catch — on error, log warning and return [] (fail-open)

Default distanceThreshold: 0.7

**Tests (`code-snippet-retrieval.test.ts`):**
- Embedding provider returns null → returns []
- Embedding provider succeeds, store returns results → maps to CodeSnippetMatch[]
- Store throws error → returns [] (fail-open)
- Results include source: "snippet"
- Distance threshold is passed through to store

Follow pattern from `review-comment-retrieval.test.ts`.
  </action>
  <verify>
    <automated>npx vitest run src/knowledge/code-snippet-retrieval.test.ts --reporter=verbose 2>&1 | tail -20</automated>
  </verify>
  <done>
    - searchCodeSnippets generates embedding, queries store, returns CodeSnippetMatch[]
    - Fail-open on embedding failure (returns [])
    - Fail-open on store error (returns [])
    - All results have source: "snippet"
    - Tests pass with mocked store and embedding provider
  </done>
</task>

</tasks>

<verification>
- `npx vitest run src/knowledge/code-snippet-store.test.ts src/knowledge/code-snippet-retrieval.test.ts` — all tests pass
- Store implements content-hash dedup via UPSERT
- Retrieval is fail-open end-to-end
</verification>

<success_criteria>
- Store correctly deduplicates by content_hash (SNIP-03)
- Store stores PR/file/line metadata in junction table (SNIP-02)
- Retrieval search is fail-open and returns typed CodeSnippetMatch results
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/96-code-snippet-embedding/96-03-SUMMARY.md`
</output>
