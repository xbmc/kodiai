---
phase: 95-ci-failure-recognition
plan: 02
type: execute
wave: 2
depends_on: [95-01]
files_modified:
  - src/lib/ci-failure-formatter.ts
  - src/handlers/ci-failure.ts
  - src/index.ts
autonomous: true
requirements: [CIFR-01, CIFR-02, CIFR-03, CIFR-04, CIFR-05]

must_haves:
  truths:
    - "When check_suite.completed fires for a PR with failures, Kodiai posts/updates a CI analysis section as a comment on the PR"
    - "The CI section shows a summary line ('N of M failures appear unrelated') with expandable per-check details"
    - "Each check shows base-branch evidence and confidence level (high/medium/low)"
    - "When all checks pass, no CI comment is posted (no noise on clean PRs)"
    - "When no base-branch check data exists, the CI annotation is skipped entirely"
    - "The handler does not modify merge confidence or block approval — it is completely independent of the review pipeline"
    - "Each check_suite.completed event records check run data into ci_check_history for flakiness tracking"
    - "Multiple check_suite events for the same SHA produce idempotent results (re-fetch all checks, rebuild section)"
  artifacts:
    - path: "src/lib/ci-failure-formatter.ts"
      provides: "Markdown CI section builder"
      exports: ["formatCISection"]
    - path: "src/handlers/ci-failure.ts"
      provides: "check_suite.completed handler"
      exports: ["createCIFailureHandler"]
    - path: "src/index.ts"
      provides: "Handler registration"
      contains: "createCIFailureHandler"
  key_links:
    - from: "src/handlers/ci-failure.ts"
      to: "src/lib/ci-failure-classifier.ts"
      via: "classifyFailures call"
      pattern: "classifyFailures"
    - from: "src/handlers/ci-failure.ts"
      to: "src/lib/ci-check-store.ts"
      via: "recordCheckRuns + getFlakiness calls"
      pattern: "recordCheckRuns|getFlakiness"
    - from: "src/handlers/ci-failure.ts"
      to: "src/lib/ci-failure-formatter.ts"
      via: "formatCISection for comment body"
      pattern: "formatCISection"
    - from: "src/index.ts"
      to: "src/handlers/ci-failure.ts"
      via: "createCIFailureHandler registration"
      pattern: "createCIFailureHandler"
---

<objective>
Build the check_suite.completed webhook handler, CI section formatter, and wire everything into the application. The handler fetches check runs for the PR head SHA and base-branch commits, classifies failures using the classifier from Plan 01, formats a markdown section, and posts/updates a CI annotation comment on the PR.

Purpose: Completes the CI failure recognition feature end-to-end — from webhook event to visible PR annotation.
Output: ci-failure-formatter.ts, ci-failure.ts handler, updated index.ts
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/95-ci-failure-recognition/95-CONTEXT.md
@.planning/phases/95-ci-failure-recognition/95-RESEARCH.md
@.planning/phases/95-ci-failure-recognition/95-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts from Plan 01 outputs -->

From src/lib/ci-failure-classifier.ts (created in Plan 01):
```typescript
export type CheckResult = { name: string; conclusion: string | null; status: string };
export type Classification = "unrelated" | "flaky-unrelated" | "possibly-pr-related";
export type Confidence = "high" | "medium" | "low";
export type ClassifiedFailure = {
  checkName: string;
  classification: Classification;
  confidence: Confidence;
  evidence: string;
  flakiness?: { failRate: number; window: number };
};
export type FlakinessStat = { failures: number; total: number };
export function classifyFailures(params: {
  headChecks: CheckResult[];
  baseResults: Map<string, CheckResult[]>;
  flakiness: Map<string, FlakinessStat>;
}): ClassifiedFailure[];
```

From src/lib/ci-check-store.ts (created in Plan 01):
```typescript
export function recordCheckRuns(sql: Sql, params: {
  repo: string; headSha: string; prNumber?: number; checkSuiteId?: number;
  runs: Array<{ name: string; conclusion: string }>;
}): Promise<void>;
export function getFlakiness(sql: Sql, params: {
  repo: string; checkNames: string[];
}): Promise<Map<string, { failures: number; total: number }>>;
```

From src/webhook/types.ts:
```typescript
export interface WebhookEvent {
  id: string;
  name: string;
  payload: Record<string, unknown>;
  installationId: number;
}
export type EventHandler = (event: WebhookEvent) => Promise<void>;
export interface EventRouter {
  register(eventKey: string, handler: EventHandler): void;
  dispatch(event: WebhookEvent): Promise<void>;
}
```

From src/handlers/dep-bump-merge-history.ts (handler factory pattern):
```typescript
export function createDepBumpMergeHistoryHandler(deps: {
  eventRouter: EventRouter;
  jobQueue: JobQueue;
  githubApp: GitHubApp;
  knowledgeStore?: KnowledgeStore;
  logger: Logger;
}): void {
  // register handler on eventRouter
  eventRouter.register("pull_request.closed", handlePullRequestClosed);
}
```

From src/handlers/review-idempotency.ts (marker pattern):
```typescript
export function buildReviewOutputMarker(reviewOutputKey: string): string {
  return `<!-- kodiai:review-output-key:${reviewOutputKey} -->`;
}
```

From src/index.ts (handler registration site, around line 408):
```typescript
createDepBumpMergeHistoryHandler({ eventRouter, jobQueue, githubApp, knowledgeStore, logger });
// New handler goes after existing handler registrations
// Available variables: eventRouter, jobQueue, githubApp, sql, logger
```

From src/db/client.ts:
```typescript
export type Sql = ReturnType<typeof postgres>;
```

From src/auth/github-app.ts:
```typescript
export interface GitHubApp {
  getInstallationOctokit(installationId: number): Promise<Octokit>;
  getAppSlug(): string;
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: CI failure formatter and handler</name>
  <files>
    src/lib/ci-failure-formatter.ts
    src/handlers/ci-failure.ts
  </files>
  <action>
**1. Create `src/lib/ci-failure-formatter.ts`:**

Export `formatCISection(classified: ClassifiedFailure[], totalFailures: number): string`

Format rules (locked decisions):
- Header: `### CI Failure Analysis`
- Summary line: `**N of M failures appear unrelated to this PR**` where N = count of unrelated + flaky-unrelated, M = totalFailures
- Wrap per-check details in `<details><summary>Failure details</summary>` ... `</details>`
- Each check: `- :icon: **checkName** [confidence] — evidence`
  - Icon mapping: `unrelated` → `:white_check_mark:`, `flaky-unrelated` → `:warning:`, `possibly-pr-related` → `:x:`
- For flaky checks, append indented line: `  Failed N% of last M runs`
- If all failures are unrelated (N === M), make summary line say "All N failures appear unrelated to this PR"

Also export `buildCIAnalysisMarker(owner: string, repo: string, prNumber: number): string` that returns `<!-- kodiai:ci-analysis:${owner}/${repo}/pr-${prNumber} -->`. This marker identifies the CI annotation comment for upsert.

**2. Create `src/handlers/ci-failure.ts`:**

Export `createCIFailureHandler(deps: { eventRouter, jobQueue, githubApp, sql, logger })`.

Handler logic for `check_suite.completed`:

```
1. Parse payload as CheckSuiteCompletedEvent
2. Extract headSha, owner, repo from payload
3. Get pull_requests array from payload.check_suite.pull_requests
4. If pull_requests is empty → log debug "No PRs in check_suite (fork?)" → return
5. For each PR in pull_requests:
   a. Get octokit via githubApp.getInstallationOctokit(installationId)
   b. Fetch ALL check runs for headSha using octokit.paginate.iterator(octokit.rest.checks.listForRef, { owner, repo, ref: headSha, per_page: 100, filter: "latest" })
   c. Record check runs in ci_check_history via recordCheckRuns(sql, ...)
   d. Filter to failures (conclusion === "failure"). If none → skip this PR (no noise on clean PRs)
   e. Fetch last 3 commits on base branch (pr.base.ref) via octokit.rest.repos.listCommits({ sha: pr.base.ref, per_page: 3 })
   f. For each base commit, fetch check runs via listForRef (sequentially, not parallel, to reduce burst)
   g. If ALL base commit fetches return empty results (no check data) → skip CI annotation entirely (no guessing)
   h. Get flakiness stats via getFlakiness(sql, { repo: `${owner}/${repo}`, checkNames: failedCheckNames })
   i. Call classifyFailures({ headChecks, baseResults, flakiness })
   j. Call formatCISection(classified, totalFailureCount)
   k. Build comment body: marker + formatted section
   l. Upsert CI comment: find existing comment by marker (list issue comments, search for marker in body). If found → update. If not found → create.
```

Important constraints (CIFR-04, locked decisions):
- Do NOT import or call anything from merge-confidence.ts
- Do NOT modify the review handler or any existing handler
- The handler is completely independent of the review pipeline
- Wrap the entire handler body in try/catch — log errors at warn level but never throw (fail-open)
- Use jobQueue.enqueue to process asynchronously, following the dep-bump-merge-history.ts pattern
- The job type should be `"ci-failure-analysis"`

Edge case handling:
- `pull_requests` empty (forks): skip, log debug
- `listForRef` errors: catch per-call, treat as empty results for that ref
- `checks:read` permission missing (403): catch, log warn "checks:read permission may be missing", skip CI annotation
- Pagination: use `octokit.paginate.iterator` for head SHA checks (may have many runs). Base branch checks unlikely to need pagination (3 commits x ~20 checks each), but use paginate anyway for safety.
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && bun build src/handlers/ci-failure.ts --no-bundle 2>&1 | head -20 && bun build src/lib/ci-failure-formatter.ts --no-bundle 2>&1 | head -20</automated>
  </verify>
  <done>
    - ci-failure-formatter.ts exports formatCISection and buildCIAnalysisMarker
    - ci-failure.ts exports createCIFailureHandler following the existing handler factory pattern
    - Handler registers on "check_suite.completed" event
    - Handler fetches check runs for head SHA and last 3 base-branch commits using Checks API
    - Handler records all check runs into ci_check_history for flakiness tracking
    - Handler skips annotation when all checks pass or when no base-branch data exists
    - Handler upserts CI comment using marker-based idempotency
    - Handler is fully independent of review pipeline (CIFR-04)
    - Handler fail-open: errors logged at warn, never thrown
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire CI failure handler into application</name>
  <files>src/index.ts</files>
  <action>
In `src/index.ts`:

1. Add import at the top with other handler imports:
```typescript
import { createCIFailureHandler } from "./handlers/ci-failure.ts";
```

2. After the `createDepBumpMergeHistoryHandler(...)` call (around line 414), add:
```typescript
createCIFailureHandler({
  eventRouter,
  jobQueue,
  githubApp,
  sql,
  logger,
});
```

The `sql` variable is already available in scope (created around line 60). The other variables (eventRouter, jobQueue, githubApp, logger) are already used by other handler registrations in the same block.

Do NOT modify any other part of index.ts. Just add the import and the handler registration call.
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && grep -n "createCIFailureHandler" src/index.ts | head -5 && bun build src/index.ts --no-bundle 2>&1 | tail -5</automated>
  </verify>
  <done>
    - index.ts imports createCIFailureHandler
    - index.ts calls createCIFailureHandler with eventRouter, jobQueue, githubApp, sql, logger
    - No other changes to index.ts
    - Application builds without errors
  </done>
</task>

</tasks>

<verification>
- `bun build src/index.ts --no-bundle` succeeds (all imports resolve)
- `grep "createCIFailureHandler" src/index.ts` shows import and call
- `grep "check_suite.completed" src/handlers/ci-failure.ts` confirms event registration
- `grep "kodiai:ci-analysis" src/lib/ci-failure-formatter.ts` confirms marker pattern
- `grep "merge-confidence" src/handlers/ci-failure.ts` returns NO matches (CIFR-04 independence)
- Handler does NOT modify any existing handler files
- All new files follow existing project patterns (handler factory, tagged template SQL, marker-based comment upsert)
</verification>

<success_criteria>
End-to-end CI failure recognition is wired: check_suite.completed events trigger classification, formatting, and comment upsert. The feature is completely independent of the review pipeline. Flakiness data accumulates organically. All 5 CIFR requirements are addressed.
</success_criteria>

<output>
After completion, create `.planning/phases/95-ci-failure-recognition/95-02-SUMMARY.md`
</output>
