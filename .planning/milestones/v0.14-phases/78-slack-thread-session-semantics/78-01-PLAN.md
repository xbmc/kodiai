---
phase: 78-slack-thread-session-semantics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/slack/thread-session-store.ts
  - src/slack/thread-session-store.test.ts
  - src/slack/safety-rails.ts
  - src/slack/safety-rails.test.ts
  - src/routes/slack-events.ts
  - src/routes/slack-events.test.ts
autonomous: true

must_haves:
  truths:
    - "Once a thread is started via @kodiai, in-thread follow-up messages are treated as addressed without requiring another mention"
    - "Follow-up handling never produces top-level channel reply targets"
    - "Thread starter and non-starter follow-up behavior is deterministic and covered by automated tests"
  artifacts:
    - path: "src/slack/thread-session-store.ts"
      provides: "Deterministic in-memory session state for started Slack threads keyed by channel + thread timestamp"
      exports: ["createSlackThreadSessionStore", "SlackThreadSessionStore"]
    - path: "src/slack/safety-rails.ts"
      provides: "Rail decisions that distinguish top-level bootstrap from in-thread follow-up eligibility"
      contains: "thread_session_follow_up"
    - path: "src/routes/slack-events.ts"
      provides: "Ingress wiring that starts sessions on bootstrap and allows follow-ups only for started threads"
      contains: "replyTarget: \"thread-only\""
    - path: "src/routes/slack-events.test.ts"
      provides: "Route-level proofs for starter vs non-starter follow-up handling"
      contains: "non-starter"
  key_links:
    - from: "src/routes/slack-events.ts"
      to: "src/slack/thread-session-store.ts"
      via: "Allowed bootstrap writes thread session before follow-up evaluation"
      pattern: "markThreadStarted|startThreadSession"
    - from: "src/routes/slack-events.ts"
      to: "src/slack/safety-rails.ts"
      via: "Rail evaluation receives session-active lookup for thread follow-up decisions"
      pattern: "evaluateSlackV1Rails"
    - from: "src/routes/slack-events.test.ts"
      to: "src/routes/slack-events.ts"
      via: "Integration tests assert started-thread follow-up allowed and non-starter follow-up ignored"
      pattern: "follow-up|starter|non-starter"
---

<objective>
Implement Slack thread session semantics so @kodiai bootstrap starts a thread session and later thread replies in that session are treated as addressed without re-mentioning.

Purpose: This satisfies SLK-03 while preserving v1 low-noise behavior from Phase 77 (explicit bootstrap only, thread-only replies, deterministic ignores for out-of-scope traffic).
Output: Thread session state module, updated rail decision logic, route wiring, and regression tests for starter vs non-starter follow-up paths.
</objective>

<execution_context>
@/home/keith/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/keith/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/77-slack-ingress-safety-rails/77-02-SUMMARY.md
@src/slack/safety-rails.ts
@src/routes/slack-events.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add deterministic thread-session store for Slack bootstrap threads</name>
  <files>src/slack/thread-session-store.ts, src/slack/thread-session-store.test.ts</files>
  <action>
Create a focused session-state primitive used by Slack ingress rails:

- Add `createSlackThreadSessionStore()` with explicit methods to mark a thread as started and query whether a thread session is active.
- Key sessions by normalized `channel + threadTs` so lookups are deterministic and independent of message text.
- Keep implementation in-process and minimal (no new dependency, no database persistence) because this phase only needs deterministic runtime session semantics.
- Add tests proving idempotent start behavior, channel scoping, and non-starter lookup returning false.
  </action>
  <verify>
Run `bun test ./src/slack/thread-session-store.test.ts --timeout 30000`.
  </verify>
  <done>
Thread sessions can be started and queried deterministically, with explicit tests proving starter vs non-starter state behavior.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend Slack v1 rail evaluator to support started-thread follow-ups</name>
  <files>src/slack/safety-rails.ts, src/slack/safety-rails.test.ts</files>
  <action>
Update rail decision logic to model two addressed paths while preserving Phase 77 safety rules:

- Keep top-level bootstrap requirement unchanged: only `#kodiai` top-level messages with `<@SLACK_BOT_USER_ID>` may start a session.
- Add follow-up eligibility path: if message has `thread_ts` and the thread is marked started, treat it as addressed even without mention prefix.
- Keep deterministic ignore reasons for non-started thread follow-ups and all existing out-of-scope traffic (DMs, bot/system events, wrong channel, malformed payloads).
- Ensure both bootstrap and follow-up allow decisions output thread-only target metadata (`threadTs`, `replyTarget: "thread-only"`) so no top-level publish path can be used.
- Add/adjust unit tests for starter follow-up allowed, non-starter follow-up ignored, and unchanged bootstrap gating.
  </action>
  <verify>
Run `bun test ./src/slack/safety-rails.test.ts --timeout 30000`.
  </verify>
  <done>
Rail evaluator deterministically allows only valid bootstrap + started-thread follow-up paths and preserves strict ignores elsewhere.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire session semantics into Slack events route with end-to-end regression tests</name>
  <files>src/routes/slack-events.ts, src/routes/slack-events.test.ts</files>
  <action>
Integrate session state and updated rails into verified ingress handling:

- Instantiate or inject the thread-session store in `createSlackEventRoutes` and pass session-active checks into rail evaluation.
- On allowed top-level bootstrap, start the thread session before async handoff; on in-thread follow-up, allow only when the session is already active.
- Route all allowed addressed events through a single normalized async callback payload that stays thread-targeted; do not introduce any top-level channel response path.
- Keep acknowledge-fast behavior (`200 {ok:true}`) and ignore-path no-op semantics from Phase 77 unchanged.
- Extend route tests to prove: bootstrap starts session, follow-up in started thread is forwarded without mention, follow-up in non-started thread is ignored, and reply target remains thread-only.
  </action>
  <verify>
Run `bun test ./src/routes/slack-events.test.ts --timeout 30000`.
Run `bun test ./src/slack/safety-rails.test.ts --timeout 30000`.
Run `bunx tsc --noEmit`.
  </verify>
  <done>
Slack route enforces deterministic starter/non-starter thread behavior and keeps all follow-up handling scoped to thread-only normalized payloads.
  </done>
</task>

</tasks>

<verification>
- Top-level `@kodiai` bootstrap in `#kodiai` starts a thread session and is forwarded for async handling.
- In-thread follow-up without mention is forwarded only when thread session is already started; non-starter thread follow-up is acknowledged and ignored.
- All allowed addressed payloads are thread-targeted (`replyTarget: "thread-only"`), with no top-level response path.
- `bun test ./src/slack/thread-session-store.test.ts --timeout 30000`, `bun test ./src/slack/safety-rails.test.ts --timeout 30000`, `bun test ./src/routes/slack-events.test.ts --timeout 30000`, and `bunx tsc --noEmit` pass.
</verification>

<success_criteria>
SLK-03 is satisfied: Slack thread sessions are deterministic, low-noise, and test-covered so started threads allow follow-ups without repeated mentions while non-started threads remain ignored.
</success_criteria>

<output>
After completion, create `.planning/phases/78-slack-thread-session-semantics/78-01-SUMMARY.md`
</output>
