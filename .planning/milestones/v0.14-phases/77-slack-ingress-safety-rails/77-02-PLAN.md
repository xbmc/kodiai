---
phase: 77-slack-ingress-safety-rails
plan: 02
type: execute
wave: 2
depends_on: [77-01]
files_modified:
  - src/slack/types.ts
  - src/slack/safety-rails.ts
  - src/slack/safety-rails.test.ts
  - src/routes/slack-events.ts
  - src/routes/slack-events.test.ts
autonomous: true

must_haves:
  truths:
    - "Slack v1 processing is limited to the configured `#kodiai` channel and ignores DMs or other channels"
    - "Thread bootstrap requires an explicit `@kodiai` mention on a top-level channel message"
    - "Any allowed Slack assistant reply target is thread-only, never a new top-level channel post"
  artifacts:
    - path: "src/slack/safety-rails.ts"
      provides: "Deterministic rail evaluator for channel, DM, thread, and mention bootstrap gating"
      contains: "thread-only"
    - path: "src/routes/slack-events.ts"
      provides: "Ingress wiring that applies rail evaluator before downstream handling"
      contains: "mention-only"
    - path: "src/slack/safety-rails.test.ts"
      provides: "Regression matrix for allowed/blocked Slack event scenarios"
      contains: "#kodiai"
  key_links:
    - from: "src/routes/slack-events.ts"
      to: "src/slack/safety-rails.ts"
      via: "Verified Slack event_callback payloads are screened by v1 rail decisions before any processing"
      pattern: "evaluateSlackV1Rails"
    - from: "src/slack/safety-rails.ts"
      to: "src/slack/types.ts"
      via: "Rail evaluator uses typed Slack event payload fields instead of ad-hoc any parsing"
      pattern: "SlackEventCallback|SlackMessageEvent"
    - from: "src/routes/slack-events.test.ts"
      to: "src/routes/slack-events.ts"
      via: "Integration tests assert blocked scenarios are acknowledged with no processing side-effects"
      pattern: "ignored|blocked|channel|dm|thread"
---

<objective>
Enforce Slack v1 low-noise safety rails after ingress verification: single channel scope, no DMs, thread-only targeting, and mention-only thread bootstrap.

Purpose: SLK-02 and existing no-unsolicited-response policy require hard gating before any assistant behavior so Slack does not become noisy or unsafe.
Output: Rail evaluation module, route wiring, and regression tests for allowed vs blocked Slack scenarios.
</objective>

<execution_context>
@/home/keith/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/keith/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/77-slack-ingress-safety-rails/77-01-SUMMARY.md
@src/routes/slack-events.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement typed Slack event model and v1 rail evaluator</name>
  <files>src/slack/types.ts, src/slack/safety-rails.ts, src/slack/safety-rails.test.ts</files>
  <action>
Create deterministic Slack v1 rail logic as pure functions with test coverage:

- Define minimal Slack event types needed for v1 (`event_callback`, message subtype filters, channel/channel_type, `thread_ts`, bot/user ids, text).
- Implement `evaluateSlackV1Rails(...)` that returns an explicit decision (`allow` or `ignore`) and reason code.
- Enforce these rules exactly: allow only configured `SLACK_KODIAI_CHANNEL_ID`; ignore DMs/group DMs; ignore bot/system messages; require top-level bootstrap message containing `@kodiai` mention token (`<@SLACK_BOT_USER_ID>`); derive reply target as thread timestamp only.
- Keep follow-up in-thread conversational handling out of scope for this phase (Phase 78); this evaluator should only authorize bootstrap messages and prepare thread target metadata.
- Add table-style tests proving each blocked scenario and allowed bootstrap path.
  </action>
  <verify>
Run `bun test ./src/slack/safety-rails.test.ts --timeout 30000`.
  </verify>
  <done>
Slack v1 rail evaluator deterministically blocks out-of-scope traffic and allows only top-level mention bootstrap in `#kodiai` with a thread-only target.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire rails into Slack events route with explicit no-op handling for blocked traffic</name>
  <files>src/routes/slack-events.ts, src/routes/slack-events.test.ts</files>
  <action>
Integrate rail evaluation into verified Slack callback handling:

- In `event_callback` handling, parse Slack message payload into typed structure and apply `evaluateSlackV1Rails(...)` before any downstream execution.
- When decision is `ignore`, return success acknowledgement with no handler invocation and log the deterministic reason code.
- When decision is `allow`, forward only normalized bootstrap payload (`channel`, `threadTs`, `user`, `text`) to the async processing seam; do not emit top-level Slack responses.
- Ensure every allowed path carries thread target metadata so later phases cannot accidentally publish non-thread replies.
- Preserve no-unsolicited-response policy by never processing non-mention bootstrap events.
  </action>
  <verify>
Run `bun test ./src/routes/slack-events.test.ts --timeout 30000`.
Run `bunx tsc --noEmit`.
  </verify>
  <done>
Route-level Slack handling now enforces low-noise v1 rails and acknowledges blocked traffic safely without downstream side effects.
  </done>
</task>

</tasks>

<verification>
- Slack events from non-`#kodiai` channels and DM surfaces are acknowledged but ignored.
- Only top-level `@kodiai` bootstrap messages are accepted for processing and converted to thread targets.
- Allowed path carries thread target metadata; no top-level publish path exists.
- `bun test ./src/slack/safety-rails.test.ts --timeout 30000`, `bun test ./src/routes/slack-events.test.ts --timeout 30000`, and `bunx tsc --noEmit` pass.
</verification>

<success_criteria>
SLK-02 is satisfied for v1 rails: Slack ingress remains low-noise and channel-scoped, with strict mention bootstrap and thread-only reply targeting.
</success_criteria>

<output>
After completion, create `.planning/phases/77-slack-ingress-safety-rails/77-02-SUMMARY.md`
</output>
