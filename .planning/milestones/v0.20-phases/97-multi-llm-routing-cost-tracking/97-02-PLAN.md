---
phase: 97-multi-llm-routing-cost-tracking
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/migrations/010-llm-cost-events.sql
  - src/db/migrations/010-llm-cost-events.down.sql
  - src/llm/cost-tracker.ts
  - src/telemetry/types.ts
  - src/telemetry/store.ts
autonomous: true
requirements:
  - LLM-05

must_haves:
  truths:
    - "Every LLM invocation (AI SDK and Agent SDK) can be logged to Postgres with model, provider, tokens, and cost"
    - "llm_cost_events table exists with full-dimensional schema queryable by repo, task type, model, provider"
    - "Cost estimation uses pricing config (not hardcoded) to compute estimated USD"
    - "Agent SDK execution costs are also written to llm_cost_events for unified querying"
  artifacts:
    - path: "src/db/migrations/010-llm-cost-events.sql"
      provides: "llm_cost_events table with full-dimensional schema"
      contains: "CREATE TABLE llm_cost_events"
    - path: "src/db/migrations/010-llm-cost-events.down.sql"
      provides: "Rollback migration for llm_cost_events"
      contains: "DROP TABLE"
    - path: "src/llm/cost-tracker.ts"
      provides: "Cost tracking module for logging LLM invocations"
      exports: ["createCostTracker", "LlmCostRecord", "CostTracker"]
    - path: "src/telemetry/types.ts"
      provides: "LlmCostRecord type definition"
      contains: "LlmCostRecord"
    - path: "src/telemetry/store.ts"
      provides: "recordLlmCost method on TelemetryStore"
      contains: "recordLlmCost"
  key_links:
    - from: "src/llm/cost-tracker.ts"
      to: "src/telemetry/store.ts"
      via: "TelemetryStore.recordLlmCost()"
      pattern: "recordLlmCost"
    - from: "src/llm/cost-tracker.ts"
      to: "src/llm/pricing.ts"
      via: "estimateCost() for USD calculation"
      pattern: "estimateCost"
---

<objective>
Create the Postgres migration for llm_cost_events and the cost tracking module that logs every LLM invocation with model, provider, token counts, and estimated USD cost.

Purpose: Provide full cost visibility per invocation, queryable along any dimension (repo, task type, model, provider, time). This is the data foundation for cost monitoring.
Output: Migration 010, cost tracker module, extended telemetry store.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/97-multi-llm-routing-cost-tracking/97-CONTEXT.md
@.planning/phases/97-multi-llm-routing-cost-tracking/97-RESEARCH.md
@src/telemetry/types.ts
@src/telemetry/store.ts
@src/db/migrations/009-code-snippets.sql

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/telemetry/types.ts (lines 121-138):
```typescript
export type TelemetryStore = {
  record(entry: TelemetryRecord): Promise<void>;
  countRecentTimeouts?(repo: string, author: string): Promise<number>;
  recordRetrievalQuality(entry: RetrievalQualityRecord): Promise<void>;
  recordRateLimitEvent(entry: RateLimitEventRecord): Promise<void>;
  recordResilienceEvent?(entry: ResilienceEventRecord): Promise<void>;
  purgeOlderThan(days: number): Promise<number>;
  checkpoint(): void;
  close(): void;
};
```

From src/telemetry/store.ts (line 19):
```typescript
export function createTelemetryStore(opts: { sql: Sql; logger: Logger }): TelemetryStore;
```

Existing migration pattern (from 009-code-snippets.sql):
- Versioned SQL files in src/db/migrations/
- Paired .down.sql rollback files
- Schema is additive-only (new tables, nullable columns)
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create llm_cost_events migration and LlmCostRecord type</name>
  <files>
    src/db/migrations/010-llm-cost-events.sql
    src/db/migrations/010-llm-cost-events.down.sql
    src/telemetry/types.ts
  </files>
  <action>
**Step 1: Create `src/db/migrations/010-llm-cost-events.sql`.**

Full-dimensional schema per CONTEXT.md locked decision:
```sql
CREATE TABLE llm_cost_events (
  id            BIGSERIAL PRIMARY KEY,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  delivery_id   TEXT,
  repo          TEXT NOT NULL,
  task_type     TEXT NOT NULL,
  model         TEXT NOT NULL,
  provider      TEXT NOT NULL,
  sdk           TEXT NOT NULL,           -- 'agent' or 'ai'
  input_tokens  INTEGER NOT NULL DEFAULT 0,
  output_tokens INTEGER NOT NULL DEFAULT 0,
  cache_read_tokens    INTEGER NOT NULL DEFAULT 0,
  cache_write_tokens   INTEGER NOT NULL DEFAULT 0,
  estimated_cost_usd   NUMERIC(12, 8) NOT NULL DEFAULT 0,
  duration_ms   INTEGER,
  used_fallback BOOLEAN NOT NULL DEFAULT false,
  fallback_reason TEXT,
  error         TEXT
);

-- Indexes for common query patterns
CREATE INDEX idx_llm_cost_events_repo ON llm_cost_events (repo);
CREATE INDEX idx_llm_cost_events_task_type ON llm_cost_events (task_type);
CREATE INDEX idx_llm_cost_events_model ON llm_cost_events (model);
CREATE INDEX idx_llm_cost_events_created_at ON llm_cost_events (created_at);
CREATE INDEX idx_llm_cost_events_delivery_id ON llm_cost_events (delivery_id);
```

**Step 2: Create `src/db/migrations/010-llm-cost-events.down.sql`.**
```sql
DROP TABLE IF EXISTS llm_cost_events;
```

**Step 3: Add `LlmCostRecord` type to `src/telemetry/types.ts`.**

Add the type BEFORE the TelemetryStore type definition:
```typescript
/**
 * LLM cost tracking record for per-invocation cost visibility.
 * Maps to the `llm_cost_events` table.
 * Tracks both AI SDK and Agent SDK invocations.
 */
export type LlmCostRecord = {
  deliveryId?: string;
  repo: string;
  taskType: string;
  model: string;
  provider: string;
  sdk: "agent" | "ai";
  inputTokens: number;
  outputTokens: number;
  cacheReadTokens?: number;
  cacheWriteTokens?: number;
  estimatedCostUsd: number;
  durationMs?: number;
  usedFallback: boolean;
  fallbackReason?: string;
  error?: string;
};
```

Add `recordLlmCost` method to the `TelemetryStore` type:
```typescript
/** Insert an LLM cost tracking record into the llm_cost_events table. */
recordLlmCost(entry: LlmCostRecord): Promise<void>;
```
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && ls src/db/migrations/010-llm-cost-events.sql src/db/migrations/010-llm-cost-events.down.sql && bun run tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>Migration 010 creates llm_cost_events table with full-dimensional schema and indexes. LlmCostRecord type exported from telemetry/types.ts. TelemetryStore type includes recordLlmCost method.</done>
</task>

<task type="auto">
  <name>Task 2: Implement recordLlmCost in telemetry store and create cost tracker module</name>
  <files>
    src/telemetry/store.ts
    src/llm/cost-tracker.ts
  </files>
  <action>
**Step 1: Implement `recordLlmCost` in `src/telemetry/store.ts`.**

Add the `recordLlmCost` method to the object returned by `createTelemetryStore`. Follow the existing pattern of the `record()` method (tagged-template SQL with `sql` from opts):

```typescript
async recordLlmCost(entry: LlmCostRecord): Promise<void> {
  try {
    await sql`
      INSERT INTO llm_cost_events (
        delivery_id, repo, task_type, model, provider, sdk,
        input_tokens, output_tokens, cache_read_tokens, cache_write_tokens,
        estimated_cost_usd, duration_ms, used_fallback, fallback_reason, error
      ) VALUES (
        ${entry.deliveryId ?? null},
        ${entry.repo},
        ${entry.taskType},
        ${entry.model},
        ${entry.provider},
        ${entry.sdk},
        ${entry.inputTokens},
        ${entry.outputTokens},
        ${entry.cacheReadTokens ?? 0},
        ${entry.cacheWriteTokens ?? 0},
        ${entry.estimatedCostUsd},
        ${entry.durationMs ?? null},
        ${entry.usedFallback},
        ${entry.fallbackReason ?? null},
        ${entry.error ?? null}
      )
    `;
  } catch (err) {
    logger.warn({ err, entry }, "Failed to record LLM cost event");
  }
}
```

Import `LlmCostRecord` from `./types.ts`.

Also extend `purgeOlderThan` to include llm_cost_events:
```typescript
// Inside purgeOlderThan, after existing DELETE statements:
await sql`DELETE FROM llm_cost_events WHERE created_at < now() - interval '${days} days'`;
```

**Step 2: Create `src/llm/cost-tracker.ts`.**

Build a convenience module that wraps cost estimation + telemetry store recording:

```typescript
import type { Logger } from "pino";
import type { TelemetryStore, LlmCostRecord } from "../telemetry/types.ts";
import { estimateCost } from "./pricing.ts";

export type { LlmCostRecord };

export type CostTracker = {
  trackAiSdkCall(params: {
    repo: string;
    taskType: string;
    model: string;
    provider: string;
    inputTokens: number;
    outputTokens: number;
    cacheReadTokens?: number;
    cacheWriteTokens?: number;
    durationMs: number;
    usedFallback: boolean;
    fallbackReason?: string;
    deliveryId?: string;
    error?: string;
  }): Promise<void>;

  trackAgentSdkCall(params: {
    repo: string;
    taskType: string;
    model: string;
    inputTokens: number;
    outputTokens: number;
    cacheReadTokens?: number;
    cacheWriteTokens?: number;
    durationMs: number;
    costUsd?: number;
    deliveryId?: string;
    error?: string;
  }): Promise<void>;
};

export function createCostTracker(deps: {
  telemetryStore: TelemetryStore;
  logger: Logger;
}): CostTracker;
```

Implementation:
- `trackAiSdkCall`: compute `estimatedCostUsd` via `estimateCost()`, build `LlmCostRecord` with `sdk: "ai"`, call `telemetryStore.recordLlmCost()`. Wrap in try/catch, log warning on failure (fail-open per project philosophy).
- `trackAgentSdkCall`: use provided `costUsd` from Agent SDK `resultMessage.total_cost_usd` when available, otherwise compute via `estimateCost()`. Build `LlmCostRecord` with `sdk: "agent"`, extract provider from model using `extractProvider()`. Call `telemetryStore.recordLlmCost()`. Fail-open.

Both methods are fire-and-forget (caller does not await). They should never throw -- all errors caught and logged.

Also export `createCostTracker` from `src/llm/index.ts` barrel.
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && bun run tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>TelemetryStore.recordLlmCost() writes to llm_cost_events table. CostTracker provides trackAiSdkCall and trackAgentSdkCall convenience methods with automatic cost estimation. All errors fail-open with warnings. TypeScript compiles clean.</done>
</task>

</tasks>

<verification>
- `bun run tsc --noEmit` passes with zero errors
- Migration 010 SQL is valid (CREATE TABLE, indexes, down migration)
- `src/telemetry/types.ts` exports LlmCostRecord type
- `src/telemetry/store.ts` implements recordLlmCost method
- `src/llm/cost-tracker.ts` exports createCostTracker factory
- Cost tracker uses estimateCost from pricing module (not hardcoded)
</verification>

<success_criteria>
- LlmCostRecord type includes all required fields: repo, taskType, model, provider, sdk, inputTokens, outputTokens, estimatedCostUsd
- TelemetryStore has recordLlmCost method that INSERTs into llm_cost_events
- CostTracker.trackAiSdkCall computes cost from pricing config and records to store
- CostTracker.trackAgentSdkCall records Agent SDK executions with sdk:"agent"
- Migration produces llm_cost_events table with indexes on repo, task_type, model, created_at
</success_criteria>

<output>
After completion, create `.planning/phases/97-multi-llm-routing-cost-tracking/97-02-SUMMARY.md`
</output>
