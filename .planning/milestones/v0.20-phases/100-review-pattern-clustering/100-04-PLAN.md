---
phase: 100-review-pattern-clustering
plan: 04
type: tdd
wave: 2
depends_on: [01, 02]
files_modified:
  - src/knowledge/cluster-matcher.ts
  - src/knowledge/cluster-matcher.test.ts
autonomous: true
requirements: [CLST-03]

must_haves:
  truths:
    - PR diffs are matched against active clusters using dual signals (embedding similarity + file path overlap)
    - Only clusters with 3+ members in last 60 days are surfaced
    - Maximum 3 pattern matches returned per PR
    - Recency weighting favors recent comments within the 60-day window
  artifacts:
    - src/knowledge/cluster-matcher.ts
    - src/knowledge/cluster-matcher.test.ts
  key_links:
    - cluster-matcher.ts imports ClusterStore and ClusterPatternMatch from cluster-types.ts
    - cluster-matcher.ts returns ClusterPatternMatch[] consumed by review prompt formatter
---

<objective>
Implement pattern matching that identifies which active clusters are relevant to a given PR diff.

Purpose: Bridge between clustering pipeline and review prompt injection â€” finds the right patterns for each PR.
Output: Matcher module with TDD tests covering dual-signal scoring and threshold filtering.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/references/tdd.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/100-review-pattern-clustering/100-RESEARCH.md

<interfaces>
From src/knowledge/cluster-types.ts (plan 01):
```typescript
export type ReviewCluster = {
  id: number; repo: string; slug: string; label: string;
  centroid: Float32Array; memberCount: number;
  filePaths: string[]; retired: boolean;
  createdAt: Date; updatedAt: Date;
};
export type ClusterPatternMatch = {
  clusterId: number; slug: string; label: string;
  memberCount: number; similarityScore: number;
  filePathOverlap: number; combinedScore: number;
  representativeSample: string;
};
export type ClusterStore = {
  getActiveClusters(repo: string): Promise<ReviewCluster[]>;
  getAssignmentsByCluster(clusterId: number): Promise<ClusterAssignment[]>;
};
```

From src/knowledge/embeddings.ts:
```typescript
export type EmbeddingProvider = {
  generate(text: string, inputType: "document" | "query"): Promise<EmbeddingResult>;
};
```

From src/knowledge/review-comment-types.ts:
```typescript
export type ReviewCommentRecord = {
  id: number; chunkText: string; filePath: string | null;
  githubCreatedAt: string;
};
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement and test cluster pattern matcher (TDD)</name>
  <files>src/knowledge/cluster-matcher.ts, src/knowledge/cluster-matcher.test.ts</files>
  <action>
Implement dual-signal pattern matching using TDD (RED-GREEN-REFACTOR).

**Write tests first** in `cluster-matcher.test.ts`:

1. **Happy path**: 3 active clusters, PR embedding similar to cluster A (cosine sim 0.85), PR files overlap with cluster A file paths (50%) -> returns cluster A as top match.

2. **Dual signal scoring**: Cluster with high embedding similarity but no file overlap scores lower than cluster with moderate similarity AND file overlap.

3. **Max 3 matches**: 5 clusters all matching -> only top 3 returned, sorted by combinedScore DESC.

4. **Minimum threshold**: Cluster with combinedScore < 0.3 -> excluded even if it's the only match.

5. **Member count filter**: Cluster with 2 members in last 60 days -> excluded (needs 3+). Cluster with 5 members -> included.

6. **Retired cluster skip**: Cluster with retired=true -> never matched.

7. **Recency weighting**: Two clusters with same similarity but different average comment age. Cluster with more recent comments (within 60 days) has higher effective score.

8. **Empty clusters**: No active clusters -> returns empty array.

9. **No embedding available**: PR embedding is null -> returns empty array (fail-open).

10. **Representative sample**: Returned matches include a representative chunk text from the cluster.

**Then implement** `cluster-matcher.ts`:

```typescript
export type MatchPatternsInput = {
  prEmbedding: Float32Array | null;
  prFilePaths: string[];
  repo: string;
};

export async function matchClusterPatterns(
  input: MatchPatternsInput,
  store: ClusterStore,
  sql: Sql,
  logger: Logger,
): Promise<ClusterPatternMatch[]>
```

**Matching algorithm:**

1. If prEmbedding is null, return [] (fail-open).

2. Fetch active clusters: `store.getActiveClusters(repo)`.

3. For each cluster:
   a. **Cosine similarity**: Compute between prEmbedding and cluster.centroid (both 1024-dim Float32Arrays).
      ```typescript
      function cosineSimilarity(a: Float32Array, b: Float32Array): number {
        let dot = 0, normA = 0, normB = 0;
        for (let i = 0; i < a.length; i++) {
          dot += a[i] * b[i];
          normA += a[i] * a[i];
          normB += b[i] * b[i];
        }
        return dot / (Math.sqrt(normA) * Math.sqrt(normB));
      }
      ```

   b. **File path overlap**: Jaccard similarity between PR file paths and cluster.filePaths.
      ```typescript
      function filePathOverlap(prPaths: string[], clusterPaths: string[]): number {
        const prSet = new Set(prPaths);
        const clusterSet = new Set(clusterPaths);
        const intersection = [...prSet].filter(p => clusterSet.has(p)).length;
        const union = new Set([...prSet, ...clusterSet]).size;
        return union === 0 ? 0 : intersection / union;
      }
      ```

   c. **Recency weight**: Query average github_created_at of cluster members within last 60 days. Compute recency factor: `Math.max(0.5, 1 - (avgAgeDays / 60))` where avgAgeDays = average days since creation. This gives a 0.5-1.0 multiplier.

   d. **Combined score**: `(0.6 * cosineSim + 0.4 * filePathOverlap) * recencyWeight`

   e. **Member count in 60-day window**: Query count of cluster assignments where review comment's github_created_at >= NOW() - 60 days. Skip if < 3.

4. Filter: combinedScore >= 0.3 (minimum threshold for surfacing).

5. Sort by combinedScore DESC, take top 3.

6. For each match, fetch one representative sample (highest probability assignment's chunkText).

7. Return ClusterPatternMatch[].

**Cosine similarity helper** should be exported for reuse.

**Performance note**: getActiveClusters returns all non-retired clusters for the repo. For repos with many clusters, the O(clusters * dimensions) cosine computation is fast since it's simple float arithmetic.
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && bun test src/knowledge/cluster-matcher.test.ts 2>&1 | tail -20</automated>
  </verify>
  <done>All matcher tests pass. Dual-signal scoring works correctly. Max 3 matches enforced. Minimum threshold filters weak matches. Member count and retired filters applied. Recency weighting favors recent clusters.</done>
</task>

</tasks>

<verification>
- [ ] Dual-signal scoring: embedding cosine similarity (0.6 weight) + file path Jaccard overlap (0.4 weight)
- [ ] Recency weighting multiplier applied (0.5-1.0 range)
- [ ] 3+ members in 60-day window required for surfacing
- [ ] Max 3 matches returned per PR
- [ ] Minimum combined score threshold of 0.3
- [ ] Retired clusters excluded
- [ ] Null embedding -> empty result (fail-open)
- [ ] Representative sample included in each match
- [ ] All tests pass
</verification>

<success_criteria>
- Matcher correctly identifies relevant clusters for a PR using both embedding similarity and file path overlap
- Edge cases handled: no clusters, no embedding, below threshold, retired clusters
- Results capped at 3, sorted by combined score
</success_criteria>

<output>
After completion, create `.planning/phases/100-review-pattern-clustering/100-04-SUMMARY.md`
</output>
