---
phase: 02-job-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/jobs/workspace.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "A job receives a workspace with a shallow clone of the target repo in a unique temp directory"
    - "The clone URL uses x-access-token:{installationToken} for authentication"
    - "Git user.name and user.email are configured as kodiai[bot] in the cloned workspace"
    - "After job success, the temp directory is deleted"
    - "After job failure (thrown error), the temp directory is still deleted"
    - "Branch names are validated before use in git commands (rejects leading dashes, control chars, etc.)"
    - "Stale kodiai-* temp dirs from previous runs are cleaned up on server startup"
    - "The clone URL token is never logged (redacted)"
  artifacts:
    - path: "src/jobs/workspace.ts"
      provides: "Workspace manager with clone, auth, cleanup, branch validation, stale cleanup"
      exports: ["createWorkspaceManager"]
    - path: "src/index.ts"
      provides: "Job queue and workspace manager wired into server startup"
      contains: "createJobQueue"
  key_links:
    - from: "src/jobs/workspace.ts"
      to: "src/auth/github-app.ts"
      via: "getInstallationToken for clone URL auth"
      pattern: "getInstallationToken"
    - from: "src/jobs/workspace.ts"
      to: "src/jobs/types.ts"
      via: "imports WorkspaceManager, Workspace, CloneOptions"
      pattern: "import.*from.*types"
    - from: "src/index.ts"
      to: "src/jobs/queue.ts"
      via: "creates job queue instance"
      pattern: "createJobQueue"
    - from: "src/index.ts"
      to: "src/jobs/workspace.ts"
      via: "creates workspace manager and calls cleanupStale"
      pattern: "createWorkspaceManager"
---

<objective>
Create the workspace manager module and wire all job infrastructure into the server.

Purpose: Completes the job infrastructure by providing ephemeral workspace creation (clone, git auth, cleanup) and wiring both the job queue and workspace manager into the server's startup sequence. After this plan, webhook handlers can enqueue jobs that get fresh cloned workspaces with automatic cleanup.
Output: src/jobs/workspace.ts (createWorkspaceManager factory), updated src/index.ts with job infrastructure wiring
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-job-infrastructure/02-RESEARCH.md
@.planning/phases/02-job-infrastructure/02-01-SUMMARY.md
@src/auth/github-app.ts
@src/jobs/types.ts
@src/jobs/queue.ts
@src/index.ts
@src/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create workspace manager with clone, auth, cleanup, and branch validation</name>
  <files>src/jobs/workspace.ts</files>
  <action>
Create `src/jobs/workspace.ts` with a `createWorkspaceManager` factory function.

**Dependencies:**
```typescript
import { mkdtemp, rm, readdir, stat } from "node:fs/promises";
import { join } from "node:path";
import { tmpdir } from "node:os";
import { $ } from "bun";
import type { Logger } from "pino";
import type { GitHubApp } from "../auth/github-app.ts";
import type { WorkspaceManager, Workspace, CloneOptions } from "./types.ts";
```

**Factory signature:** `createWorkspaceManager(githubApp: GitHubApp, logger: Logger): WorkspaceManager`

**Implement `validateBranchName(branchName: string): void`** (non-exported helper):
Port the validation from the reference code (tmp/claude-code-action/src/github/operations/branch.ts):
- Reject empty/whitespace-only names
- Reject names starting with `-` (git option injection)
- Reject control characters (\x00-\x1F, \x7F) and special git chars (~, ^, :, ?, *, [, ], \)
- Enforce pattern: starts with alphanumeric, then alphanumeric/underscore/slash/dot/dash
- Reject `..` (parent traversal), `.lock` suffix, `@{` (reflog), trailing `/`, consecutive `//`
- Throw descriptive Error for each violation

**Implement `create(installationId, options)`:**
1. Call `validateBranchName(options.ref)` first -- throw before creating any temp dir.
2. Create temp dir: `await mkdtemp(join(tmpdir(), "kodiai-"))`.
3. Get token: `const token = await githubApp.getInstallationToken(installationId)`.
4. Build clone URL: `https://x-access-token:${token}@github.com/${owner}/${repo}.git` -- NEVER log this URL.
5. Clone: `await $\`git clone --depth=${depth ?? 1} --single-branch --branch ${ref} ${cloneUrl} ${dir}\`.quiet()` -- use `.quiet()` to suppress output that may contain the token in error messages.
6. Configure git identity:
   - `await $\`git -C ${dir} config user.name "kodiai[bot]"\``
   - `await $\`git -C ${dir} config user.email "kodiai[bot]@users.noreply.github.com"\``
7. Log success: `logger.info({ owner, repo, ref, dir }, "Workspace created")` -- owner/repo/ref are safe to log, token is NOT.
8. Return `{ dir, cleanup }` where `cleanup` is an async function that calls `await rm(dir, { recursive: true, force: true })` and logs at debug level.
9. **On any error in steps 3-6:** Catch, clean up the temp dir (await rm with recursive/force, wrapped in .catch(() => {}) so cleanup failure doesn't mask the original error), then re-throw. If the error message contains the token, redact it before re-throwing: replace the token substring with `[REDACTED]`.

**Implement `cleanupStale(): Promise<number>`:**
1. Read the system tmpdir contents via `readdir(tmpdir())`.
2. Filter entries starting with `kodiai-`.
3. For each matching entry, `stat()` it -- if mtime is older than 1 hour, `rm({ recursive: true, force: true })`.
4. Count and return the number of directories removed.
5. Wrap the entire function in try/catch -- if readdir or stat fails, log warning and return 0 (non-fatal).
6. Log at info level: `{ removed: count }, "Stale workspaces cleaned up"` (only if count > 0).

**Token redaction helper** (non-exported):
```typescript
function redactToken(message: string, token: string): string {
  return message.replaceAll(token, "[REDACTED]");
}
```
Use this when re-throwing git errors to prevent token leakage in stack traces.
  </action>
  <verify>
`bunx tsc --noEmit` passes. Verify:
1. `src/jobs/workspace.ts` exports `createWorkspaceManager`.
2. Quick import check: `bun -e "import { createWorkspaceManager } from './src/jobs/workspace.ts'; console.log(typeof createWorkspaceManager)"` prints "function".
3. Branch validation rejects dangerous inputs: `bun -e "import('./src/jobs/workspace.ts')"` does not throw at import time (runtime validation only).
  </verify>
  <done>createWorkspaceManager factory creates workspaces with shallow clone, token-based git auth, bot identity config, try/finally cleanup, branch validation, token redaction, and stale workspace cleanup.</done>
</task>

<task type="auto">
  <name>Task 2: Wire job infrastructure into server startup</name>
  <files>src/index.ts</files>
  <action>
Update `src/index.ts` to create and wire the job queue and workspace manager:

1. Add imports:
   ```typescript
   import { createJobQueue } from "./jobs/queue.ts";
   import { createWorkspaceManager } from "./jobs/workspace.ts";
   ```

2. After the `githubApp.initialize()` block and before the bot filter/event router block, add:
   ```typescript
   // Job infrastructure
   const jobQueue = createJobQueue(logger);
   const workspaceManager = createWorkspaceManager(githubApp, logger);

   // Defense-in-depth: clean up any stale workspaces from previous runs
   const staleCount = await workspaceManager.cleanupStale();
   if (staleCount > 0) {
     logger.info({ staleCount }, "Cleaned up stale workspaces from previous run");
   }
   ```

3. Update the comment about Phase 2+ handlers to reflect that job infrastructure is now available:
   ```typescript
   // Phase 3+ plans will register handlers that use jobQueue and workspaceManager.
   // Example: eventRouter.register("pull_request.opened", async (event) => {
   //   await jobQueue.enqueue(event.installationId, async () => {
   //     const ws = await workspaceManager.create(event.installationId, { owner, repo, ref });
   //     try { /* run job */ } finally { await ws.cleanup(); }
   //   });
   // });
   ```

The jobQueue and workspaceManager are created as local constants. They will be passed to handler registration code in Phase 3+ (either via deps injection or direct reference). For now, they are initialized and the stale cleanup runs at startup.

Do NOT export jobQueue or workspaceManager as module-level exports -- they will be wired into handler registration when Phase 3 adds real handlers.
  </action>
  <verify>
1. `bunx tsc --noEmit` passes with zero errors.
2. `bun run src/index.ts` starts without crashing (will fail at GitHub auth but that's expected without real credentials -- the imports and wiring are the verification target).
3. Verify src/index.ts imports createJobQueue and createWorkspaceManager.
  </verify>
  <done>Job queue and workspace manager are created at server startup. Stale workspace cleanup runs on boot. The infrastructure is ready for Phase 3+ handlers to use via jobQueue.enqueue() and workspaceManager.create().</done>
</task>

</tasks>

<verification>
1. `bunx tsc --noEmit` passes with zero errors across entire project
2. All new files exist: src/jobs/workspace.ts
3. src/index.ts imports and creates both jobQueue and workspaceManager
4. Workspace manager implements: create (clone + auth + cleanup), cleanupStale, validateBranchName
5. Token is never logged -- grep for "token" in log calls should only find debug-level "Obtained installation token" with no value
6. Factory function pattern followed (createWorkspaceManager)
</verification>

<success_criteria>
- Workspace creation: mkdtemp + git clone with token auth + git config for bot identity
- Workspace cleanup: rm(dir, {recursive: true, force: true}) in both success and failure paths
- Branch validation rejects dangerous names (leading dash, control chars, .., .lock, @{, //, trailing /)
- Token redaction in error messages prevents leakage
- Stale workspace cleanup on startup removes kodiai-* dirs older than 1 hour
- Server starts cleanly with job infrastructure wired in
- TypeScript compiles with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-job-infrastructure/02-02-SUMMARY.md`
</output>
