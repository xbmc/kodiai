---
phase: 02-job-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/jobs/types.ts
  - src/jobs/queue.ts
  - src/auth/github-app.ts
autonomous: true

must_haves:
  truths:
    - "jobQueue.enqueue(installationId, fn) accepts a job and returns a Promise that resolves when the job completes"
    - "Two jobs for the same installation ID run sequentially (concurrency 1)"
    - "Two jobs for different installation IDs can run in parallel"
    - "getInstallationToken(installationId) returns a raw token string for git URL auth"
    - "Idle queue instances are pruned to prevent memory leaks"
  artifacts:
    - path: "src/jobs/types.ts"
      provides: "Job and workspace type definitions"
      contains: "interface JobQueue"
    - path: "src/jobs/queue.ts"
      provides: "Per-installation concurrency queue using p-queue"
      exports: ["createJobQueue"]
    - path: "src/auth/github-app.ts"
      provides: "getInstallationToken method on GitHubApp interface"
      contains: "getInstallationToken"
  key_links:
    - from: "src/jobs/queue.ts"
      to: "src/jobs/types.ts"
      via: "import JobQueue type"
      pattern: "import.*from.*types"
    - from: "src/jobs/queue.ts"
      to: "p-queue"
      via: "PQueue per installation"
      pattern: "new PQueue"
---

<objective>
Create the job queue module with per-installation concurrency control and extend GitHubApp with raw token access.

Purpose: Provides the concurrency infrastructure that ensures only one job runs per GitHub App installation at a time, while allowing parallel execution across installations. Also exposes raw installation tokens needed by the workspace manager in Plan 02.
Output: src/jobs/types.ts, src/jobs/queue.ts (createJobQueue factory), updated src/auth/github-app.ts with getInstallationToken
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-job-infrastructure/02-RESEARCH.md
@src/auth/github-app.ts
@src/webhook/types.ts
@src/config.ts
@src/lib/logger.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install p-queue and create job types</name>
  <files>package.json, src/jobs/types.ts</files>
  <action>
Run `bun install p-queue` to add p-queue v9.x dependency.

Create `src/jobs/types.ts` with these type definitions:

```typescript
import type { Logger } from "pino";

/** Options for creating a workspace (clone target) */
export interface CloneOptions {
  owner: string;
  repo: string;
  ref: string;         // branch name to checkout
  depth?: number;      // shallow clone depth (default: 1)
}

/** An ephemeral workspace with a cloned repo */
export interface Workspace {
  /** Absolute path to the cloned repo directory */
  dir: string;
  /** Clean up the workspace directory. Idempotent, never throws. */
  cleanup(): Promise<void>;
}

/** Job queue with per-installation concurrency control */
export interface JobQueue {
  /** Enqueue a job for an installation. Returns a Promise resolving to the job result. */
  enqueue<T>(installationId: number, fn: () => Promise<T>): Promise<T>;
  /** Number of waiting (not yet running) jobs for an installation */
  getQueueSize(installationId: number): number;
  /** Number of currently running jobs for an installation */
  getPendingCount(installationId: number): number;
}

/** Workspace manager creates and cleans up ephemeral workspaces */
export interface WorkspaceManager {
  /** Create a workspace: temp dir + shallow clone with git auth */
  create(installationId: number, options: CloneOptions): Promise<Workspace>;
  /** Remove any stale kodiai-* temp dirs from previous runs (startup defense-in-depth) */
  cleanupStale(): Promise<number>;
}
```

Keep types minimal and focused. The `CloneOptions` takes explicit `owner`/`repo` (not derived from event) so the handler can determine the correct clone target for fork PRs.
  </action>
  <verify>
`bunx tsc --noEmit` passes with no errors. `bun install` succeeds (p-queue in node_modules). Verify `src/jobs/types.ts` exists and exports all 4 interfaces.
  </verify>
  <done>p-queue is installed. src/jobs/types.ts exports CloneOptions, Workspace, JobQueue, and WorkspaceManager interfaces.</done>
</task>

<task type="auto">
  <name>Task 2: Create job queue and extend GitHubApp with getInstallationToken</name>
  <files>src/jobs/queue.ts, src/auth/github-app.ts</files>
  <action>
**Create `src/jobs/queue.ts`** with a `createJobQueue(logger: Logger): JobQueue` factory function:

- Import PQueue from "p-queue" (default import, ESM).
- Use a `Map<number, PQueue>` to store one PQueue per installation ID.
- Each PQueue is created with `{ concurrency: 1 }`.
- Lazy initialization: create the PQueue on first enqueue for an installation.
- `enqueue<T>(installationId, fn)`: get or create queue, call `queue.add(fn)`, return the result. Log at debug level when enqueuing (include installationId, queueSize, pendingCount).
- `getQueueSize(id)`: return `queues.get(id)?.size ?? 0`.
- `getPendingCount(id)`: return `queues.get(id)?.pending ?? 0`.
- **Idle queue pruning:** After each job completes (in the enqueue wrapper), check if the queue is empty (size === 0 and pending === 0). If so, delete it from the map. This prevents the Map from growing unbounded. Log at debug level when pruning.

**Extend `src/auth/github-app.ts`:**

Add `getInstallationToken(installationId: number): Promise<string>` to the `GitHubApp` interface and implement it in `createGitHubApp`:

```typescript
async getInstallationToken(installationId: number): Promise<string> {
  // Use createAppAuth directly to get a raw token (not an Octokit client).
  // auth-app internally caches tokens and refreshes before expiry.
  const auth = createAppAuth({
    appId: config.githubAppId,
    privateKey: config.githubPrivateKey,
  });

  const result = await auth({
    type: "installation",
    installationId,
  });

  return result.token;
}
```

Add this method to the interface declaration AND to the returned object in createGitHubApp. Do NOT log the token value. Log at debug level: `{ installationId }, "Obtained installation token"`.

**Important:** The `queue.add()` return type from p-queue is `Promise<T | void>`. Handle this by casting: `return queue.add(fn) as Promise<T>`. The void case only occurs when `throwOnTimeout` is used with a timeout, which we don't configure.
  </action>
  <verify>
`bunx tsc --noEmit` passes. Verify:
1. `src/jobs/queue.ts` exports `createJobQueue`.
2. `src/auth/github-app.ts` interface includes `getInstallationToken`.
3. Quick smoke test: `bun -e "import { createJobQueue } from './src/jobs/queue.ts'; console.log(typeof createJobQueue)"` prints "function".
  </verify>
  <done>createJobQueue factory creates per-installation PQueue(concurrency: 1) instances with lazy creation and idle pruning. GitHubApp.getInstallationToken() returns raw token strings for git URL auth.</done>
</task>

</tasks>

<verification>
1. `bunx tsc --noEmit` passes with zero errors
2. `bun install` shows p-queue in dependencies
3. All new files exist: src/jobs/types.ts, src/jobs/queue.ts
4. GitHubApp interface includes getInstallationToken method
5. Factory function pattern followed (createJobQueue)
</verification>

<success_criteria>
- p-queue installed as a dependency
- JobQueue interface enforces per-installation concurrency via PQueue(concurrency: 1)
- Queue map lazily creates and prunes idle PQueue instances
- GitHubApp exposes getInstallationToken() for raw token access
- All types (CloneOptions, Workspace, JobQueue, WorkspaceManager) exported from src/jobs/types.ts
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/02-job-infrastructure/02-01-SUMMARY.md`
</output>
