---
phase: 98-contributor-profiles-identity-linking
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/slack/slash-command-handler.ts
  - src/slack/slash-command-handler.test.ts
  - src/routes/slack-commands.ts
  - src/routes/slack-commands.test.ts
autonomous: true
requirements:
  - PROF-02
  - PROF-05

must_haves:
  truths:
    - "Slack slash command /kodiai link <github-username> creates a cross-platform identity link"
    - "Slack slash command /kodiai unlink removes the Slack link but keeps expertise data"
    - "Slack slash command /kodiai profile shows linked identities, expertise scores, and tier"
    - "Slack slash command /kodiai profile opt-out stops data collection for the contributor"
    - "All slash commands respond within 3 seconds with immediate acknowledgment"
  artifacts:
    - path: "src/slack/slash-command-handler.ts"
      provides: "handleKodiaiCommand dispatcher with link/unlink/profile/opt-out subcommands"
      exports: ["handleKodiaiCommand", "SlashCommandResult"]
    - path: "src/routes/slack-commands.ts"
      provides: "Hono route for /command endpoint receiving form-encoded Slack payloads"
      exports: ["createSlackCommandRoutes"]
    - path: "src/routes/slack-commands.test.ts"
      provides: "Route-level tests for slash command endpoint"
      min_lines: 50
  key_links:
    - from: "src/routes/slack-commands.ts"
      to: "src/slack/verify.ts"
      via: "verifySlackRequest for HMAC signature validation"
      pattern: "verifySlackRequest"
    - from: "src/slack/slash-command-handler.ts"
      to: "src/contributor/profile-store.ts"
      via: "ContributorProfileStore for link/unlink/profile/opt-out operations"
      pattern: "ContributorProfileStore"
---

<objective>
Build the Slack slash command endpoint and handler for identity linking, unlinking, profile viewing, and opt-out -- the user-facing interaction surface for contributor profiles.

Purpose: This is the single entry point for cross-platform identity linking (Slack is the entry point, per user decision).
Output: Hono route for slash commands, handler with subcommand dispatch, tests.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/98-contributor-profiles-identity-linking/98-CONTEXT.md
@.planning/phases/98-contributor-profiles-identity-linking/98-RESEARCH.md

@src/routes/slack-events.ts (route pattern reference)
@src/slack/verify.ts (request verification)
@src/slack/client.ts (Slack API client pattern)

<interfaces>
<!-- Key types the executor needs -->

From src/slack/verify.ts:
```typescript
export function verifySlackRequest(input: VerifySlackRequestInput): SlackVerifyResult;
```

From src/routes/slack-events.ts (route factory pattern):
```typescript
export function createSlackEventRoutes(deps: SlackEventsRouteDeps): Hono {
```

From src/contributor/types.ts (will be created by Plan 01, but Plan 02 can define its own interface dependency):
```typescript
// Plan 02 depends on ContributorProfileStore interface from Plan 01.
// If executing in parallel (both Wave 1), the handler should accept a
// ContributorProfileStore parameter -- the actual store implementation
// will be wired when both plans complete. Use a minimal inline interface
// if types.ts doesn't exist yet:
interface ProfileStoreForCommands {
  getBySlackUserId(slackUserId: string): Promise<any | null>;
  getByGithubUsername(username: string): Promise<any | null>;
  linkIdentity(params: { slackUserId: string; githubUsername: string; displayName: string }): Promise<any>;
  unlinkSlack(githubUsername: string): Promise<void>;
  setOptedOut(githubUsername: string, optedOut: boolean): Promise<void>;
  getExpertise(profileId: number): Promise<any[]>;
}
```

Slack slash command payloads are form-encoded (NOT JSON):
- `command` = "/kodiai"
- `text` = "link octocat" (subcommand + args)
- `user_id` = Slack user ID
- `user_name` = Slack display name
- `response_url` = URL for async follow-up (within 30 minutes)
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create slash command handler with subcommand dispatch</name>
  <files>
    src/slack/slash-command-handler.ts
    src/slack/slash-command-handler.test.ts
  </files>
  <action>
    Create `src/slack/slash-command-handler.ts`:

    Export `SlashCommandResult` type:
    ```typescript
    export type SlashCommandResult = {
      responseType: "ephemeral" | "in_channel";
      text: string;
      asyncWork?: () => Promise<void>;  // Deferred work after immediate 200 response
    };
    ```

    Export `handleKodiaiCommand(params)` function accepting:
    - `text: string` — raw subcommand text from Slack (e.g., "link octocat")
    - `slackUserId: string`
    - `slackUserName: string`
    - `profileStore: ContributorProfileStore` (import from `../contributor/types.ts`)
    - `logger: Logger`

    Parse `text` into subcommand + args by splitting on whitespace.

    Subcommands:

    **`link <github-username>`:**
    - Validate github-username is provided, non-empty, alphanumeric with hyphens (GitHub username rules)
    - Call `profileStore.linkIdentity({ slackUserId, githubUsername, displayName: slackUserName })`
    - Return ephemeral: "Linked your Slack account to GitHub user `<username>`. Your contributor profile is now active."
    - Set `asyncWork` to seed expertise (placeholder — actual seeding in Plan 03). For now, log: "Expertise seeding deferred to background job"

    **`unlink`:**
    - Look up profile by slackUserId. If not found, return "No linked GitHub account found."
    - Call `profileStore.unlinkSlack(profile.githubUsername)`
    - Return ephemeral: "Unlinked your Slack account from GitHub user `<username>`. Your expertise data is preserved."

    **`profile` (no args):**
    - Look up profile by slackUserId. If not found, return "No profile found. Link with `/kodiai link <github-username>`"
    - Fetch expertise via `profileStore.getExpertise(profile.id)`
    - Format response showing: GitHub username, tier, overall score, top expertise entries (up to 5), opted-out status
    - Return ephemeral with formatted profile card

    **`profile opt-out`:**
    - Look up profile by slackUserId. If not found, return "No profile found."
    - Call `profileStore.setOptedOut(profile.githubUsername, true)`
    - Return ephemeral: "Opted out of contributor profiling. You will receive generic (non-adapted) reviews."

    **`profile opt-in`:** (reverse of opt-out)
    - Call `profileStore.setOptedOut(profile.githubUsername, false)`
    - Return ephemeral: "Opted back in to contributor profiling."

    **Default (unknown subcommand):**
    - Return ephemeral: "Unknown command. Available: `link <github-username>`, `unlink`, `profile`, `profile opt-out`"

    Create `src/slack/slash-command-handler.test.ts`:
    - Mock profileStore with jest-style inline mocks
    - Test: `link octocat` calls linkIdentity and returns success message
    - Test: `link` with no username returns validation error
    - Test: `link invalid username!` with special chars returns validation error
    - Test: `unlink` with linked profile unlinks and returns success
    - Test: `unlink` with no profile returns "No linked account"
    - Test: `profile` with linked profile returns formatted card
    - Test: `profile opt-out` sets opted_out to true
    - Test: unknown subcommand returns help text
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && bun test src/slack/slash-command-handler.test.ts</automated>
  </verify>
  <done>Handler dispatches link/unlink/profile/opt-out subcommands with proper validation. All 8+ unit tests pass with mocked store.</done>
</task>

<task type="auto">
  <name>Task 2: Create Hono route for slash command webhook endpoint</name>
  <files>
    src/routes/slack-commands.ts
    src/routes/slack-commands.test.ts
  </files>
  <action>
    Create `src/routes/slack-commands.ts`:

    Export `createSlackCommandRoutes(deps)` factory function following the pattern from `createSlackEventRoutes`:

    Deps interface:
    ```typescript
    interface SlackCommandRouteDeps {
      config: AppConfig;
      logger: Logger;
      profileStore: ContributorProfileStore;
    }
    ```

    Single POST route at root (`/`):
    1. Read raw body text: `const rawBody = await c.req.text()`
    2. Verify Slack signature using `verifySlackRequest()` from `../slack/verify.ts` with `config.slack.signingSecret`, request headers, and rawBody. Return 401 if invalid.
    3. Parse form-encoded body: `const params = new URLSearchParams(rawBody)`
    4. Extract: `command` (should be "/kodiai"), `text`, `user_id`, `user_name`, `response_url`
    5. Call `handleKodiaiCommand({ text, slackUserId: user_id, slackUserName: user_name, profileStore, logger })`
    6. If result has `asyncWork`, fire it as fire-and-forget: `result.asyncWork().catch(err => logger.warn({ err }, "Slash command async work failed"))`
    7. Return immediately (within 3 seconds): `c.json({ response_type: result.responseType, text: result.text })`

    Note: Do NOT register this route in `src/index.ts` yet — that wiring happens in Plan 04 when all pieces are integrated. For now, the route is a standalone module.

    Create `src/routes/slack-commands.test.ts`:
    - Test: valid signed request dispatches to handler and returns 200 with JSON
    - Test: invalid signature returns 401
    - Test: missing text param still dispatches (shows help)
    - Mock verifySlackRequest and profileStore
    - Follow test patterns from `src/routes/slack-events.test.ts`
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && bun test src/routes/slack-commands.test.ts</automated>
  </verify>
  <done>Hono route receives form-encoded slash command payloads, verifies Slack signatures, dispatches to handler, and returns within 3 seconds. Route and handler tests pass.</done>
</task>

</tasks>

<verification>
- All slash-command-handler tests pass (8+ tests)
- All slack-commands route tests pass (3+ tests)
- TypeScript compiles with no errors
- Handler properly validates GitHub usernames
- Responses are ephemeral (only visible to the user who typed the command)
</verification>

<success_criteria>
- `/kodiai link <username>` creates identity link via profile store
- `/kodiai unlink` removes Slack link, preserves expertise
- `/kodiai profile` displays contributor profile card
- `/kodiai profile opt-out` sets privacy flag
- All responses are ephemeral and return within 3 seconds
- Slack signature verification protects the endpoint
</success_criteria>

<output>
After completion, create `.planning/phases/98-contributor-profiles-identity-linking/98-02-SUMMARY.md`
</output>
