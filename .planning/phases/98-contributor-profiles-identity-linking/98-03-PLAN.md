---
phase: 98-contributor-profiles-identity-linking
plan: 03
type: execute
wave: 2
depends_on: ["98-01"]
files_modified:
  - src/contributor/expertise-scorer.ts
  - src/contributor/expertise-scorer.test.ts
  - src/contributor/tier-calculator.ts
  - src/contributor/tier-calculator.test.ts
  - src/contributor/identity-matcher.ts
  - src/contributor/identity-matcher.test.ts
autonomous: true
requirements:
  - PROF-03

must_haves:
  truths:
    - "Expertise scores are computed from commit history, PR authorship, and PR review activity with recency decay"
    - "Scores are two-dimensional: programming language AND codebase file area"
    - "Tiers are auto-computed from percentile distribution of all contributors"
    - "Heuristic identity matcher suggests GitHub/Slack links based on display name similarity"
  artifacts:
    - path: "src/contributor/expertise-scorer.ts"
      provides: "Score calculation from GitHub activity signals with exponential decay"
      exports: ["computeExpertiseScores", "updateExpertiseIncremental"]
    - path: "src/contributor/tier-calculator.ts"
      provides: "Percentile-based tier assignment using PERCENT_RANK"
      exports: ["recalculateTiers"]
    - path: "src/contributor/identity-matcher.ts"
      provides: "Heuristic name matching between GitHub and Slack identities"
      exports: ["findPotentialMatches"]
  key_links:
    - from: "src/contributor/expertise-scorer.ts"
      to: "src/contributor/profile-store.ts"
      via: "reads/writes expertise entries via ContributorProfileStore"
      pattern: "upsertExpertise|getExpertise"
    - from: "src/contributor/tier-calculator.ts"
      to: "src/contributor/profile-store.ts"
      via: "reads all scores and updates tiers"
      pattern: "getAllScores|updateTier"
---

<objective>
Build the expertise scoring engine, tier calculator, and identity matcher -- the intelligence layer that turns raw GitHub activity into structured expertise profiles.

Purpose: This is the core algorithm that drives adaptive review behavior (Plan 04).
Output: Expertise scorer with decay, tier calculator with percentiles, identity matcher with heuristics.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/98-contributor-profiles-identity-linking/98-CONTEXT.md
@.planning/phases/98-contributor-profiles-identity-linking/98-RESEARCH.md
@.planning/phases/98-contributor-profiles-identity-linking/98-01-SUMMARY.md

@src/contributor/types.ts (created in Plan 01)
@src/contributor/profile-store.ts (created in Plan 01)

<interfaces>
<!-- Key types from Plan 01 that this plan depends on -->

From src/contributor/types.ts (created in Plan 01):
```typescript
export type ContributorTier = "newcomer" | "developing" | "established" | "senior";
export type ExpertiseDimension = "language" | "file_area";

export interface ContributorProfileStore {
  getOrCreateByGithubUsername(username: string): Promise<ContributorProfile>;
  getExpertise(profileId: number): Promise<ContributorExpertise[]>;
  upsertExpertise(params: {
    profileId: number;
    dimension: ExpertiseDimension;
    topic: string;
    score: number;
    rawSignals: number;
    lastActive: Date;
  }): Promise<void>;
  updateTier(profileId: number, tier: ContributorTier, overallScore: number): Promise<void>;
  getAllScores(): Promise<{ profileId: number; overallScore: number }[]>;
}
```

Octokit usage pattern (from review handler):
```typescript
const octokit = await githubApp.getInstallationOctokit(installationId);
// Uses octokit.rest.repos.listCommits, octokit.rest.pulls.list, etc.
```

Slack client pattern (from src/slack/client.ts):
```typescript
// Raw fetch to Slack Web API, no SDK dependency
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement expertise scorer with decay and incremental update</name>
  <files>
    src/contributor/expertise-scorer.ts
    src/contributor/expertise-scorer.test.ts
  </files>
  <action>
    Create `src/contributor/expertise-scorer.ts`:

    **Constants:**
    ```typescript
    const DECAY_HALF_LIFE_DAYS = 180;
    const DECAY_LAMBDA = Math.LN2 / DECAY_HALF_LIFE_DAYS;

    const SIGNAL_WEIGHTS = {
      commit: 1,
      pr_review: 2,
      pr_authored: 3,
    } as const;
    ```

    **Type: ActivitySignal**
    ```typescript
    export type ActivitySignal = {
      type: "commit" | "pr_review" | "pr_authored";
      date: Date;
      languages: string[];     // e.g., ["typescript", "javascript"]
      fileAreas: string[];     // e.g., ["src/handlers/", "src/knowledge/"]
    };
    ```

    **Function: extractFileArea(filePath: string): string**
    - Extract two-level directory prefix: `src/handlers/review.ts` -> `src/handlers/`
    - If file is at root level (no directory): use `.` (root)
    - Normalize: always lowercase, always end with `/`

    **Function: computeDecayedScore(signals: ActivitySignal[]): number**
    - For each signal: `weight * e^(-lambda * daysSinceSignal)`
    - Sum all weighted values
    - Return raw (un-normalized) total

    **Function: normalizeScore(raw: number): number**
    - Sigmoid normalization: `1 / (1 + e^(-k * (raw - midpoint)))`
    - k = 0.05, midpoint = 50 (tunable)
    - Returns 0.0-1.0 bounded value

    **Function: computeExpertiseScores(params)**
    Exported. Accepts:
    - `githubUsername: string`
    - `octokit: Octokit` (for fetching commit/PR history)
    - `owner: string`, `repo: string`
    - `profileStore: ContributorProfileStore`
    - `logger: Logger`
    - `monthsBack?: number` (default 12)

    Implementation:
    1. `profileStore.getOrCreateByGithubUsername(githubUsername)` to get/create profile
    2. Fetch commits: `octokit.rest.repos.listCommits({ owner, repo, author: githubUsername, since: dateMonthsAgo, per_page: 100 })`. Paginate up to 5 pages max (500 commits). For each commit, extract files changed to determine languages (from file extensions using `classifyFileLanguage` from `src/lib/language-classifier.ts`) and file areas (using `extractFileArea`).
    3. Fetch authored PRs: `octokit.rest.pulls.list({ owner, repo, state: "closed", per_page: 100 })`. Filter by `pull.user.login === githubUsername` and `pull.merged_at !== null`. Paginate up to 3 pages. For each merged PR, use the PR's changed files to determine languages and areas.
    4. For review activity: query the existing `review_comments` table via the knowledge store's review comment search (or direct SQL query on the contributor_expertise side). Group by file areas and languages from the review comments. This avoids extra GitHub API calls since review comments are already backfilled.
    5. Build ActivitySignal[] from all three sources
    6. Group signals by (dimension, topic) — e.g., ("language", "typescript"), ("file_area", "src/handlers/")
    7. For each group: `computeDecayedScore` -> `normalizeScore` -> `upsertExpertise`
    8. Compute overall_score as average of top-5 expertise scores
    9. `profileStore.updateTier(profileId, currentTier, overallScore)` — tier will be recalculated in bulk by tier-calculator

    **Function: updateExpertiseIncremental(params)**
    Exported. Lightweight incremental update for use after PR review (fire-and-forget pattern).
    Accepts:
    - `githubUsername: string`
    - `filesChanged: string[]` — file paths from the PR diff
    - `type: "commit" | "pr_review" | "pr_authored"`
    - `profileStore: ContributorProfileStore`
    - `logger: Logger`

    Implementation:
    1. `profileStore.getOrCreateByGithubUsername(githubUsername)`
    2. Extract languages and file areas from filesChanged
    3. For each unique (dimension, topic): read existing expertise, add 1 signal of given type with today's date, recompute decayed score, upsert
    4. Update overall_score on profile

    **Important:** All GitHub API calls must be wrapped in try/catch with fail-open behavior. Rate limit errors logged but do not propagate. Use a simple delay between paginated requests (`await new Promise(r => setTimeout(r, 200))`).

    Create `src/contributor/expertise-scorer.test.ts`:
    - Test: `extractFileArea` correctly extracts two-level paths
    - Test: `extractFileArea` handles root-level files
    - Test: `computeDecayedScore` applies exponential decay correctly (signal from today vs 180 days ago should differ by ~2x)
    - Test: `normalizeScore` returns value between 0 and 1
    - Test: `normalizeScore(0)` returns value near 0.08 (sigmoid at x=0 with midpoint=50)
    - Test: `normalizeScore(100)` returns value near 0.99
    - Test: `updateExpertiseIncremental` calls upsertExpertise for each language and file area (mock profileStore)
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && bun test src/contributor/expertise-scorer.test.ts</automated>
  </verify>
  <done>Scorer computes decayed expertise from activity signals. Incremental updater works for fire-and-forget PR event hooks. Pure math functions tested independently. Integration function tests use mocked stores.</done>
</task>

<task type="auto">
  <name>Task 2: Implement tier calculator and identity matcher</name>
  <files>
    src/contributor/tier-calculator.ts
    src/contributor/tier-calculator.test.ts
    src/contributor/identity-matcher.ts
    src/contributor/identity-matcher.test.ts
  </files>
  <action>
    **Tier Calculator** (`src/contributor/tier-calculator.ts`):

    Export `recalculateTiers(params)`:
    - `profileStore: ContributorProfileStore`
    - `logger: Logger`

    Implementation:
    1. `profileStore.getAllScores()` — get all non-opted-out profiles with scores
    2. Sort by overallScore ascending
    3. For each profile, compute percentile rank: `rank / total` (0.0 to 1.0)
    4. Assign tier based on percentile:
       - score === 0: always `newcomer` (regardless of percentile — no data means newcomer)
       - percentile < 0.20: `newcomer`
       - percentile 0.20-0.50: `developing`
       - percentile 0.50-0.80: `established`
       - percentile >= 0.80: `senior`
    5. Only call `profileStore.updateTier()` for profiles whose tier actually changed
    6. Log summary: `{ totalProfiles, tiersChanged, breakdown: { newcomer: N, developing: N, established: N, senior: N } }`

    Create `src/contributor/tier-calculator.test.ts`:
    - Test: single contributor with score 0 gets `newcomer`
    - Test: 10 contributors with varying scores get correct percentile tiers (bottom 2 = newcomer, middle = developing/established, top 2 = senior)
    - Test: all contributors with score 0 all get `newcomer`
    - Test: only changed tiers trigger updateTier calls
    - Mock profileStore

    **Identity Matcher** (`src/contributor/identity-matcher.ts`):

    Export `findPotentialMatches(params)`:
    - `githubUsername: string`
    - `githubDisplayName: string | null` — from GitHub API user profile (may be null)
    - `slackMembers: { userId: string; displayName: string; realName: string }[]`
    - Returns: `{ slackUserId: string; displayName: string; confidence: "high" | "medium" }[]`

    Implementation:
    1. Normalize all names: lowercase, strip non-alphanumeric except hyphens
    2. For each Slack member, compare:
       - Exact match: normalized(githubUsername) === normalized(slackDisplayName or slackRealName) -> confidence: "high"
       - Levenshtein distance <= 2 (for names <= 8 chars) or <= 3 (for longer names) -> confidence: "medium"
       - If githubDisplayName provided: also compare against that
    3. Return matches sorted by confidence (high first), max 3 results
    4. Never return a match for bot users or the Kodiai bot itself

    Implement `levenshteinDistance(a: string, b: string): number` as a private helper. Standard dynamic programming algorithm. No external library needed.

    Create `src/contributor/identity-matcher.test.ts`:
    - Test: exact username match returns high confidence
    - Test: close match (1 char difference) returns medium confidence
    - Test: no match returns empty array
    - Test: GitHub display name match also works
    - Test: max 3 results returned
    - Test: levenshtein distance calculation (direct unit tests)

    Update `src/contributor/index.ts` barrel to re-export from these new modules.
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && bun test src/contributor/tier-calculator.test.ts src/contributor/identity-matcher.test.ts</automated>
  </verify>
  <done>Tier calculator assigns newcomer/developing/established/senior based on percentile. Identity matcher finds potential GitHub/Slack matches with confidence levels. All tests pass.</done>
</task>

</tasks>

<verification>
- All expertise-scorer tests pass (7+ tests)
- All tier-calculator tests pass (4+ tests)
- All identity-matcher tests pass (6+ tests)
- TypeScript compiles cleanly
- Exponential decay produces expected half-life behavior
- Percentile tiers handle edge cases (all zeros, single contributor)
</verification>

<success_criteria>
- Expertise scores incorporate commit, PR authored, and PR review signals with 180-day half-life decay
- Scores are two-dimensional (language + file_area) as required by PROF-03
- Tier boundaries are 20/50/80 percentile with zero-score override
- Identity matcher uses Levenshtein distance with configurable thresholds
- All pure functions are independently testable without database
</success_criteria>

<output>
After completion, create `.planning/phases/98-contributor-profiles-identity-linking/98-03-SUMMARY.md`
</output>
