---
phase: 45-author-experience-adaptation
plan: 02
type: execute
wave: 2
depends_on: ["45-01"]
files_modified:
  - src/knowledge/store.ts
  - src/knowledge/types.ts
  - src/handlers/review.ts
  - src/execution/review-prompt.ts
autonomous: true

must_haves:
  truths:
    - "Author classification is cached in SQLite with a 24-hour TTL"
    - "Cache miss for ambiguous associations triggers optional GitHub Search API PR count lookup"
    - "Search API failure returns null and classification proceeds without enrichment (fail-open)"
    - "Classification failure at any point defaults to regular tier (fail-open)"
    - "First-time contributor review prompts include educational tone directives"
    - "Core contributor review prompts include terse tone directives"
    - "Author tier appears in Review Details appendix for transparency"
    - "Stale author cache entries (>7 days) are purged alongside existing purgeOldRuns"
  artifacts:
    - path: "src/knowledge/store.ts"
      provides: "author_cache table, getAuthorCache, upsertAuthorCache, purgeStaleAuthorCache methods"
      contains: "CREATE TABLE IF NOT EXISTS author_cache"
    - path: "src/knowledge/types.ts"
      provides: "Author cache methods on KnowledgeStore type"
      contains: "getAuthorCache"
    - path: "src/handlers/review.ts"
      provides: "Author classification pipeline wired into review handler"
      contains: "authorTier"
    - path: "src/execution/review-prompt.ts"
      provides: "authorTier parameter wired into buildReviewPrompt"
      contains: "buildAuthorExperienceSection"
  key_links:
    - from: "src/handlers/review.ts"
      to: "src/knowledge/store.ts"
      via: "getAuthorCache/upsertAuthorCache for classification caching"
      pattern: "getAuthorCache|upsertAuthorCache"
    - from: "src/handlers/review.ts"
      to: "src/execution/review-prompt.ts"
      via: "authorTier passed to buildReviewPrompt"
      pattern: "authorTier.*classification"
    - from: "src/handlers/review.ts"
      to: "src/lib/author-classifier.ts"
      via: "classifyAuthor called with author_association and optional prCount"
      pattern: "classifyAuthor"
---

<objective>
Wire author classification into the review pipeline: SQLite cache table, handler integration with Search API enrichment, prompt injection, Review Details transparency, and fail-open error handling.

Purpose: Connect the tested classification logic (plan 01) to the live review flow so that PR reviews adapt tone based on author experience level, with aggressive caching to minimize API calls and consistent fail-open semantics.

Output: Fully integrated author experience adaptation visible in review output.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-author-experience-adaptation/45-RESEARCH.md
@.planning/phases/45-author-experience-adaptation/45-01-SUMMARY.md
@src/knowledge/store.ts
@src/knowledge/types.ts
@src/handlers/review.ts
@src/execution/review-prompt.ts
@src/lib/author-classifier.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add author_cache table and methods to knowledge store</name>
  <files>src/knowledge/store.ts, src/knowledge/types.ts</files>
  <action>
**In `src/knowledge/types.ts`:**

Add a `AuthorCacheEntry` type and three methods to the `KnowledgeStore` type:

```typescript
export type AuthorCacheEntry = {
  tier: string;
  authorAssociation: string;
  prCount: number | null;
  cachedAt: string;
};
```

Add to `KnowledgeStore` type (before `checkpoint()`):
```typescript
getAuthorCache(params: { repo: string; authorLogin: string }): AuthorCacheEntry | null;
upsertAuthorCache(params: { repo: string; authorLogin: string; tier: string; authorAssociation: string; prCount: number | null }): void;
purgeStaleAuthorCache(retentionDays?: number): number;
```

**In `src/knowledge/store.ts`:**

1. Add `CREATE TABLE IF NOT EXISTS author_cache` after the `run_state` table creation block (line ~285). Follow the schema from research Pattern 2:
   - Columns: id, repo, author_login, tier, author_association, pr_count (nullable), cached_at (default datetime('now'))
   - UNIQUE(repo, author_login)

2. Add an index: `CREATE INDEX IF NOT EXISTS idx_author_cache_lookup ON author_cache(repo, author_login)`

3. Add a type for the row: `type AuthorCacheRow = { tier: string; author_association: string; pr_count: number | null; cached_at: string; }`

4. Add prepared statements:
   - `getAuthorCacheStmt`: SELECT tier, author_association, pr_count, cached_at FROM author_cache WHERE repo = $repo AND author_login = $authorLogin AND cached_at >= datetime('now', '-24 hours')
   - `upsertAuthorCacheStmt`: INSERT ... ON CONFLICT(repo, author_login) DO UPDATE SET ... (see research Pattern 2)
   - `purgeStaleAuthorCacheStmt`: DELETE FROM author_cache WHERE cached_at < datetime('now', $modifier)

5. Implement the three methods on the returned store object:
   - `getAuthorCache`: Run select, return mapped entry or null
   - `upsertAuthorCache`: Run upsert with provided params
   - `purgeStaleAuthorCache(retentionDays = 7)`: Run delete, return changes count

6. Call `purgeStaleAuthorCache()` inside the existing `purgeOldRuns()` method at the end, so both purge operations happen together.
  </action>
  <verify>`bun test` -- full suite passes (no regressions). Grep for `author_cache` in store.ts confirms table creation and all three methods.</verify>
  <done>author_cache table created with 24-hour TTL reads, upsert writes, and 7-day stale purge. KnowledgeStore type includes all three new methods.</done>
</task>

<task type="auto">
  <name>Task 2: Wire classification into review handler with Search API enrichment and prompt injection</name>
  <files>src/handlers/review.ts, src/execution/review-prompt.ts</files>
  <action>
**In `src/execution/review-prompt.ts`:**

1. Add `authorTier?: "first-time" | "regular" | "core"` to the `buildReviewPrompt` context parameter type (after `largePRContext`).

2. After `lines.push("", buildToneGuidelinesSection());` (line ~1079), add:
```typescript
if (context.authorTier) {
  const authorExpSection = buildAuthorExperienceSection({
    tier: context.authorTier,
    authorLogin: context.prAuthor,
  });
  if (authorExpSection) lines.push("", authorExpSection);
}
```

**In `src/handlers/review.ts`:**

1. Add imports at top:
```typescript
import { classifyAuthor, type AuthorTier } from "../lib/author-classifier.ts";
import { buildAuthorExperienceSection } from "../execution/review-prompt.ts";
```

2. Create a helper function `resolveAuthorTier` inside the file (NOT exported, review-handler-local):

```typescript
async function resolveAuthorTier(params: {
  authorLogin: string;
  authorAssociation: string;
  repo: string;
  owner: string;
  repoSlug: string;
  octokit: Awaited<ReturnType<GitHubApp["getInstallationOctokit"]>>;
  knowledgeStore: KnowledgeStore;
  logger: Logger;
}): Promise<{ tier: AuthorTier; prCount: number | null; fromCache: boolean }> {
  const { authorLogin, authorAssociation, repo: repoName, owner, repoSlug, octokit, knowledgeStore, logger } = params;

  // Check cache first
  try {
    const cached = knowledgeStore.getAuthorCache({ repo: repoSlug, authorLogin });
    if (cached) {
      return { tier: cached.tier as AuthorTier, prCount: cached.prCount, fromCache: true };
    }
  } catch (err) {
    logger.warn({ err, authorLogin }, "Author cache read failed (fail-open)");
  }

  // Determine if Search API enrichment is needed
  const ambiguousAssociations = ["NONE", "MANNEQUIN", "COLLABORATOR", "CONTRIBUTOR"];
  let prCount: number | null = null;

  if (ambiguousAssociations.includes(authorAssociation)) {
    try {
      const { data } = await octokit.rest.search.issuesAndPullRequests({
        q: `repo:${owner}/${repoName} type:pr author:${authorLogin} is:merged`,
        per_page: 1,
      });
      prCount = data.total_count;
    } catch (err) {
      logger.warn({ err, authorLogin }, "Author PR count lookup failed (fail-open, proceeding without enrichment)");
    }
  }

  const tier = classifyAuthor({ authorAssociation, prCount });

  // Cache the result (fire-and-forget)
  try {
    knowledgeStore.upsertAuthorCache({
      repo: repoSlug,
      authorLogin,
      tier,
      authorAssociation,
      prCount,
    });
  } catch (err) {
    logger.warn({ err, authorLogin }, "Author cache write failed (non-fatal)");
  }

  return { tier, prCount, fromCache: false };
}
```

3. In the main review handler function, AFTER the `skipAuthors` check and BEFORE the workspace/prompt building section, add the classification call. Look for a suitable location after config is loaded and `pr` is available (around the profile selection area). Add:

```typescript
// Author experience classification (AUTH-01 through AUTH-07)
let authorClassification: { tier: AuthorTier; prCount: number | null; fromCache: boolean } = { tier: "regular", prCount: null, fromCache: false };
try {
  authorClassification = await resolveAuthorTier({
    authorLogin: pr.user.login,
    authorAssociation: (pr as any).author_association ?? "NONE",
    repo: apiRepo,
    owner: apiOwner,
    repoSlug: `${apiOwner}/${apiRepo}`,
    octokit,
    knowledgeStore: deps.knowledgeStore,
    logger,
  });
  logger.info(
    { ...baseLog, authorTier: authorClassification.tier, authorPrCount: authorClassification.prCount, fromCache: authorClassification.fromCache },
    "Author experience classification resolved",
  );
} catch (err) {
  logger.warn({ ...baseLog, err }, "Author classification failed (fail-open, using regular tier)");
}
```

Note: Cast `(pr as any).author_association` because the union type of PR event payloads may not expose it directly on the intersection type. The field IS present on the webhook payload -- the cast is safe. Alternatively, extract it from the raw payload before the PR destructuring if cleaner.

4. Pass `authorTier` to `buildReviewPrompt()`:
```typescript
authorTier: authorClassification.tier,
```
Add this to the existing `buildReviewPrompt({...})` call, after the `largePRContext` field.

5. Add author tier to `formatReviewDetailsSummary()`:
   - Add optional `authorTier?: string` to the params type
   - After the profile line in the sections array, add: `- Author: ${params.authorTier ?? "regular"} (${params.authorTier === "regular" ? "default" : "adapted tone"})`
   - Pass `authorTier: authorClassification.tier` in the call site

6. Write 2 regression tests at the bottom of the review handler test file (or inline if no separate test file -- check first). If no test file exists, add a small describe block to an existing integration test. The tests should verify:
   - Test that `resolveAuthorTier` with MEMBER returns core without API call (mock octokit, verify search not called)
   - Test that `resolveAuthorTier` with NONE triggers search API call and caches result

   If the handler tests are integration-level and hard to unit test, skip this sub-step and rely on the full `bun test` suite for regression coverage.
  </action>
  <verify>
- `bun test` -- full suite passes
- Grep `authorTier` in review-prompt.ts confirms it is in the buildReviewPrompt parameter type and used in prompt assembly
- Grep `resolveAuthorTier` in review.ts confirms the helper exists and is called
- Grep `author_cache` in store.ts and types.ts confirms table and methods
- Grep `Author:` in review.ts formatReviewDetailsSummary confirms Review Details transparency
  </verify>
  <done>Full review pipeline wires author classification: cache check -> optional Search API enrichment -> classifyAuthor -> prompt tone injection -> Review Details transparency. Fail-open at every error boundary. All tests pass.</done>
</task>

</tasks>

<verification>
- `bun test` -- full test suite passes with zero regressions
- First-time contributor (FIRST_TIMER) PR produces prompt with educational tone section
- Core contributor (MEMBER/OWNER) PR produces prompt with terse tone section
- Regular contributor PR produces no additional tone section (current behavior preserved)
- SQLite author_cache table exists with 24-hour TTL reads and 7-day purge
- Search API only called for ambiguous associations (NONE, MANNEQUIN, COLLABORATOR, CONTRIBUTOR) on cache miss
- All error paths default to { tier: "regular" } -- review never fails due to classification
- Review Details includes "Author: {tier}" line
</verification>

<success_criteria>
Author experience adaptation is fully integrated into the review pipeline. Classification caches in SQLite with 24-hour TTL. Search API enriches ambiguous associations on cache miss. Prompt includes tier-specific tone directives. Review Details shows author tier. All error paths fail-open to regular tier. Full test suite passes.
</success_criteria>

<output>
After completion, create `.planning/phases/45-author-experience-adaptation/45-02-SUMMARY.md`
</output>
