---
phase: 58-intelligence-layer
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/learning/adaptive-threshold.ts
  - src/learning/adaptive-threshold.test.ts
autonomous: true

must_haves:
  truths:
    - "computeAdaptiveThreshold uses max-gap detection when given 8+ distances"
    - "computeAdaptiveThreshold uses 75th-percentile fallback when given fewer than 8 distances"
    - "computeAdaptiveThreshold falls back to configured threshold when no candidates or gap too small"
    - "All computed thresholds are clamped to [0.15, 0.65] floor/ceiling bounds"
  artifacts:
    - path: "src/learning/adaptive-threshold.ts"
      provides: "Pure function for adaptive distance threshold computation"
      exports: ["computeAdaptiveThreshold", "AdaptiveThresholdResult", "ThresholdMethod", "AdaptiveThresholdConfig", "DEFAULT_ADAPTIVE_CONFIG"]
    - path: "src/learning/adaptive-threshold.test.ts"
      provides: "Edge case test coverage for adaptive threshold"
      min_lines: 80
  key_links:
    - from: "src/learning/adaptive-threshold.test.ts"
      to: "src/learning/adaptive-threshold.ts"
      via: "import computeAdaptiveThreshold"
      pattern: "import.*computeAdaptiveThreshold.*from.*adaptive-threshold"
---

<objective>
Create the adaptive distance threshold computation module using TDD.

Purpose: This pure function is the algorithmic core of Phase 58 -- it takes a sorted array of candidate distances and determines the optimal cutoff using max-gap detection (8+ candidates) or percentile fallback (fewer candidates). TDD is ideal because the function has well-defined inputs and outputs with many edge cases.

Output: `src/learning/adaptive-threshold.ts` with full test coverage in `src/learning/adaptive-threshold.test.ts`
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/58-intelligence-layer/58-RESEARCH.md
@src/learning/retrieval-rerank.ts
@src/learning/retrieval-recency.ts
</context>

<feature>
  <name>Adaptive Distance Threshold Computation</name>
  <files>src/learning/adaptive-threshold.ts, src/learning/adaptive-threshold.test.ts</files>
  <behavior>
    computeAdaptiveThreshold({ distances, configuredThreshold, config? }) -> AdaptiveThresholdResult

    Cases:
    - [] distances, configured=0.3 -> { threshold: 0.3, method: "configured", candidateCount: 0 }
    - [0.1, 0.2, 0.25] (3 items, below 8 min) -> { method: "percentile", threshold: clamped 75th percentile }
    - [0.1, 0.15, 0.18, 0.2, 0.22, 0.25, 0.28] (7 items) -> percentile fallback
    - [0.1, 0.12, 0.15, 0.18, 0.20, 0.22, 0.25, 0.50] (8 items, clear gap at 0.25->0.50) -> { method: "adaptive", threshold: 0.25, gapSize: 0.25 }
    - [0.28, 0.29, 0.30, 0.31] (all similar, max gap < 0.05) -> { method: "configured", threshold: configured value }
    - [0.05, 0.06] -> threshold clamped to floor 0.15
    - [0.70, 0.80, 0.90] -> threshold clamped to ceiling 0.65
    - Unsorted input -> function sorts internally, same result as sorted

    Types exported:
    - ThresholdMethod = "adaptive" | "percentile" | "configured"
    - AdaptiveThresholdResult = { threshold, method, candidateCount, gapSize?, gapIndex? }
    - AdaptiveThresholdConfig = { minCandidatesForGap, fallbackPercentile, minGapSize, floor, ceiling }
    - DEFAULT_ADAPTIVE_CONFIG = { minCandidatesForGap: 8, fallbackPercentile: 0.75, minGapSize: 0.05, floor: 0.15, ceiling: 0.65 }
  </behavior>
  <implementation>
    Follow the code example from 58-RESEARCH.md almost exactly. The algorithm:
    1. Empty distances -> return configured threshold with method "configured"
    2. Sort distances ascending (defensive copy)
    3. If length < minCandidatesForGap (8) -> percentile fallback: index = floor(length * 0.75), return sorted[index] clamped to [floor, ceiling]
    4. If length >= 8 -> max-gap detection: iterate consecutive pairs, find largest gap. If largest gap < minGapSize (0.05) -> return configured threshold. Otherwise return sorted[gapIndex - 1] clamped to [floor, ceiling]
    5. All returned thresholds clamped to [floor=0.15, ceiling=0.65]

    Use a private clamp(value, min, max) helper.

    Match the repo pattern: pure function module with named exports, same style as retrieval-rerank.ts and retrieval-recency.ts.
  </implementation>
</feature>

<verification>
- `bun test src/learning/adaptive-threshold.test.ts` passes all test cases
- Tests cover: empty array, 1 element, 7 elements (percentile), 8 elements (adaptive), clear gap, no gap (all similar), floor clamping, ceiling clamping, unsorted input
- No external dependencies added
</verification>

<success_criteria>
- computeAdaptiveThreshold returns correct method for each candidate count scenario
- Floor (0.15) and ceiling (0.65) bounds enforced in all paths
- Minimum gap size (0.05) correctly triggers configured fallback
- All tests pass with bun test
</success_criteria>

<output>
After completion, create `.planning/phases/58-intelligence-layer/58-01-SUMMARY.md`
</output>
