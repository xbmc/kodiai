---
phase: 58-intelligence-layer
plan: 02
type: execute
wave: 2
depends_on: ["58-01"]
files_modified:
  - src/learning/isolation.ts
  - src/handlers/review.ts
  - src/telemetry/types.ts
  - src/telemetry/store.ts
  - src/execution/config.ts
autonomous: true

must_haves:
  truths:
    - "When retrieval returns 8+ candidates, Kodiai applies max-gap detection to find the natural distance cutoff"
    - "When fewer than 8 candidates are returned, Kodiai falls back to percentile-based threshold"
    - "Adaptive thresholds are bounded by floor 0.15 and ceiling 0.65"
    - "Threshold selection method (adaptive/percentile/configured) is logged in retrieval telemetry"
  artifacts:
    - path: "src/learning/isolation.ts"
      provides: "Unfiltered candidate retrieval with increased internal topK"
      contains: "max(20"
    - path: "src/handlers/review.ts"
      provides: "Post-rerank adaptive threshold filtering and telemetry logging"
      contains: "computeAdaptiveThreshold"
    - path: "src/telemetry/types.ts"
      provides: "Extended RetrievalQualityRecord with thresholdMethod"
      contains: "thresholdMethod"
    - path: "src/telemetry/store.ts"
      provides: "Persists threshold_method column in retrieval_quality"
      contains: "threshold_method"
    - path: "src/execution/config.ts"
      provides: "Retrieval config with adaptive boolean knob"
      contains: "adaptive"
  key_links:
    - from: "src/handlers/review.ts"
      to: "src/learning/adaptive-threshold.ts"
      via: "import computeAdaptiveThreshold"
      pattern: "import.*computeAdaptiveThreshold.*from.*adaptive-threshold"
    - from: "src/handlers/review.ts"
      to: "src/telemetry/store.ts"
      via: "recordRetrievalQuality with thresholdMethod"
      pattern: "thresholdMethod.*adaptiveResult\\.method"
    - from: "src/learning/isolation.ts"
      to: "retrieveWithIsolation callers"
      via: "returns unfiltered candidates when adaptive enabled"
      pattern: "internalTopK|max\\(20"
---

<objective>
Wire the adaptive threshold into the retrieval pipeline and extend telemetry.

Purpose: This plan restructures the retrieval pipeline so adaptive thresholds are computed on post-rerank distances (after language reranking + recency weighting), replaces the pre-rerank distance filter in the isolation layer with an increased internal topK, and logs the threshold method in retrieval telemetry for observability.

Output: Complete end-to-end adaptive threshold pipeline with telemetry logging.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/58-intelligence-layer/58-RESEARCH.md
@.planning/phases/58-intelligence-layer/58-01-SUMMARY.md
@src/learning/isolation.ts
@src/handlers/review.ts
@src/telemetry/types.ts
@src/telemetry/store.ts
@src/execution/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Restructure isolation layer and extend config + telemetry</name>
  <files>src/learning/isolation.ts, src/execution/config.ts, src/telemetry/types.ts, src/telemetry/store.ts</files>
  <action>
    **isolation.ts changes:**
    - Add an optional `adaptive` boolean parameter to `retrieveWithIsolation` params (default: true). Keep `distanceThreshold` parameter for backward compatibility.
    - When `adaptive` is true: do NOT filter by `distanceThreshold`. Instead, compute `internalTopK = Math.max(20, topK * 4)` and use that as the topK passed to `memoryStore.retrieveMemories()` and `memoryStore.retrieveMemoriesForOwner()`. Return ALL candidates up to internalTopK without distance filtering. The final topK slice and adaptive threshold filtering will happen in the handler (review.ts).
    - When `adaptive` is false: keep the existing behavior (filter by `distanceThreshold` as before, use original topK). This preserves backward compatibility.
    - Update the `IsolationLayer` type to include the optional `adaptive` param.
    - Update the provenance log to include the internalTopK when adaptive is enabled.

    **config.ts changes:**
    - Add `adaptive: z.boolean().default(true)` to the `retrievalSchema` object (after `distanceThreshold`).
    - Update the `.default({...})` call to include `adaptive: true`.

    **telemetry/types.ts changes:**
    - Add `thresholdMethod?: string` to `RetrievalQualityRecord` (after `languageMatchRatio`). Doc comment: "How the distance threshold was selected: 'adaptive', 'percentile', or 'configured'".

    **telemetry/store.ts changes:**
    - After the `CREATE TABLE IF NOT EXISTS retrieval_quality` block, add an additive column migration:
      ```
      const rqTableInfo = db.prepare("PRAGMA table_info(retrieval_quality)").all() as { name: string }[];
      if (!rqTableInfo.some(c => c.name === "threshold_method")) {
        db.run("ALTER TABLE retrieval_quality ADD COLUMN threshold_method TEXT");
      }
      ```
    - Update the `insertRetrievalQualityStmt` prepared statement to include `threshold_method` in both the column list and VALUES clause.
    - Update the `recordRetrievalQuality` method to bind `$thresholdMethod: entry.thresholdMethod ?? null`.
  </action>
  <verify>
    - `bunx tsc --noEmit` passes (type check)
    - `bun test` passes (existing tests not broken)
    - Grep confirms: `adaptive` in config.ts retrievalSchema, `threshold_method` in store.ts, `thresholdMethod` in types.ts
  </verify>
  <done>
    - isolation.ts conditionally skips distance filtering when adaptive=true, uses internalTopK = max(20, topK*4)
    - isolation.ts preserves original behavior when adaptive=false
    - Config schema has `adaptive: boolean` with default true
    - RetrievalQualityRecord has thresholdMethod field
    - Telemetry store persists threshold_method column (additive migration)
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire adaptive threshold into review handler post-rerank pipeline</name>
  <files>src/handlers/review.ts</files>
  <action>
    In `src/handlers/review.ts`, modify the retrieval section (around lines 1695-1770):

    1. **Import:** Add `import { computeAdaptiveThreshold } from "../learning/adaptive-threshold.ts";` at the top with other learning imports.

    2. **Pass adaptive flag to isolation layer:** Update the `isolationLayer.retrieveWithIsolation()` call to include `adaptive: config.knowledge.retrieval.adaptive`.

    3. **Apply adaptive threshold post-rerank:** After the recency weighting step (after `const reranked = ...`), add the adaptive threshold computation and filtering:
       ```typescript
       // Adaptive distance threshold (RET-03): compute on post-rerank distances
       const distances = reranked.map(r => r.adjustedDistance);
       const adaptiveResult = computeAdaptiveThreshold({
         distances,
         configuredThreshold: config.knowledge.retrieval.distanceThreshold,
       });
       const thresholdFiltered = reranked.filter(
         r => r.adjustedDistance <= adaptiveResult.threshold,
       );
       const finalReranked = thresholdFiltered.slice(0, config.knowledge.retrieval.topK);
       ```

    4. **Update telemetry recording:** In the telemetry block, change:
       - `distanceThreshold: config.knowledge.retrieval.distanceThreshold` -> `distanceThreshold: adaptiveResult.threshold`
       - Add `thresholdMethod: adaptiveResult.method` to the `recordRetrievalQuality` call
       - Change `resultCount` references to use `finalReranked.length` (not `reranked.length`)

    5. **Update downstream usage:** Replace all references to `reranked` that appear AFTER the adaptive threshold block with `finalReranked`:
       - The `reranked.length > 0` check for building retrievalCtx -> `finalReranked.length > 0`
       - The `reranked.map(r => ...)` for building findings -> `finalReranked.map(r => ...)`

    6. **Update debug logging:** Add a debug log line after adaptive threshold computation:
       ```typescript
       logger.debug({
         ...baseLog,
         gate: "adaptive-threshold",
         method: adaptiveResult.method,
         threshold: adaptiveResult.threshold,
         candidateCount: adaptiveResult.candidateCount,
         gapSize: adaptiveResult.gapSize,
         preFilterCount: reranked.length,
         postFilterCount: finalReranked.length,
       }, "Adaptive threshold applied to retrieval results");
       ```

    IMPORTANT: Also add an optional `adaptiveThreshold` DI hook in the `createReviewHandler` deps, same pattern as `retrievalReranker` and `retrievalRecency`:
    ```typescript
    adaptiveThreshold?: { computeAdaptiveThreshold: typeof computeAdaptiveThreshold };
    ```
    Then use `const computeThreshold = adaptiveThreshold?.computeAdaptiveThreshold ?? computeAdaptiveThreshold;` and call `computeThreshold(...)` instead of the direct import. This enables deterministic unit tests (per Phase 57 decision on DI hooks).
  </action>
  <verify>
    - `bunx tsc --noEmit` passes
    - `bun test` passes (existing tests not broken -- DI hooks keep defaults matching production behavior)
    - Grep confirms: `computeAdaptiveThreshold` imported in review.ts, `adaptiveResult.method` used in telemetry call, `finalReranked` used for building retrievalCtx
  </verify>
  <done>
    - Adaptive threshold is computed on post-rerank distances in review handler
    - Results are filtered by adaptive threshold before building prompt context
    - Threshold method is logged in retrieval quality telemetry
    - Adaptive threshold is injectable via DI for testing
    - Existing tests pass without modification (DI defaults match production)
  </done>
</task>

</tasks>

<verification>
- `bunx tsc --noEmit` -- full type check passes
- `bun test` -- all existing tests pass
- `bun test src/learning/adaptive-threshold.test.ts` -- TDD tests from Plan 01 still pass
- Grep for `computeAdaptiveThreshold` in review.ts confirms wiring
- Grep for `threshold_method` in store.ts confirms telemetry column
- Grep for `adaptive.*z\.boolean` in config.ts confirms config knob
- The four success criteria from the roadmap are satisfied:
  1. 8+ candidates -> max-gap detection (via computeAdaptiveThreshold)
  2. <8 candidates -> percentile fallback (via computeAdaptiveThreshold)
  3. Floor 0.15, ceiling 0.65 (enforced in computeAdaptiveThreshold)
  4. Threshold method logged in telemetry (thresholdMethod field)
</verification>

<success_criteria>
- Retrieval pipeline applies adaptive threshold post-rerank, not pre-rerank
- Isolation layer returns more candidates (internalTopK) when adaptive enabled
- Config has `adaptive: true` default with opt-out via `adaptive: false`
- Telemetry records threshold_method for every retrieval quality event
- All existing tests pass without modification
</success_criteria>

<output>
After completion, create `.planning/phases/58-intelligence-layer/58-02-SUMMARY.md`
</output>
