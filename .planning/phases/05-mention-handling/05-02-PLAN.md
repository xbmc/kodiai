---
phase: 05-mention-handling
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/handlers/mention.ts
  - src/execution/config.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Typing @kodiai in an issue comment produces a contextual response as a reply"
    - "Typing @kodiai in a PR comment, PR review comment, or PR review body produces a contextual response"
    - "A tracking comment appears within seconds showing the job is in progress, and updates when the response is ready"
    - "The bot's response demonstrates awareness of conversation context (prior comments, PR diff if applicable)"
    - "Comments without @kodiai mention are ignored"
    - "Review bodies with null body are skipped"
    - "Mention handling respects mention.enabled config"
  artifacts:
    - path: "src/handlers/mention.ts"
      provides: "createMentionHandler factory registering for 3 webhook events"
      exports: ["createMentionHandler"]
      min_lines: 100
    - path: "src/execution/config.ts"
      provides: "mention.prompt config field for custom instructions"
      contains: "mention"
    - path: "src/index.ts"
      provides: "mention handler wiring"
      contains: "createMentionHandler"
  key_links:
    - from: "src/handlers/mention.ts"
      to: "src/webhook/router.ts"
      via: "eventRouter.register for 3 event keys"
      pattern: "eventRouter\\.register"
    - from: "src/handlers/mention.ts"
      to: "src/execution/executor.ts"
      via: "executor.execute(context) with prompt override"
      pattern: "executor\\.execute"
    - from: "src/handlers/mention.ts"
      to: "src/execution/mention-prompt.ts"
      via: "buildConversationContext + buildMentionPrompt"
      pattern: "buildConversationContext|buildMentionPrompt"
    - from: "src/handlers/mention.ts"
      to: "src/handlers/mention-types.ts"
      via: "normalizers + containsMention + stripMention"
      pattern: "normalize|containsMention|stripMention"
    - from: "src/index.ts"
      to: "src/handlers/mention.ts"
      via: "createMentionHandler(deps)"
      pattern: "createMentionHandler"
---

<objective>
Create the mention handler that dispatches across all four comment surfaces, posts tracking comments for progress, builds conversation context, and invokes Claude with a mention-specific prompt. Wire into the server entrypoint.

Purpose: This is the core Phase 5 deliverable. Following the handler factory pattern from Phase 4, a single handler covers issue comments, PR comments, PR review comments, and PR review bodies. The tracking comment provides immediate user feedback before the job queue processes the request.

Output: Working mention handler wired into the server, covering all MENTION-01 through MENTION-05 requirements.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-mention-handling/05-RESEARCH.md
@.planning/phases/05-mention-handling/05-01-SUMMARY.md
@src/handlers/review.ts
@src/handlers/mention-types.ts
@src/execution/mention-prompt.ts
@src/execution/mcp/comment-server.ts
@src/execution/mcp/index.ts
@src/execution/executor.ts
@src/execution/types.ts
@src/execution/config.ts
@src/webhook/types.ts
@src/jobs/types.ts
@src/auth/github-app.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mention handler</name>
  <files>src/handlers/mention.ts, src/execution/config.ts</files>
  <action>
**1. Extend repo config with mention.prompt:**

In `src/execution/config.ts`, add an optional `prompt` field to the `mention` object in the schema: `prompt: z.string().optional()`. Update the `.default()` value to include the new field. This mirrors `review.prompt` and lets users customize the mention prompt via `.kodiai.yml`.

**2. Create src/handlers/mention.ts:**

Follow the exact handler factory pattern from `src/handlers/review.ts`. Export `createMentionHandler(deps)` which takes the same deps shape: `{ eventRouter, jobQueue, workspaceManager, githubApp, executor, logger }`.

Register for three webhook events:
- `issue_comment.created` (covers issue comments AND PR comments)
- `pull_request_review_comment.created` (inline diff comments)
- `pull_request_review.submitted` (review body)

All three call the same `handleMention(event)` async function.

**handleMention(event) implementation:**

Step 1 -- Extract and normalize:
- Get `appSlug` from `githubApp.getAppSlug()`.
- Based on `event.name`, determine which normalizer to call:
  - `"issue_comment"` -> check `event.payload.action === "created"`, then `normalizeIssueComment(payload as IssueCommentCreatedEvent)`
  - `"pull_request_review_comment"` -> check `event.payload.action === "created"`, then `normalizeReviewComment(payload as PullRequestReviewCommentCreatedEvent)`
  - `"pull_request_review"` -> check `event.payload.action === "submitted"`, then `normalizeReviewBody(payload as PullRequestReviewSubmittedEvent)`
- If action doesn't match (e.g. "edited", "deleted"), return early.
- For review body: check `payload.review.body` is not null/undefined before normalizing. If null, return early (no mention possible).

Step 2 -- Check mention:
- Call `containsMention(mention.commentBody, appSlug)`. If false, return early (not all comments are mentions).

Step 3 -- Log and strip mention:
- Log info: `{ surface, owner, repo, issueNumber, prNumber, commentAuthor }` "Processing @kodiai mention"
- Call `stripMention(mention.commentBody, appSlug)` to get `userQuestion`.

Step 4 -- Post tracking comment BEFORE enqueue:
- Get octokit via `githubApp.getInstallationOctokit(event.installationId)`.
- Post tracking comment: `octokit.rest.issues.createComment({ owner, repo, issue_number: mention.issueNumber, body: trackingInitialBody })`.
- `trackingInitialBody` is: `"> **Kodiai** is thinking...\n\n_Working on your request. This comment will be updated with the response._"`
- Store `trackingComment.data.id` as `trackingCommentId`.
- Wrap in try/catch -- if posting tracking comment fails, log error and continue without tracking (still process the mention).

Step 5 -- Enqueue job:
```typescript
await jobQueue.enqueue(event.installationId, async () => {
  let workspace = undefined;
  try {
    // Determine clone params
    // For PR surfaces where we have head/base info already (review_comment, review_body):
    //   use mention.headRef, mention.baseRef, mention.headRepoOwner, mention.headRepoName
    // For issue_comment on a PR (mention.prNumber set but headRef undefined):
    //   fetch PR details first via octokit.rest.pulls.get()
    // For pure issue mentions (mention.prNumber undefined):
    //   clone default branch with depth 1

    const octokit = await githubApp.getInstallationOctokit(event.installationId);

    let cloneOwner = mention.owner;
    let cloneRepo = mention.repo;
    let cloneRef: string | undefined;
    let cloneDepth = 1;
    let prTitle: string | undefined;
    let prBody: string | undefined;
    let prAuthor: string | undefined;

    if (mention.prNumber !== undefined) {
      cloneDepth = 50; // PR mentions need diff context

      if (mention.headRef) {
        // Review comment or review body -- PR details in payload
        cloneRef = mention.headRef;
        if (mention.headRepoOwner && mention.headRepoName) {
          cloneOwner = mention.headRepoOwner;
          cloneRepo = mention.headRepoName;
        }
      } else {
        // issue_comment on PR -- must fetch PR details (Pitfall 2)
        const { data: pr } = await octokit.rest.pulls.get({
          owner: mention.owner,
          repo: mention.repo,
          pull_number: mention.prNumber,
        });
        cloneRef = pr.head.ref;
        if (pr.head.repo) {
          cloneOwner = pr.head.repo.owner.login;
          cloneRepo = pr.head.repo.name;
        }
        // Populate mention with fetched PR data for context builder
        mention.headRef = pr.head.ref;
        mention.baseRef = pr.base.ref;
        mention.headRepoOwner = pr.head.repo?.owner.login;
        mention.headRepoName = pr.head.repo?.name;
        prTitle = pr.title;
        prBody = pr.body ?? undefined;
        prAuthor = pr.user?.login;
      }
    }

    // Clone workspace
    workspace = await workspaceManager.create(event.installationId, {
      owner: cloneOwner,
      repo: cloneRepo,
      ref: cloneRef ?? "HEAD", // Default branch for issues
      depth: cloneDepth,
    });

    // Load repo config
    const config = await loadRepoConfig(workspace.dir);

    // Check mention.enabled
    if (!config.mention.enabled) {
      logger.info({ owner: mention.owner, repo: mention.repo }, "Mentions disabled in config, skipping");
      return;
    }

    // Build conversation context
    const conversationContext = await buildConversationContext(octokit, mention);

    // Build mention prompt
    const mentionPrompt = buildMentionPrompt({
      mention,
      conversationContext,
      userQuestion,
      customInstructions: config.mention.prompt,
    });

    // Execute via Claude
    const result = await executor.execute({
      workspace,
      installationId: event.installationId,
      owner: mention.owner,
      repo: mention.repo,
      prNumber: mention.prNumber,
      commentId: trackingCommentId, // So Claude can update via update_comment MCP tool
      eventType: `${event.name}.${event.payload.action as string}`,
      triggerBody: mention.commentBody,
      prompt: mentionPrompt,
    });

    logger.info(
      {
        surface: mention.surface,
        issueNumber: mention.issueNumber,
        conclusion: result.conclusion,
        costUsd: result.costUsd,
        numTurns: result.numTurns,
        durationMs: result.durationMs,
        sessionId: result.sessionId,
      },
      "Mention execution completed",
    );

    // If execution errored and we have a tracking comment, update it with error
    if (result.conclusion === "error" && trackingCommentId) {
      try {
        const errOctokit = await githubApp.getInstallationOctokit(event.installationId);
        await errOctokit.rest.issues.updateComment({
          owner: mention.owner,
          repo: mention.repo,
          comment_id: trackingCommentId,
          body: `> **Kodiai** encountered an error\n\n_${result.errorMessage ?? "An unexpected error occurred"}_\n\nPlease try again or check the logs.`,
        });
      } catch (updateErr) {
        logger.error({ err: updateErr }, "Failed to update tracking comment with error");
      }
    }
  } catch (err) {
    logger.error({ err, surface: mention.surface, issueNumber: mention.issueNumber }, "Mention handler failed");

    // Update tracking comment with error if possible
    if (trackingCommentId) {
      try {
        const errOctokit = await githubApp.getInstallationOctokit(event.installationId);
        await errOctokit.rest.issues.updateComment({
          owner: mention.owner,
          repo: mention.repo,
          comment_id: trackingCommentId,
          body: `> **Kodiai** encountered an error\n\n_Something went wrong while processing your request._\n\nPlease try again or check the logs.`,
        });
      } catch (updateErr) {
        logger.error({ err: updateErr }, "Failed to update tracking comment with error");
      }
    }
  } finally {
    if (workspace) {
      await workspace.cleanup();
    }
  }
});
```

Import everything needed: `MentionEvent`, normalizers, `containsMention`, `stripMention` from `../handlers/mention-types.ts`. `buildConversationContext`, `buildMentionPrompt` from `../execution/mention-prompt.ts`. `loadRepoConfig` from `../execution/config.ts`. Webhook types from `@octokit/webhooks-types`. Handler deps types from existing modules.

Note: The `cloneRef ?? "HEAD"` fallback for issues uses the default branch. The workspace manager's clone function will clone whatever ref is specified. For repos where "HEAD" doesn't work as a ref, we can use the repo's default_branch, but since workspace manager does `git clone --branch REF`, using "HEAD" may not work. Instead, for pure issue mentions (no prNumber), omit the `ref` from clone options or use `"main"`. ACTUALLY -- looking at the workspace manager's clone, it takes `ref: string` as required. For issue mentions, clone the repo without specifying a branch (just the default). The simplest approach: set `cloneRef` to the default branch. Since the issue_comment payload has `payload.repository.default_branch`, use that. For PR-based issue_comment, we already fetch the PR. So: for pure issue mentions, extract `defaultBranch` from `(event.payload as any).repository.default_branch` and use that as cloneRef.
  </action>
  <verify>
Run `bun build --no-bundle src/handlers/mention.ts` and `bun build --no-bundle src/execution/config.ts` -- both must compile without errors. Run `bun test src/execution/config.test.ts` -- existing config tests still pass.
  </verify>
  <done>
Mention handler registers for issue_comment.created, pull_request_review_comment.created, and pull_request_review.submitted. For each event: normalizes payload, checks for @kodiai mention, posts tracking comment immediately, enqueues job that clones repo, builds conversation context, runs executor with mention prompt, and updates tracking comment on error. Config schema includes mention.prompt for custom instructions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire mention handler into server</name>
  <files>src/index.ts</files>
  <action>
In `src/index.ts`:

1. Add import: `import { createMentionHandler } from "./handlers/mention.ts";`

2. After the `createReviewHandler({...})` call, add:
```typescript
createMentionHandler({
  eventRouter,
  jobQueue,
  workspaceManager,
  githubApp,
  executor,
  logger,
});
```

This follows the exact same wiring pattern as the review handler. The mention handler uses the same shared deps (same executor, same job queue, same workspace manager).
  </action>
  <verify>
Run `bun build --no-bundle src/index.ts` -- must compile without errors. Verify the import and handler registration are present.
  </verify>
  <done>
Server entrypoint creates and registers the mention handler alongside the review handler. Both share the same executor, job queue, workspace manager, and event router. The server is ready to receive mention-triggering webhook events.
  </done>
</task>

</tasks>

<verification>
- `bun build --no-bundle src/handlers/mention.ts` compiles
- `bun build --no-bundle src/execution/config.ts` compiles
- `bun build --no-bundle src/index.ts` compiles
- `bun test src/execution/config.test.ts` all tests pass (config changes are backward-compatible)
- mention handler registers for exactly 3 event keys
- tracking comment is posted BEFORE jobQueue.enqueue (immediate user feedback)
- error paths update the tracking comment with error message
- mention.enabled config check is inside the job (after clone, before execution)
- containsMention check is outside the job (fast, avoids unnecessary clones)
</verification>

<success_criteria>
- @kodiai mention in issue comment triggers handler: normalize -> check mention -> track -> clone -> context -> execute
- @kodiai mention in PR comment (issue_comment on PR) triggers same flow with PR details fetched
- @kodiai mention in PR review comment triggers with diff hunk context
- @kodiai mention in PR review body triggers (null body skipped)
- Tracking comment appears immediately (before job queue)
- Tracking comment updated with error on failure
- Comments without @kodiai are silently ignored
- mention.enabled=false in .kodiai.yml skips processing
- mention.prompt custom instructions passed to prompt builder
- Server wiring follows established pattern from Phase 4
</success_criteria>

<output>
After completion, create `.planning/phases/05-mention-handling/05-02-SUMMARY.md`
</output>
