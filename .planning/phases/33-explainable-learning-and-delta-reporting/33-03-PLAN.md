---
phase: 33-explainable-learning-and-delta-reporting
plan: 03
type: execute
wave: 2
depends_on: ["33-01", "33-02"]
files_modified:
  - src/handlers/review.ts
autonomous: true

must_haves:
  truths:
    - "Delta classification runs after finding extraction in incremental mode and produces delta-labeled findings"
    - "Delta classification is fail-open: errors degrade to no delta labels rather than blocking review publication"
    - "Provenance data from retrieval context is threaded into formatReviewDetailsSummary as provenanceSummary"
    - "Delta summary data from classifyFindingDeltas is threaded into formatReviewDetailsSummary as deltaSummary"
    - "Dedup-suppressed findings are counted as suppressedStillOpen in the delta summary"
    - "Full (non-incremental) reviews do not show delta summary"
  artifacts:
    - path: "src/handlers/review.ts"
      provides: "End-to-end wiring of delta classification and provenance into review output"
      contains: "classifyFindingDeltas"
  key_links:
    - from: "src/handlers/review.ts"
      to: "src/lib/delta-classifier.ts"
      via: "import classifyFindingDeltas"
      pattern: "import.*classifyFindingDeltas.*from.*delta-classifier"
    - from: "src/handlers/review.ts"
      to: "formatReviewDetailsSummary"
      via: "deltaSummary and provenanceSummary params"
      pattern: "deltaSummary:|provenanceSummary:"
---

<objective>
Wire delta classification and provenance threading into the review handler so that incremental reviews produce delta-labeled findings in Review Details and retrieval provenance is visible in the published output.

Purpose: Connects the delta classifier (33-01) and extended format functions (33-02) into the live review handler, completing the end-to-end data flow from finding extraction through delta classification to published Review Details with delta + provenance sections.

Output: Modified `src/handlers/review.ts` with delta classification call and provenance threading into `formatReviewDetailsSummary`.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-explainable-learning-and-delta-reporting/33-RESEARCH.md
@.planning/phases/33-explainable-learning-and-delta-reporting/33-01-SUMMARY.md
@.planning/phases/33-explainable-learning-and-delta-reporting/33-02-SUMMARY.md
@src/handlers/review.ts
@src/lib/delta-classifier.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire delta classification into review handler</name>
  <files>src/handlers/review.ts</files>
  <action>
In the `handleReview` function in `src/handlers/review.ts`, add delta classification after finding extraction and processing:

1. **Import** `classifyFindingDeltas` and `DeltaClassification` from `../lib/delta-classifier.ts` at the top of the file.

2. **After the `processedFindings` pipeline** (after the `const processedFindings: ProcessedFinding[] = ...` block, around the area where `visibleFindings`, `lowConfidenceFindings`, and `filteredInlineFindings` are computed), add delta classification:

   ```typescript
   // Delta classification (REV-03)
   // Only classify deltas in incremental mode when prior findings exist.
   let deltaClassification: DeltaClassification | null = null;
   if (incrementalResult?.mode === "incremental" && priorFindingCtx) {
     try {
       const priorFindings = knowledgeStore!.getPriorReviewFindings({
         repo: `${apiOwner}/${apiRepo}`,
         prNumber: pr.number,
       });
       if (priorFindings.length > 0) {
         deltaClassification = classifyFindingDeltas({
           currentFindings: processedFindings.map(f => ({
             filePath: f.filePath,
             title: f.title,
             severity: f.severity,
             category: f.category,
           })),
           priorFindings,
           fingerprintFn: fingerprintFindingTitle,
         });
       }
     } catch (err) {
       logger.warn(
         { ...baseLog, err },
         "Delta classification failed (fail-open, publishing without delta labels)",
       );
     }
   }
   ```

   Note: We already retrieved priorFindings earlier for dedup, but `getPriorReviewFindings` is a prepared statement and is fast. The prior dedup code consumed priorFindings for fingerprint building, but the variable was scoped inside the `if` block. Re-querying is the cleanest approach to avoid scoping issues.

3. **Count dedup-suppressed findings as `suppressedStillOpen`:**
   ```typescript
   const suppressedStillOpen = processedFindings.filter(f =>
     f.suppressed && priorFindingCtx?.suppressionFingerprints.has(
       `${f.filePath}:${fingerprintFindingTitle(f.title)}`
     )
   ).length;
   ```
   Place this right after the deltaClassification block. These are findings that were suppressed by dedup (they match a prior finding on unchanged code), so they are effectively `still-open` but not visible.

4. **Thread delta and provenance into `formatReviewDetailsSummary`** in the `shouldProcessReviewOutput` block:

   Pass the new optional parameters to `formatReviewDetailsSummary`:
   ```typescript
   deltaSummary: deltaClassification ? {
     counts: deltaClassification.counts,
     resolved: deltaClassification.resolved,
     suppressedStillOpen,
   } : undefined,
   provenanceSummary: retrievalCtx ? {
     findings: retrievalCtx.findings,
   } : undefined,
   ```

5. **Add delta counts to the review-details-output log entry** for operator visibility:
   ```typescript
   deltaNew: deltaClassification?.counts.new ?? null,
   deltaResolved: deltaClassification?.counts.resolved ?? null,
   deltaStillOpen: deltaClassification?.counts.stillOpen ?? null,
   provenanceCount: retrievalCtx?.findings.length ?? null,
   ```
  </action>
  <verify>
`bunx tsc --noEmit` -- no type errors.
`bun test` -- all existing tests pass.
  </verify>
  <done>
Review handler calls classifyFindingDeltas in incremental mode, threads delta and provenance data into formatReviewDetailsSummary, and logs delta counts. All paths are fail-open. Non-incremental reviews produce no delta section.
  </done>
</task>

</tasks>

<verification>
- `bun test` passes all tests
- `bunx tsc --noEmit` compiles without errors
- Delta classification import resolves correctly
- Delta classification only runs when incrementalResult.mode === "incremental" AND priorFindingCtx exists
- Fail-open: delta classification errors logged and skipped
- formatReviewDetailsSummary called with deltaSummary and provenanceSummary when available
- Non-incremental reviews produce unchanged Review Details (no delta section)
</verification>

<success_criteria>
- Incremental review summaries include delta status labels (new, resolved, still-open) [SC1]
- Retrieval provenance visible in Review Details when retrieval was used [SC2]
- Both delta and provenance in same published output [SC3]
- Fail-open: any delta/provenance error does not block review
- Backward compatible: full reviews produce standard Review Details
</success_criteria>

<output>
After completion, create `.planning/phases/33-explainable-learning-and-delta-reporting/33-03-SUMMARY.md`
</output>
