---
phase: 33-explainable-learning-and-delta-reporting
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/lib/delta-classifier.ts
  - src/lib/delta-classifier.test.ts
autonomous: true

must_haves:
  truths:
    - "classifyFindingDeltas correctly labels current findings as new or still-open based on prior fingerprint comparison"
    - "Prior findings not present in current findings are returned as resolved"
    - "Counts object accurately reflects new, resolved, and stillOpen tallies"
    - "Empty prior findings produce all-new classifications with zero resolved"
    - "Empty current findings with non-empty prior produce all-resolved classifications"
  artifacts:
    - path: "src/lib/delta-classifier.ts"
      provides: "DeltaStatus type, DeltaClassifiedFinding type, DeltaClassification type, classifyFindingDeltas function"
      exports: ["DeltaStatus", "DeltaClassifiedFinding", "DeltaClassification", "classifyFindingDeltas"]
    - path: "src/lib/delta-classifier.test.ts"
      provides: "Unit tests for delta classification"
      min_lines: 50
  key_links:
    - from: "src/lib/delta-classifier.ts"
      to: "src/knowledge/types.ts"
      via: "PriorFinding type import"
      pattern: "import.*PriorFinding.*from.*knowledge/types"
---

<objective>
Create a delta classification module that compares current review findings against prior review findings using filePath:titleFingerprint composite keys to label each finding as `new`, `still-open`, or `resolved`.

Purpose: Provides the classification engine that Phase 33-03 will call from the review handler to produce delta-labeled findings for the Review Details summary. This is a pure deterministic set-comparison function with well-defined I/O -- ideal for TDD.

Output: `src/lib/delta-classifier.ts` with exported types and `classifyFindingDeltas` function, plus comprehensive test coverage.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-explainable-learning-and-delta-reporting/33-RESEARCH.md
@src/knowledge/types.ts
@src/lib/finding-dedup.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create delta classifier module with TDD</name>
  <files>src/lib/delta-classifier.ts, src/lib/delta-classifier.test.ts</files>
  <action>
Create `src/lib/delta-classifier.ts` exporting:

1. **Types:**
   - `DeltaStatus = "new" | "resolved" | "still-open"`
   - `DeltaClassifiedFinding` -- extends the shape `{ filePath: string; title: string; severity: string; category: string; commentId: number; suppressed: boolean; confidence: number }` with `deltaStatus: DeltaStatus`. Use a generic intersection or simple inline type (do NOT import ProcessedFinding from review.ts to avoid circular dependency -- define a `FindingForDelta` input type with the minimal fields needed: `filePath`, `title`, plus any passthrough fields via a generic).
   - `DeltaClassification` -- `{ current: DeltaClassifiedFinding[]; resolved: Array<{ filePath: string; title: string; severity: string; category: string }>; counts: { new: number; resolved: number; stillOpen: number } }`

2. **Function `classifyFindingDeltas`:**
   - Accepts `{ currentFindings: FindingForDelta[]; priorFindings: PriorFinding[]; fingerprintFn: (title: string) => string }`.
   - Import `PriorFinding` from `../knowledge/types.ts`.
   - Build a Map of prior fingerprint keys (`filePath:titleFingerprint`) to PriorFinding.
   - For each current finding, compute `fingerprintFn(finding.title)` and build key `filePath:fp`. If key exists in prior map -> `still-open`, else -> `new`. Track matched prior keys in a Set.
   - After processing all current findings, iterate prior map. Any key NOT in matched set -> `resolved` (add to resolved array with filePath, title, severity, category).
   - Return `DeltaClassification` with classified current findings, resolved array, and counts.

**TDD approach (RED -> GREEN -> REFACTOR):**

**RED:** Write tests first in `src/lib/delta-classifier.test.ts`:
- Test: "labels all findings as new when no prior findings exist"
- Test: "labels matching finding as still-open when prior fingerprint matches"
- Test: "includes prior finding in resolved when not present in current"
- Test: "handles mixed scenario with new, still-open, and resolved findings"
- Test: "counts are accurate for mixed scenario"
- Test: "empty current findings with prior findings produces all resolved"
- Test: "uses fingerprintFn to compute fingerprints (not raw title comparison)"

Use a trivial fingerprintFn in tests: `(title) => title.toLowerCase().replace(/\s+/g, '-')` for predictability.

Run tests -- they should FAIL (module doesn't exist yet).

**GREEN:** Implement the module to make all tests pass.

**REFACTOR:** Clean up if needed, ensure types are exported.
  </action>
  <verify>
`bun test src/lib/delta-classifier.test.ts` -- all tests pass.
`bunx tsc --noEmit` -- no type errors.
  </verify>
  <done>
classifyFindingDeltas correctly classifies current findings as new/still-open and identifies resolved prior findings, with accurate counts. All tests green, types exported.
  </done>
</task>

</tasks>

<verification>
- `bun test src/lib/delta-classifier.test.ts` passes all tests
- `bunx tsc --noEmit` compiles without errors
- `classifyFindingDeltas` is exported and importable
- Types `DeltaStatus`, `DeltaClassifiedFinding`, `DeltaClassification` are exported
</verification>

<success_criteria>
- Delta classifier module exists with exported types and function
- All test cases pass covering new, still-open, resolved, mixed, and edge cases
- No circular imports (does not import from review.ts)
- Uses injected fingerprintFn for testability
</success_criteria>

<output>
After completion, create `.planning/phases/33-explainable-learning-and-delta-reporting/33-01-SUMMARY.md`
</output>
