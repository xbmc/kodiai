---
phase: 101-wire-executor-deps-cost-tracking
plan: 1
type: execute
wave: 1
depends_on: []
files_modified:
  - src/index.ts
  - src/knowledge/wiki-staleness-detector.ts
  - src/knowledge/wiki-staleness-detector.test.ts
autonomous: true
requirements: [LLM-02, LLM-03, LLM-05]

must_haves:
  truths:
    - "Agent SDK executor calls write cost rows to Postgres via costTracker"
    - ".kodiai.yml model routing is operative for agentic tasks via taskRouter"
    - "Wiki staleness LLM evaluations write cost rows (repo field no longer missing)"
  artifacts:
    - path: "src/index.ts"
      provides: "Executor wired with taskRouter and costTracker dependencies"
      contains: "createExecutor({ githubApp, logger, taskRouter, costTracker })"
    - path: "src/knowledge/wiki-staleness-detector.ts"
      provides: "generateWithFallback call includes repo field"
      contains: "repo:"
  key_links:
    - from: "src/index.ts"
      to: "src/execution/executor.ts"
      via: "createExecutor deps object"
      pattern: "createExecutor.*taskRouter.*costTracker"
    - from: "src/knowledge/wiki-staleness-detector.ts"
      to: "src/llm/generate.ts"
      via: "generateWithFallback opts.repo field"
      pattern: "repo:.*githubOwner.*githubRepo"
---

<objective>
Wire taskRouter and costTracker into createExecutor and fix the missing repo field in wiki-staleness-detector's generateWithFallback call.

Purpose: Closes GAP-1 (executor missing dependencies — agent SDK calls never write cost rows, .kodiai.yml model routing has no effect on agentic tasks) and GAP-2 (wiki staleness LLM calls silently skip cost tracking because repo is undefined).

Output: Both integration gaps closed; all LLM invocations — agentic and non-agentic — produce cost rows.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/index.ts
@src/execution/executor.ts
@src/llm/cost-tracker.ts
@src/llm/task-router.ts
@src/knowledge/wiki-staleness-detector.ts
@src/knowledge/wiki-staleness-types.ts
@src/llm/generate.ts

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/execution/executor.ts (line 12-17):
```typescript
export function createExecutor(deps: {
  githubApp: GitHubApp;
  logger: Logger;
  costTracker?: CostTracker;
  taskRouter?: { resolve(taskType: string): ResolvedModel };
})
```

From src/llm/cost-tracker.ts (line 64-67):
```typescript
export function createCostTracker(deps: {
  telemetryStore: TelemetryStore;
  logger: Logger;
}): CostTracker
```

From src/llm/task-router.ts (line ~export):
```typescript
export function createTaskRouter(config: { models: Record<string, string> }, logger: Logger): TaskRouter
```

From src/llm/generate.ts (line 36-46):
```typescript
export async function generateWithFallback(opts: {
  taskType: string;
  resolved: ResolvedModel;
  prompt: string;
  system?: string;
  tools?: Record<string, any>;
  costTracker?: CostTracker;
  repo?: string;                    // <-- GAP-2: this field is missing in wiki-staleness-detector
  deliveryId?: string;
  logger: Logger;
}): Promise<GenerateResult>
```

From src/knowledge/wiki-staleness-types.ts (line 71-91):
```typescript
export type WikiStalenessDetectorOptions = {
  sql: Sql;
  wikiPageStore: WikiPageStore;
  githubApp: GitHubApp;
  slackClient: SlackClient;
  taskRouter: TaskRouter;
  costTracker?: CostTracker;        // Already in type, but never passed from index.ts
  logger: Logger;
  githubOwner: string;              // Available — should form repo as `${githubOwner}/${githubRepo}`
  githubRepo: string;
  wikiChannelId: string;
  stalenessThresholdDays: number;
  intervalMs?: number;
  delayMs?: number;
};
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire taskRouter and costTracker into createExecutor in index.ts</name>
  <files>src/index.ts</files>
  <action>
In `src/index.ts`, make two changes:

1. **Add costTracker import and instantiation.** After the existing `createTaskRouter` import (line 28), add an import for `createCostTracker` from `"./llm/cost-tracker.ts"`. After the `telemetryStore` is created (~line 78), create a shared `costTracker`:
```typescript
import { createCostTracker } from "./llm/cost-tracker.ts";
// ...after telemetryStore creation:
const costTracker = createCostTracker({ telemetryStore, logger });
```

2. **Add a shared taskRouter for the executor.** Currently there are two separate `createTaskRouter({ models: {} }, logger)` calls for staleness and cluster schedulers (lines 483, 516). Create a single shared `taskRouter` instance near the executor (before line 245), and pass it plus `costTracker` to `createExecutor`:
```typescript
const taskRouter = createTaskRouter({ models: {} }, logger);
const executor = createExecutor({ githubApp, logger, taskRouter, costTracker });
```

3. **Pass costTracker to the wiki staleness detector.** At line 484-496, add `costTracker` to the `createWikiStalenessDetector` options:
```typescript
const wikiStalenessDetector = config.slackWikiChannelId
  ? createWikiStalenessDetector({
      sql,
      wikiPageStore,
      githubApp,
      slackClient,
      taskRouter: stalenessTaskRouter,
      costTracker,                       // <-- ADD THIS
      logger,
      // ... rest unchanged
    })
  : null;
```

**IMPORTANT:** Keep the separate `stalenessTaskRouter` and `clusterTaskRouter` instances for the scheduled background jobs. They use `{ models: {} }` (empty config) which means default model routing. The shared `taskRouter` for the executor will also start with `{ models: {} }` — the `.kodiai.yml` override is applied at a different level (per-repo config loaded inside the executor). The critical fix is that the executor now HAS a taskRouter to resolve model routing, and HAS a costTracker to write rows.
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && npx tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>
    - `createExecutor` call in index.ts includes `taskRouter` and `costTracker` deps
    - `createCostTracker` import added and instance created from `telemetryStore`
    - `costTracker` passed to wiki staleness detector options
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix missing repo field in wiki-staleness-detector generateWithFallback call</name>
  <files>src/knowledge/wiki-staleness-detector.ts, src/knowledge/wiki-staleness-detector.test.ts</files>
  <action>
In `src/knowledge/wiki-staleness-detector.ts`, function `evaluateWithLlm` (line ~274), the `generateWithFallback` call at line 302-308 passes `costTracker: opts.costTracker` but omits `repo`. The cost-tracking guard in `generate.ts` line 67 is `if (opts.costTracker && opts.repo)`, so cost rows are silently skipped.

Fix: Add `repo` field using the opts that are already available:
```typescript
const result = await generateWithFallback({
  taskType: TASK_TYPES.STALENESS_EVIDENCE,
  resolved,
  prompt,
  logger,
  costTracker: opts.costTracker,
  repo: `${opts.githubOwner}/${opts.githubRepo}`,   // <-- ADD THIS
});
```

The `opts` parameter is typed `WikiStalenessDetectorOptions` which has `githubOwner: string` and `githubRepo: string` — both are required fields always present.

Then verify the existing test file `wiki-staleness-detector.test.ts` still passes. If there is a test for the LLM evaluation path that mocks `generateWithFallback`, confirm the mock still matches the updated call signature (the `repo` field is optional in the type so existing mocks will not break).
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && bun test src/knowledge/wiki-staleness-detector.test.ts 2>&1 | tail -20</automated>
  </verify>
  <done>
    - `generateWithFallback` call in `evaluateWithLlm` includes `repo: \`${opts.githubOwner}/${opts.githubRepo}\``
    - Cost tracking guard (`opts.costTracker && opts.repo`) will now pass for wiki staleness LLM calls
    - Existing tests pass
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit` exits 0
2. Wiki staleness tests pass: `bun test src/knowledge/wiki-staleness-detector.test.ts`
3. Full test suite: `bun test` (no regressions)
4. Grep confirms wiring:
   - `grep -n "costTracker" src/index.ts` shows costTracker created and passed to executor + staleness detector
   - `grep -n "taskRouter" src/index.ts` shows taskRouter passed to executor
   - `grep -n "repo:" src/knowledge/wiki-staleness-detector.ts` shows repo field in generateWithFallback call
</verification>

<success_criteria>
- createExecutor receives both taskRouter and costTracker (GAP-1 closed)
- wiki-staleness-detector passes repo to generateWithFallback (GAP-2 closed)
- All existing tests pass with no regressions
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/101-wire-executor-dependencies/101-01-SUMMARY.md`
</output>
