---
phase: 41-feedback-driven-learning
plan: 03
type: execute
wave: 3
depends_on: ["41-01", "41-02"]
files_modified:
  - src/handlers/review.ts
  - src/handlers/review.test.ts
autonomous: true

must_haves:
  truths:
    - "When feedback.autoSuppress.enabled is true, findings matching suppressed fingerprints are marked suppressed in processedFindings"
    - "When feedback.autoSuppress.enabled is false (default), no feedback suppression logic runs and no store queries execute"
    - "CRITICAL findings are never feedback-suppressed even when their pattern fingerprint is in the suppression set"
    - "Confidence scores in processedFindings reflect feedback adjustment (+10 thumbs-up, -20 thumbs-down) when feedback data exists"
    - "Review Details includes feedback suppression count when patterns were auto-suppressed (e.g. '2 patterns auto-suppressed by feedback')"
    - "Feedback evaluation errors log a warning and proceed with zero suppressions (fail-open)"
  artifacts:
    - path: "src/handlers/review.ts"
      provides: "Feedback suppression wired between enforcement and config suppression matching, feedback-adjusted confidence, Review Details disclosure"
    - path: "src/handlers/review.test.ts"
      provides: "Integration tests for feedback suppression in review pipeline"
  key_links:
    - from: "src/handlers/review.ts"
      to: "src/feedback/index.ts"
      via: "import evaluateFeedbackSuppressions, adjustConfidenceForFeedback"
      pattern: "evaluateFeedbackSuppressions|adjustConfidenceForFeedback"
    - from: "src/handlers/review.ts"
      to: "src/knowledge/types.ts"
      via: "KnowledgeStore.aggregateFeedbackPatterns called via evaluateFeedbackSuppressions"
      pattern: "aggregateFeedbackPatterns"
---

<objective>
Integrate feedback-driven suppression and confidence adjustment into the review pipeline with transparent disclosure in Review Details.

Purpose: Connect the feedback evaluation logic from plan 02 into the live review handler so that consistently-rejected patterns are auto-suppressed, confidence reflects feedback history, and Review Details reports the suppression count.
Output: review.ts with feedback suppression in the post-enforcement pipeline, feedback-adjusted confidence scores, and Review Details disclosure line.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-feedback-driven-learning/41-RESEARCH.md
@.planning/phases/41-feedback-driven-learning/41-01-SUMMARY.md
@.planning/phases/41-feedback-driven-learning/41-02-SUMMARY.md

@src/handlers/review.ts (lines 1362-1520 for pipeline integration point)
@src/feedback/index.ts
@src/feedback/types.ts
@src/knowledge/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire feedback suppression into review pipeline with confidence adjustment</name>
  <files>src/handlers/review.ts</files>
  <action>
Import from the feedback module at the top of review.ts:
```typescript
import { evaluateFeedbackSuppressions, adjustConfidenceForFeedback } from "../feedback/index.ts";
```

**Insert feedback evaluation between enforcement and processedFindings mapping** (after line ~1397 enforcement logging, before line ~1405 abbreviatedFileSet):

```typescript
// Feedback-driven suppression (FEED-01 through FEED-10)
// Runs after enforcement, before config suppression matching.
// Early returns empty when feedback.autoSuppress.enabled is false (FEED-08).
// Fail-open: errors log warning and return empty suppression set.
const feedbackSuppression = knowledgeStore
  ? evaluateFeedbackSuppressions({
      store: knowledgeStore,
      repo: `${apiOwner}/${apiRepo}`,
      config: config.feedback.autoSuppress,
      logger,
    })
  : { suppressedFingerprints: new Set<string>(), suppressedPatternCount: 0, patterns: [] };

if (feedbackSuppression.suppressedPatternCount > 0) {
  logger.info(
    { ...baseLog, feedbackSuppressedPatterns: feedbackSuppression.suppressedPatternCount },
    "Feedback-driven suppression applied",
  );
}
```

**Modify the processedFindings mapping** (inside the `.map()` at ~line 1414) to include feedback suppression:

1. Compute the finding's title fingerprint: `const titleFp = fingerprintFindingTitle(finding.title);`
2. Check feedback suppression: `const feedbackSuppressed = feedbackSuppression.suppressedFingerprints.has(titleFp);`
3. Add feedbackSuppressed to the suppressed calculation: `const suppressed = finding.toolingSuppressed || Boolean(matchedSuppression) || dedupSuppressed || abbreviatedSuppressed || feedbackSuppressed;`
4. Look up the FeedbackPattern for this fingerprint to get thumbsUp/thumbsDown counts for confidence adjustment:
```typescript
const feedbackPattern = feedbackSuppression.patterns.find(p => p.fingerprint === titleFp);
const baseConfidence = computeConfidence({
  severity: finding.severity,
  category,
  matchesKnownPattern: Boolean(matchedSuppression),
});
const confidence = feedbackPattern
  ? adjustConfidenceForFeedback(baseConfidence, {
      thumbsUp: feedbackPattern.thumbsUpCount,
      thumbsDown: feedbackPattern.thumbsDownCount,
    })
  : baseConfidence;
```

Replace the existing `computeConfidence` call with this two-step computation.

**Modify formatReviewDetailsSummary** to accept and render feedback suppression count:

Add optional parameter to the function signature:
```typescript
feedbackSuppressionCount?: number;
```

After the existing largePRTriage section (before the closing `</details>`), add:
```typescript
if (feedbackSuppressionCount && feedbackSuppressionCount > 0) {
  sections.push(`- ${feedbackSuppressionCount} pattern${feedbackSuppressionCount === 1 ? '' : 's'} auto-suppressed by feedback`);
}
```

**Pass feedbackSuppression data** to the formatReviewDetailsSummary call (~line 1540):
```typescript
feedbackSuppressionCount: feedbackSuppression.suppressedPatternCount,
```

IMPORTANT: The feedback evaluation must be fail-open. evaluateFeedbackSuppressions already has internal try/catch, but the review handler should also guard the outer call. If knowledgeStore is undefined, skip feedback entirely (already handled by the ternary above).
  </action>
  <verify>
`bun run --bun tsc --noEmit` passes.
`bun test src/handlers/review.test.ts` passes (existing review tests still green).
  </verify>
  <done>
Feedback suppression integrated between enforcement and config suppression matching in review.ts.
Confidence scores reflect feedback adjustment when pattern data exists.
Review Details shows feedback suppression count when patterns were auto-suppressed.
Fail-open: feedback errors never block review publication.
Default behavior unchanged when feedback.autoSuppress.enabled is false.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add integration tests for feedback suppression in review pipeline</name>
  <files>src/handlers/review.test.ts</files>
  <action>
Add a new `describe("feedback-driven suppression")` block to the review handler tests (alongside the existing enforcement test blocks).

Tests to add:

1. **feedback suppression marks matching findings as suppressed** -- Mock knowledgeStore.aggregateFeedbackPatterns to return a pattern with fingerprint matching a finding title. Set config.feedback.autoSuppress.enabled = true with default thresholds. Verify the finding is marked suppressed in processedFindings.

2. **feedback suppression skipped when config.feedback.autoSuppress.enabled is false** -- Same setup but enabled=false. Verify no store query is made (aggregateFeedbackPatterns not called or early return), finding NOT suppressed.

3. **CRITICAL findings not feedback-suppressed** -- Set up a CRITICAL finding whose fingerprint matches a feedback pattern. Verify it is NOT marked as feedback-suppressed (safety guard protects it).

4. **feedback evaluation failure is fail-open** -- Mock aggregateFeedbackPatterns to throw an error. Verify review completes without feedback suppressions, warning is logged.

5. **Review Details includes feedback suppression count** -- Set up 2 suppressed patterns. Verify the Review Details comment body contains "2 patterns auto-suppressed by feedback".

Follow the existing test patterns in review.test.ts:
- Use existing mock factories for octokit, githubApp, config, etc.
- Mock the knowledgeStore with the additional aggregateFeedbackPatterns method
- Use the existing pattern of spying on API calls and verifying outputs

If the existing test infrastructure makes it difficult to test the full pipeline end-to-end, focus on verifiable aspects: that evaluateFeedbackSuppressions is called with the right params, and that the formatReviewDetailsSummary output includes the feedback line.
  </action>
  <verify>
`bun test src/handlers/review.test.ts` passes including new tests.
`bun test` all tests pass (existing 578+ plus new feedback tests).
  </verify>
  <done>
Integration tests verify: feedback suppression applied when enabled, skipped when disabled, CRITICAL/MAJOR safety protected, fail-open on errors, Review Details disclosure renders.
  </done>
</task>

</tasks>

<verification>
- `bun run --bun tsc --noEmit` compiles without errors
- `bun test` all tests pass (existing + new feedback integration tests)
- Review pipeline: enforcement -> feedback suppression -> config suppression -> dedup -> confidence
- Feedback suppression default off (opt-in via config.feedback.autoSuppress.enabled)
- Safety floors prevent CRITICAL and MAJOR security/correctness from feedback suppression
- Review Details line appears when feedback suppressions are active
- Fail-open: feedback evaluation errors don't block review publication
</verification>

<success_criteria>
End-to-end feedback-driven learning pipeline is operational. When enabled, consistently-rejected patterns are auto-suppressed with safety floors. Confidence scores reflect feedback history. Review Details transparently reports suppression counts. Default behavior (disabled) adds zero overhead.
</success_criteria>

<output>
After completion, create `.planning/phases/41-feedback-driven-learning/41-03-SUMMARY.md`
</output>
