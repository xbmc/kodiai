---
phase: 41-feedback-driven-learning
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/feedback/types.ts
  - src/knowledge/types.ts
  - src/knowledge/store.ts
  - src/execution/config.ts
autonomous: true

must_haves:
  truths:
    - "FeedbackPattern type exists with fingerprint, thumbsDownCount, thumbsUpCount, distinctReactors, distinctPRs, severity, category, sampleTitle fields"
    - "FeedbackSuppressionConfig type mirrors the .kodiai.yml feedback.autoSuppress schema shape"
    - "KnowledgeStore has aggregateFeedbackPatterns() method that returns FeedbackPattern[] grouped by title fingerprint"
    - "KnowledgeStore has clearFeedbackSuppressions() method that deletes feedback_reactions for a repo"
    - ".kodiai.yml accepts a feedback.autoSuppress section with enabled (default false) and thresholds (minThumbsDown=3, minDistinctReactors=3, minDistinctPRs=2)"
    - "Invalid feedback config falls back to defaults with a config warning, not a crash"
  artifacts:
    - path: "src/feedback/types.ts"
      provides: "FeedbackPattern, FeedbackThresholds, FeedbackSuppressionResult, FeedbackSuppressionConfig types"
    - path: "src/knowledge/types.ts"
      provides: "aggregateFeedbackPatterns and clearFeedbackSuppressions on KnowledgeStore interface"
    - path: "src/knowledge/store.ts"
      provides: "SQL aggregation query implementation for feedback_reactions grouped by title"
    - path: "src/execution/config.ts"
      provides: "feedbackSchema with autoSuppress.enabled and autoSuppress.thresholds, section-level fallback"
  key_links:
    - from: "src/feedback/types.ts"
      to: "src/knowledge/types.ts"
      via: "FeedbackPattern type used in aggregateFeedbackPatterns return type"
      pattern: "FeedbackPattern"
    - from: "src/execution/config.ts"
      to: "src/feedback/types.ts"
      via: "feedbackSchema shape matches FeedbackSuppressionConfig type"
      pattern: "feedback.*autoSuppress"
---

<objective>
Create the foundation types, config schema, and knowledge store query methods for feedback-driven learning.

Purpose: Establish the data contracts and storage layer that the aggregator, safety guard, and pipeline integration will build upon in subsequent plans.
Output: `src/feedback/types.ts` with all shared types, KnowledgeStore with aggregation + clear methods, and `.kodiai.yml` feedback config section.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-feedback-driven-learning/41-RESEARCH.md

@src/knowledge/types.ts
@src/knowledge/store.ts
@src/execution/config.ts
@src/handlers/review.ts (lines 79-94 for fingerprintFindingTitle)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create feedback types and KnowledgeStore aggregation methods</name>
  <files>src/feedback/types.ts, src/knowledge/types.ts, src/knowledge/store.ts</files>
  <action>
Create `src/feedback/types.ts` with the following types:

```typescript
export type FeedbackPattern = {
  fingerprint: string;       // FNV-1a hash of normalized title (same as fingerprintFindingTitle)
  thumbsDownCount: number;
  thumbsUpCount: number;
  distinctReactors: number;  // COUNT(DISTINCT reactor_login) for -1 reactions
  distinctPRs: number;       // COUNT(DISTINCT pr_number) for -1 reactions
  severity: FindingSeverity; // Most recent severity seen
  category: FindingCategory; // Most recent category seen
  sampleTitle: string;       // Representative title for logging/audit
};

export type FeedbackThresholds = {
  minThumbsDown: number;     // Default 3
  minDistinctReactors: number; // Default 3
  minDistinctPRs: number;   // Default 2
};

export type FeedbackSuppressionResult = {
  suppressedFingerprints: Set<string>;  // Fingerprints that crossed thresholds
  suppressedPatternCount: number;
  patterns: FeedbackPattern[];          // All patterns above threshold (for audit/logging)
};

export type FeedbackSuppressionConfig = {
  enabled: boolean;
  thresholds: FeedbackThresholds;
};
```

Import `FindingSeverity` and `FindingCategory` from `../knowledge/types.ts`.

Add to KnowledgeStore interface in `src/knowledge/types.ts`:
```typescript
aggregateFeedbackPatterns(repo: string): FeedbackPattern[];
clearFeedbackSuppressions(repo: string): number;
listFeedbackSuppressions(repo: string): FeedbackPattern[];
```

Import `FeedbackPattern` from `../feedback/types.ts` in `src/knowledge/types.ts`.

Implement in `src/knowledge/store.ts`:

**`aggregateFeedbackPatterns(repo)`**: SQL query against `feedback_reactions` table that:
1. Groups by `title` (the raw title text)
2. For each group, counts total -1 reactions, total +1 reactions, COUNT(DISTINCT reactor_login) for -1 only, COUNT(DISTINCT pr_number) for -1 only (requires JOIN to `reviews` table on `review_id = reviews.id` to get `pr_number`)
3. Returns severity and category from the most recent row (MAX(id))
4. Returns the title as sampleTitle
5. Computes fingerprint in the application layer using the same FNV-1a hash as `fingerprintFindingTitle()` in review.ts. Copy the FNV-1a logic into a local helper in store.ts (do NOT import from review.ts to avoid circular dependencies). Use the same normalization: trim, lowercase, replace non-alphanumeric with space, collapse whitespace, then FNV-1a with `fp-` prefix and 8-char hex.

The SQL query should look like:
```sql
SELECT
  fr.title,
  SUM(CASE WHEN fr.reaction_content = '-1' THEN 1 ELSE 0 END) AS thumbs_down_count,
  SUM(CASE WHEN fr.reaction_content = '+1' THEN 1 ELSE 0 END) AS thumbs_up_count,
  COUNT(DISTINCT CASE WHEN fr.reaction_content = '-1' THEN fr.reactor_login END) AS distinct_reactors,
  COUNT(DISTINCT CASE WHEN fr.reaction_content = '-1' THEN r.pr_number END) AS distinct_prs,
  (SELECT fr2.severity FROM feedback_reactions fr2 WHERE fr2.repo = $repo AND fr2.title = fr.title ORDER BY fr2.id DESC LIMIT 1) AS latest_severity,
  (SELECT fr2.category FROM feedback_reactions fr2 WHERE fr2.repo = $repo AND fr2.title = fr.title ORDER BY fr2.id DESC LIMIT 1) AS latest_category
FROM feedback_reactions fr
INNER JOIN reviews r ON r.id = fr.review_id
WHERE fr.repo = $repo
GROUP BY fr.title
HAVING SUM(CASE WHEN fr.reaction_content = '-1' THEN 1 ELSE 0 END) > 0
```

Map SQL results to `FeedbackPattern[]`, computing fingerprint from title in application code.

**`clearFeedbackSuppressions(repo)`**: Delete all feedback_reactions for the given repo. Return the count of deleted rows via `changes` property.

**`listFeedbackSuppressions(repo)`**: Same as `aggregateFeedbackPatterns` -- they return identical data. The distinction exists so the public API is clear (list for viewing, aggregate for evaluation). Implement as a direct call to `aggregateFeedbackPatterns`.

Add the `CREATE INDEX IF NOT EXISTS idx_feedback_reactions_repo_title ON feedback_reactions(repo, title)` index in the schema initialization section of store.ts (near the other feedback_reactions indexes at ~lines 240-244).
  </action>
  <verify>
`bun run --bun tsc --noEmit` passes with no type errors.
`bun test src/knowledge/store.test.ts` passes (existing tests still green).
  </verify>
  <done>
FeedbackPattern, FeedbackThresholds, FeedbackSuppressionResult, FeedbackSuppressionConfig types exported from src/feedback/types.ts.
KnowledgeStore interface has aggregateFeedbackPatterns, clearFeedbackSuppressions, listFeedbackSuppressions methods.
store.ts implements SQL aggregation query with proper JOIN, DISTINCT counting, and app-layer fingerprint computation.
New index on feedback_reactions(repo, title) created during schema init.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add feedback config schema with section-level fallback</name>
  <files>src/execution/config.ts</files>
  <action>
Add the `feedbackSchema` to `src/execution/config.ts` following the established pattern of existing schemas (see `largePRSchema`, `languageRulesSchema` for reference):

```typescript
const feedbackAutoSuppressThresholdsSchema = z
  .object({
    minThumbsDown: z.number().min(1).max(50).default(3),
    minDistinctReactors: z.number().min(1).max(50).default(3),
    minDistinctPRs: z.number().min(1).max(50).default(2),
  })
  .default({
    minThumbsDown: 3,
    minDistinctReactors: 3,
    minDistinctPRs: 2,
  });

const feedbackAutoSuppressSchema = z
  .object({
    enabled: z.boolean().default(false),
    thresholds: feedbackAutoSuppressThresholdsSchema,
  })
  .default({
    enabled: false,
    thresholds: {
      minThumbsDown: 3,
      minDistinctReactors: 3,
      minDistinctPRs: 2,
    },
  });

const feedbackSchema = z
  .object({
    autoSuppress: feedbackAutoSuppressSchema,
  })
  .default({
    autoSuppress: {
      enabled: false,
      thresholds: {
        minThumbsDown: 3,
        minDistinctReactors: 3,
        minDistinctPRs: 2,
      },
    },
  });
```

Add `feedback: feedbackSchema` to `repoConfigSchema`.

Add section-level fallback parsing for `feedback` in the Pass 2 block (after the `largePR` section, following the identical pattern):

```typescript
// feedback
const feedbackResult = feedbackSchema.safeParse(obj.feedback);
let feedback: z.infer<typeof feedbackSchema>;
if (feedbackResult.success) {
  feedback = feedbackResult.data;
} else {
  feedback = feedbackSchema.parse({});
  warnings.push({
    section: "feedback",
    issues: feedbackResult.error.issues.map(
      (i) => `${i.path.join(".")}: ${i.message}`,
    ),
  });
}
```

Add `feedback` to the assembled config object at the bottom of `loadRepoConfig`.

Ensure defaults: `feedback.autoSuppress.enabled = false` (opt-in per FEED-08), thresholds default to 3/3/2 per FEED-09.
  </action>
  <verify>
`bun run --bun tsc --noEmit` passes.
`bun test src/execution/config.test.ts` passes (existing config tests still green).
  </verify>
  <done>
`.kodiai.yml` accepts `feedback.autoSuppress.enabled` (boolean, default false) and `feedback.autoSuppress.thresholds` (minThumbsDown default 3, minDistinctReactors default 3, minDistinctPRs default 2).
Invalid feedback config falls back to defaults with a warning.
RepoConfig type includes `feedback` field.
  </done>
</task>

</tasks>

<verification>
- `bun run --bun tsc --noEmit` compiles without errors
- `bun test` all existing tests pass (578+)
- `src/feedback/types.ts` exports FeedbackPattern, FeedbackThresholds, FeedbackSuppressionResult, FeedbackSuppressionConfig
- `src/knowledge/types.ts` KnowledgeStore interface includes aggregateFeedbackPatterns, clearFeedbackSuppressions, listFeedbackSuppressions
- `src/knowledge/store.ts` implements aggregation SQL query with JOIN to reviews table
- `src/execution/config.ts` includes feedbackSchema with autoSuppress.enabled defaulting to false
- Config section-level fallback handles invalid feedback section gracefully
</verification>

<success_criteria>
All foundation types are defined. KnowledgeStore can aggregate feedback patterns from the existing feedback_reactions table. Config schema accepts and validates the feedback section. All existing tests pass unchanged.
</success_criteria>

<output>
After completion, create `.planning/phases/41-feedback-driven-learning/41-01-SUMMARY.md`
</output>
