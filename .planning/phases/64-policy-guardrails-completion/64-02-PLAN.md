---
phase: 64-policy-guardrails-completion
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/jobs/workspace.ts
  - src/jobs/workspace.test.ts
autonomous: true

must_haves:
  truths:
    - "enforceWritePolicy rejects denied paths with the first matching pattern and file path in the error metadata"
    - "enforceWritePolicy rejects paths outside allowPaths when allowPaths is non-empty"
    - "enforceWritePolicy passes all paths when allowPaths is empty (no restriction)"
    - "buildWritePolicyRefusalMessage produces a config snippet for allowPaths violations and safe remediation for secret violations"
  artifacts:
    - path: "src/jobs/workspace.test.ts"
      provides: "Unit tests for enforceWritePolicy and buildWritePolicyRefusalMessage"
      contains: "enforceWritePolicy|buildWritePolicyRefusalMessage"
  key_links:
    - from: "src/jobs/workspace.test.ts"
      to: "src/jobs/workspace.ts"
      via: "direct import of enforceWritePolicy"
      pattern: "import.*enforceWritePolicy.*workspace"
---

<objective>
Add unit-level tests for the write policy enforcement function and refusal message builder, proving guardrail behavior at the lowest testable layer independent of the full mention handler integration.

Purpose: Provide focused unit coverage that validates policy logic in isolation, complementing the integration-level tests from plan 01. Export `enforceWritePolicy` for direct testing.
Output: A new workspace.test.ts with unit tests covering denyPaths, allowPaths, secretScan enforcement, and refusal message formatting.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/jobs/workspace.ts
@src/handlers/mention.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Export enforceWritePolicy and buildWritePolicyRefusalMessage for unit testing</name>
  <files>src/jobs/workspace.ts, src/handlers/mention.ts</files>
  <action>
1. In `src/jobs/workspace.ts`, change `async function enforceWritePolicy` to `export async function enforceWritePolicy`. This function is already pure in its path-checking logic (denyPaths/allowPaths are synchronous; secretScan needs git diff which requires a real dir). Keep the export for path-policy testing; secretScan tests will use a real git fixture.

2. In `src/handlers/mention.ts`, find the private `buildWritePolicyRefusalMessage` function and export it. It is a pure function that takes a `WritePolicyError` and `allowPaths` array and returns a string. Exporting it enables direct unit testing of refusal message content.

Verify: `bunx tsc --noEmit` passes after both exports.
  </action>
  <verify>
`bunx tsc --noEmit` passes.
`bun test` passes (no behavioral change).
  </verify>
  <done>
`enforceWritePolicy` and `buildWritePolicyRefusalMessage` are exported and available for direct unit testing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for enforceWritePolicy path checks and buildWritePolicyRefusalMessage</name>
  <files>src/jobs/workspace.test.ts</files>
  <action>
Create `src/jobs/workspace.test.ts` with focused unit tests:

**enforceWritePolicy path-policy tests** (use a temp git repo fixture for the dir, but secretScan=false to isolate path logic):

1. "passes when no denyPaths or allowPaths configured" -- stagedPaths=["src/foo.ts"], empty deny/allow, secretScan=false -> no throw
2. "rejects path matching denyPaths" -- denyPaths=[".github/"], stagedPaths=[".github/workflows/ci.yml"] -> throws WritePolicyError with code "write-policy-denied-path", rule "denyPaths", path ".github/workflows/ci.yml"
3. "rejects path outside allowPaths" -- allowPaths=["src/"], stagedPaths=["README.md"] -> throws WritePolicyError with code "write-policy-not-allowed", rule "allowPaths", path "README.md"
4. "passes path inside allowPaths" -- allowPaths=["src/"], stagedPaths=["src/index.ts"] -> no throw
5. "denyPaths wins over allowPaths" -- allowPaths=["src/", ".github/"], denyPaths=[".github/"], stagedPaths=[".github/foo.yml"] -> throws denied-path (deny checked first)

For tests 1-5, create a minimal temp git dir with `git init`, stage a dummy file, then call `enforceWritePolicy` directly. The function needs `dir` for secretScan git diff only, so for path-only tests with secretScan=false, `dir` can be any valid directory.

**buildWritePolicyRefusalMessage tests:**

6. "formats denyPaths refusal with pattern" -- WritePolicyError("write-policy-denied-path", ..., {path: "README.md", rule: "denyPaths", pattern: "README.md"}) -> output contains "Write request refused", "Reason: write-policy-denied-path", "Rule: denyPaths", "File: README.md", "Matched pattern: README.md"
7. "formats allowPaths refusal with config snippet" -- WritePolicyError("write-policy-not-allowed", ..., {path: "README.md", rule: "allowPaths"}) with allowPaths=["src/"] -> output contains "Smallest config change", "allowPaths", "- 'README.md'", "Current allowPaths: 'src/'"
8. "formats secretScan refusal with safe remediation" -- WritePolicyError("write-policy-secret-detected", ..., {path: "config.ts", rule: "secretScan", detector: "regex:github-pat"}) -> output contains "Detector: regex:github-pat", "Remove/redact the secret", does NOT contain any actual secret value
9. "formats no-changes refusal" -- WritePolicyError("write-policy-no-changes", ...) -> output contains "No file changes"

Commit with message: `test(64-02): add unit tests for enforceWritePolicy and buildWritePolicyRefusalMessage`
  </action>
  <verify>
`bun test src/jobs/workspace.test.ts --timeout 30000` passes.
`bun test` full suite passes.
`bunx tsc --noEmit` passes.
  </verify>
  <done>
Unit-level coverage for write policy enforcement and refusal message formatting exists. Path-policy logic (deny/allow precedence, empty-allow passthrough) and message formatting (config snippets, safe remediation, no secret exposure) are tested in isolation from the mention handler.
  </done>
</task>

</tasks>

<verification>
- `bun test src/jobs/workspace.test.ts --timeout 30000` passes
- `bun test` full suite passes
- `bunx tsc --noEmit` passes
- Unit tests cover: denyPaths reject, allowPaths reject, allowPaths pass, deny-wins-over-allow, no-restriction pass
- Refusal message tests cover: all four error codes with correct content assertions
</verification>

<success_criteria>
Write policy enforcement logic is unit-tested at the function level, independent of the mention handler integration layer. Refusal messages are verified to contain actionable next steps without exposing sensitive data.
</success_criteria>

<output>
After completion, create `.planning/phases/64-policy-guardrails-completion/64-02-SUMMARY.md`
</output>
