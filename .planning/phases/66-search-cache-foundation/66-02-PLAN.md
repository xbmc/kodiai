---
phase: 66-search-cache-foundation
plan: 02
type: execute
wave: 2
depends_on: [66-01]
files_modified:
  - src/handlers/review.ts
  - src/handlers/review.test.ts
autonomous: true

must_haves:
  truths:
    - "Equivalent author-history Search API lookups in review enrichment reuse cached results within TTL"
    - "Concurrent review enrichments that request the same repo/query semantics trigger at most one remote Search API request"
    - "Search cache lookup/storage failures do not block review completion; handler continues with fail-open behavior"
  artifacts:
    - path: "src/handlers/review.ts"
      provides: "Search cache integration in author-tier enrichment path with safe fallback"
      contains: "createSearchCache|getOrLoad"
    - path: "src/handlers/review.test.ts"
      provides: "Regression coverage for cache hit, de-dupe concurrency, and fail-open fallback in review flow"
      contains: "issuesAndPullRequests"
  key_links:
    - from: "src/handlers/review.ts"
      to: "src/lib/search-cache.ts"
      via: "author PR-count lookup uses deterministic cache key + getOrLoad"
      pattern: "repo:.*type:pr.*author:"
    - from: "src/handlers/review.ts"
      to: "src/handlers/review.test.ts"
      via: "handler tests assert GitHub search call count under serial and concurrent events"
      pattern: "total_count|issuesAndPullRequests"
---

<objective>
Wire the Phase 66 cache primitive into review enrichment so Search API usage is reduced through deterministic reuse and concurrent request coalescing.

Purpose: Complete OPS-01 for real execution paths by applying cache controls where GitHub Search is currently called, while preserving non-blocking fail-open behavior.
Output: Review handler integration with cache-backed author PR-count lookup plus regression tests for cache hit, in-flight de-dupe, and cache-fault fallback.
</objective>

<execution_context>
@/home/keith/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/keith/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/66-search-cache-foundation/66-01-SUMMARY.md
@src/lib/search-cache.ts
@src/handlers/review.ts
@src/handlers/review.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate search cache into review author-tier enrichment</name>
  <files>src/handlers/review.ts</files>
  <action>
Update the author-tier enrichment path (`resolveAuthorTier`) to use the Phase 66 cache primitive for Search API lookups:

1) Build deterministic cache keys from repo + search semantics.
   - Scope key to `owner/repo` and `authorLogin` query semantics used by `issuesAndPullRequests`.
   - Keep query construction stable so equivalent calls map to one cache entry.

2) Wrap the existing `octokit.rest.search.issuesAndPullRequests` call with `getOrLoad`.
   - On cache hit, reuse `total_count` result.
   - On miss, execute the existing Search API call and store result with bounded TTL.

3) Preserve fail-open behavior.
   - If cache module throws or cannot serve/store, log warning and continue with direct Search API call path.
   - Keep existing behavior for Search API failures unchanged (warn and continue without enrichment).

4) Keep handler testability deterministic.
   - Add optional dependency injection for cache instance or cache factory in `createReviewHandler` deps, defaulting to production cache when omitted.
   - Avoid changing external handler contract behavior outside search-call reduction.
  </action>
  <verify>
Run `bun test src/handlers/review.test.ts --timeout 30000` after adding regressions.
  </verify>
  <done>
Review author-tier Search lookups now route through deterministic, repo-scoped cache + in-flight de-dupe while preserving non-blocking fallback behavior.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add review-handler regressions for cache hits and concurrent de-dupe</name>
  <files>src/handlers/review.test.ts</files>
  <action>
Add targeted tests proving handler-level OPS-01 behavior:

- **Cache hit regression:** trigger two equivalent review-enrichment paths for same repo/author and assert `issuesAndPullRequests` is called once while both executions complete.
- **Concurrent de-dupe regression:** run two equivalent review events concurrently (same repo/author) and assert only one in-flight Search API call is made.
- **Fail-open cache-fault regression:** inject cache read/write error and assert handler still completes using direct Search API path (no hard failure).

Use existing review fixture/builder patterns and minimal mocks so tests validate behavior, not implementation internals.
  </action>
  <verify>
Run `bun test src/handlers/review.test.ts --timeout 30000`.
Run `bun test src/lib/search-cache.test.ts --timeout 30000`.
Run `bunx tsc --noEmit`.
  </verify>
  <done>
Review handler regressions prove equivalent and concurrent search enrichments are de-duped and cache faults fail open without blocking review completion.
  </done>
</task>

</tasks>

<verification>
- `bun test src/handlers/review.test.ts --timeout 30000` passes with new cache integration regressions.
- `bun test src/lib/search-cache.test.ts --timeout 30000` remains passing.
- `bunx tsc --noEmit` passes.
- Equivalent and concurrent review enrichments reduce Search API call count without changing review completion behavior.
</verification>

<success_criteria>
OPS-01 is satisfied for current Search enrichment flow: deterministic repo-scoped caching and concurrent de-duplication reduce Search API load, and failures remain fail-open.
</success_criteria>

<output>
After completion, create `.planning/phases/66-search-cache-foundation/66-02-SUMMARY.md`
</output>
