---
phase: 66-search-cache-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/search-cache.ts
  - src/lib/search-cache.test.ts
autonomous: true

must_haves:
  truths:
    - "Equivalent Search API requests within a bounded window return cached results instead of reissuing remote calls"
    - "Cache keys are deterministic for repository + query semantics so equivalent requests map to one cache entry"
    - "Cache lookups and writes fail open: internal cache errors do not throw into caller flows"
  artifacts:
    - path: "src/lib/search-cache.ts"
      provides: "Repo-scoped deterministic search cache with TTL and in-flight de-duplication"
      exports: ["createSearchCache", "buildSearchCacheKey"]
    - path: "src/lib/search-cache.test.ts"
      provides: "Regression tests for key determinism, repo isolation, TTL expiry, and concurrent de-duplication"
      contains: "concurrent"
  key_links:
    - from: "src/lib/search-cache.ts"
      to: "src/lib/search-cache.test.ts"
      via: "unit tests assert identical semantic queries share key and in-flight promise"
      pattern: "buildSearchCacheKey|coalesc|in-flight"
---

<objective>
Create a deterministic, repository-scoped Search API cache primitive that supports bounded TTL and concurrent request de-duplication.

Purpose: Satisfy OPS-01 foundation requirements before handler integration by locking key semantics, fail-open behavior, and race-safe in-flight reuse in one reusable module.
Output: New `src/lib/search-cache.ts` module and focused unit tests proving key normalization, repo isolation, bounded TTL eviction, and in-flight request coalescing.
</objective>

<execution_context>
@/home/keith/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/keith/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/handlers/review.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build deterministic repo-scoped search cache module</name>
  <files>src/lib/search-cache.ts</files>
  <action>
Create a standalone cache utility for Search API usage with explicit deterministic keying and fail-open semantics:

1) Export `buildSearchCacheKey(params)` that includes repository scope and normalized query semantics.
   - Inputs: `repo`, `searchType`, `query`, `extra` (optional semantic fields).
   - Normalize query text (trim, lowercase, collapse whitespace) and sort semantic fields deterministically before hashing/serialization.
   - Ensure keys differ across repositories even when query text is identical.

2) Export `createSearchCache(options)` that returns methods for `get`, `set`, `getOrLoad`, and `purgeExpired`.
   - Use bounded TTL default (for example 10 minutes) with configurable override.
   - Keep cache in-memory and repository-scoped by key; do not introduce external dependencies.
   - Track in-flight loaders in a map so concurrent identical `getOrLoad` calls share one Promise.

3) Enforce fail-open behavior.
   - Any cache read/write/coalescing internal error must resolve by running the loader path (or returning miss) instead of throwing cache-originated errors.
   - Do not swallow loader errors from the upstream Search API call itself.

Keep the module pure and dependency-injected where needed (e.g., `now()` clock) so tests remain deterministic.
  </action>
  <verify>
Run `bun test src/lib/search-cache.test.ts --timeout 30000` once tests exist and confirm initial assertions execute against exported API.
  </verify>
  <done>
`src/lib/search-cache.ts` exposes deterministic key generation and TTL + in-flight cache operations that can be consumed by handler enrichment code without cross-repo leakage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add exhaustive cache behavior regressions</name>
  <files>src/lib/search-cache.test.ts</files>
  <action>
Add focused unit tests that lock OPS-01 contracts for the cache primitive:

- Deterministic keying: equivalent semantic queries (spacing/case variance) produce identical keys.
- Repo isolation: same query under different repos yields different keys.
- TTL boundaries: entries are returned before expiry and treated as misses after expiry.
- In-flight de-dupe: two concurrent `getOrLoad` calls for the same key execute the loader once and both callers receive the same result.
- Fail-open: if internal cache bookkeeping throws (injectable fault), cache bypasses and loader still returns successfully.

Use deterministic async tests (explicit deferred promises/counters) rather than timing races.
  </action>
  <verify>
Run `bun test src/lib/search-cache.test.ts --timeout 30000`.
Run `bunx tsc --noEmit`.
  </verify>
  <done>
All core search-cache contracts (determinism, repo scoping, bounded TTL, de-dupe, fail-open) are covered by passing regressions.
  </done>
</task>

</tasks>

<verification>
- `bun test src/lib/search-cache.test.ts --timeout 30000` passes.
- `bunx tsc --noEmit` passes.
- Module API is consumable from handlers without additional dependency installs.
</verification>

<success_criteria>
OPS-01 cache foundation exists as a reusable, deterministic primitive that prevents duplicate equivalent Search API calls in a bounded window and safely degrades on cache faults.
</success_criteria>

<output>
After completion, create `.planning/phases/66-search-cache-foundation/66-01-SUMMARY.md`
</output>
