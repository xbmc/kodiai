---
phase: 63-intent-gate-idempotency-foundations
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/handlers/mention.ts
  - src/handlers/mention.test.ts
autonomous: true

must_haves:
  truths:
    - "Non-prefixed implementation asks in issue comments produce a read-only reply with explicit @kodiai apply: and @kodiai change: opt-in commands instead of entering write mode"
    - "Explicit apply:/change: prefixed issue comments still enter write mode and create PRs normally"
    - "Non-prefixed informational questions in issue comments are unaffected and pass through to normal executor flow"
  artifacts:
    - path: "src/handlers/mention.ts"
      provides: "Implicit issue intent triggers opt-in guidance reply instead of write mode entry"
      contains: "implicitIntent"
    - path: "src/handlers/mention.test.ts"
      provides: "Regression tests for implicit intent opt-in guidance path"
      contains: "opt-in guidance"
  key_links:
    - from: "src/handlers/mention.ts"
      to: "postMentionReply"
      via: "implicitIntent detection triggers guidance reply before write mode entry"
      pattern: "implicitIntent.*guidance"
---

<objective>
Restore explicit opt-in safety for non-prefixed issue implementation asks.

Purpose: Phase 62 introduced implicit intent detection that auto-enters write mode for non-prefixed implementation asks (e.g., "fix the login bug"). This violates ISSUE-02 and SAFE-01 which require explicit `apply:`/`change:` prefixes for write mode. The fix changes the handler so implicit intent detection produces a read-only opt-in guidance reply (containing exact `@kodiai apply: <request>` and `@kodiai change: <request>` commands) instead of silently entering write mode.

Output: Handler code that gates implicit issue intents to guidance-only replies, with TDD regression coverage.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/handlers/mention.ts
@src/handlers/mention.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED - Add failing tests for implicit intent opt-in guidance</name>
  <files>src/handlers/mention.test.ts</files>
  <action>
Add two new test cases in the mention handler test file:

1. **"non-prefixed implementation ask in issue comment receives opt-in guidance instead of write mode"**
   - Create an `issue_comment.created` event with body `@kodiai fix the login bug` (no apply: prefix)
   - Configure `write.enabled: true` so write mode is technically available
   - Assert: executor is NOT called with `writeMode: true`
   - Assert: a reply comment is posted containing both `@kodiai apply: fix the login bug` and `@kodiai change: fix the login bug` as exact opt-in commands
   - Assert: no PR is created (pulls.create not called)

2. **"explicit apply: prefix in issue comment still enters write mode normally"**
   - Create an `issue_comment.created` event with body `@kodiai apply: fix the login bug`
   - Configure `write.enabled: true`
   - Assert: executor IS called with `writeMode: true`
   - This serves as a non-regression control to prove explicit prefixes still work

Use the existing test fixture patterns (createWorkspaceFixture, handlers Map, event objects) from the file.

Run `bun test src/handlers/mention.test.ts --timeout 30000` — expect the first test to FAIL (currently, non-prefixed implementation asks enter write mode).
  </action>
  <verify>Run `bun test src/handlers/mention.test.ts --timeout 30000` — first new test should fail, second should pass (or both may fail depending on assertion shape; the key is that the opt-in guidance assertion fails).</verify>
  <done>Failing test exists that asserts non-prefixed implementation asks produce opt-in guidance, not write mode entry.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN - Gate implicit intent to opt-in guidance reply</name>
  <files>src/handlers/mention.ts</files>
  <action>
In `createMentionHandler`, change the handling of `implicitIntent` so it NO LONGER sets `writeIntent: true`. Instead:

1. After `detectImplicitIssueIntent` returns a non-undefined value (meaning an implementation ask was detected without prefix), do NOT merge it into `writeIntent`. Keep `writeIntent` as-is from `parsedWriteIntent` (which will be `writeIntent: false`).

2. Instead, store the detected implicit intent and the normalized request. After the write-intent block, add a new code path: if `isIssueThreadComment && implicitIntent !== undefined && !parsedWriteIntent.writeIntent`, post an opt-in guidance reply and return early.

3. The opt-in guidance reply must contain:
   - A brief explanation: the request looks like a code change, which requires explicit opt-in
   - Two exact commands the user can copy: `@kodiai apply: <normalized request>` and `@kodiai change: <normalized request>`
   - Use the existing `summarizeWriteRequest` function to normalize the request text for the commands
   - Wrap the reply in `wrapInDetails` with "kodiai response" label for consistency
   - Post via `postMentionReply`

4. The code block around lines 554-565 should change from:
   ```
   const implicitIntent = isIssueThreadComment && !parsedWriteIntent.writeIntent
     ? detectImplicitIssueIntent(parsedWriteIntent.request)
     : undefined;
   const writeIntent = implicitIntent !== undefined
     ? { writeIntent: true, keyword: implicitIntent, request: parsedWriteIntent.request }
     : parsedWriteIntent;
   ```
   To:
   ```
   const implicitIntent = isIssueThreadComment && !parsedWriteIntent.writeIntent
     ? detectImplicitIssueIntent(parsedWriteIntent.request)
     : undefined;
   const writeIntent = parsedWriteIntent;  // Never auto-promote implicit intent
   ```

5. Add the guidance reply gate AFTER the `userQuestion.trim().length === 0` check and BEFORE the write-mode key/branch computation block. The gate:
   ```
   if (isIssueThreadComment && implicitIntent !== undefined && !parsedWriteIntent.writeIntent) {
     const normalized = summarizeWriteRequest(parsedWriteIntent.request);
     const guidanceBody = wrapInDetails(
       [
         "This looks like a code change request. To proceed, use an explicit command:",
         "",
         `\`@kodiai apply: ${normalized}\``,
         `\`@kodiai change: ${normalized}\``,
       ].join("\n"),
       "kodiai response",
     );
     await postMentionReply(guidanceBody);
     return;
   }
   ```

Run `bun test src/handlers/mention.test.ts --timeout 30000` — all tests should now pass.
Run `bun test` — full suite should pass.
Run `bunx tsc --noEmit` — typecheck should pass.
  </action>
  <verify>`bun test src/handlers/mention.test.ts --timeout 30000` passes all tests including the two new ones. `bun test` passes. `bunx tsc --noEmit` passes.</verify>
  <done>Non-prefixed implementation asks in issue comments produce read-only opt-in guidance instead of entering write mode. Explicit apply:/change: prefixes still enter write mode normally.</done>
</task>

</tasks>

<verification>
1. `bun test src/handlers/mention.test.ts --timeout 30000` — all tests pass
2. `bun test` — full suite passes
3. `bunx tsc --noEmit` — no type errors
4. Verify that the opt-in guidance contains both `@kodiai apply:` and `@kodiai change:` commands
5. Verify that `detectImplicitIssueIntent` still exists and is called, but its result gates to guidance instead of write mode
</verification>

<success_criteria>
- Non-prefixed implementation asks (e.g., "fix the login bug") in issue comments get a guidance reply, not write mode
- Explicit `apply:` / `change:` prefixed issue comments still enter write mode
- Informational questions pass through unchanged
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/63-intent-gate-idempotency-foundations/63-01-SUMMARY.md`
</output>
