---
phase: 30-state-memory-and-isolation-foundation
plan: 03
type: execute
wave: 2
depends_on: ["30-01", "30-02"]
files_modified:
  - src/index.ts
  - src/handlers/review.ts
  - src/learning/memory-store.test.ts
autonomous: true
user_setup:
  - service: voyageai
    why: "Embedding generation for learning memory"
    env_vars:
      - name: VOYAGE_API_KEY
        source: "https://dash.voyageai.com/api-keys -- create an API key (200M free tokens included)"

must_haves:
  truths:
    - "Learning memory writes happen asynchronously after review completion, not in the review critical path"
    - "sqlite-vec is loaded at startup with a health check logging the version"
    - "If sqlite-vec fails to load, server starts normally with learning memory disabled"
    - "Accepted and suppressed findings are written to learning_memories with embeddings after each review"
    - "Run state is purged on startup following retention policy"
    - "Retrieval for a repo cannot read memory from any other repo unless explicit sharing is enabled"
  artifacts:
    - path: "src/index.ts"
      provides: "Learning memory store initialization, embedding provider creation, startup health check"
      contains: "createLearningMemoryStore"
    - path: "src/handlers/review.ts"
      provides: "Post-review async memory write pipeline"
      contains: "writeMemory"
    - path: "src/learning/memory-store.test.ts"
      provides: "Tests for memory store write, retrieval, isolation, and stale management"
      contains: "learning_memory_vec"
  key_links:
    - from: "src/index.ts"
      to: "src/learning/memory-store.ts"
      via: "createLearningMemoryStore(db, logger) at startup"
      pattern: "createLearningMemoryStore"
    - from: "src/index.ts"
      to: "src/learning/embedding-provider.ts"
      via: "createEmbeddingProvider with VOYAGE_API_KEY"
      pattern: "createEmbeddingProvider"
    - from: "src/handlers/review.ts"
      to: "src/learning/memory-store.ts"
      via: "async memory write after review completion"
      pattern: "writeMemory"
    - from: "src/handlers/review.ts"
      to: "src/learning/embedding-provider.ts"
      via: "generate embedding for finding text before writeMemory"
      pattern: "generate"
---

<objective>
Wire the learning memory infrastructure into the application: startup initialization, post-review memory writes, and integration tests.

Purpose: Connect the run state (Plan 01), learning memory store, embedding provider, and isolation layer (Plan 02) into the live review flow. After this plan, accepted/suppressed findings are automatically embedded and stored in repo-scoped learning memory after each review. This completes the LEARN-06 and REL-03 integration.
Output: Updated index.ts with learning memory initialization, updated review handler with async memory writes, integration tests for memory store.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-state-memory-and-isolation-foundation/30-CONTEXT.md
@.planning/phases/30-state-memory-and-isolation-foundation/30-RESEARCH.md
@.planning/phases/30-state-memory-and-isolation-foundation/30-01-SUMMARY.md
@.planning/phases/30-state-memory-and-isolation-foundation/30-02-SUMMARY.md
@src/index.ts
@src/handlers/review.ts
@src/knowledge/store.ts
@src/learning/types.ts
@src/learning/embedding-provider.ts
@src/learning/memory-store.ts
@src/learning/isolation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire learning memory into startup and review handler</name>
  <files>src/index.ts, src/handlers/review.ts</files>
  <action>
**Startup wiring (src/index.ts):**

After the knowledge store initialization block (around line 57), add learning memory initialization:

```typescript
import { createLearningMemoryStore } from "./learning/memory-store.ts";
import { createEmbeddingProvider, createNoOpEmbeddingProvider } from "./learning/embedding-provider.ts";
```

1. Create the learning memory store using the same database instance approach -- the learning memory store needs access to the knowledge DB. Since `createKnowledgeStore` encapsulates its own Database, we need to either:
   - Pass the db path to createLearningMemoryStore and let it open its own connection (preferred for separation), OR
   - Expose the db from knowledge store.

   **Decision:** Give learning memory store its own Database connection to the same DB file. This is safe with WAL mode (supports concurrent readers). Create it after knowledgeStore:

```typescript
// Learning memory (v0.5 LEARN-06)
import { Database } from "bun:sqlite";

let learningMemoryStore: LearningMemoryStore | undefined;
let embeddingProvider: EmbeddingProvider | undefined;

try {
  const learningDb = new Database(knowledgeDb.dbPath, { create: true });
  learningDb.run("PRAGMA journal_mode = WAL");
  learningDb.run("PRAGMA synchronous = NORMAL");
  learningDb.run("PRAGMA busy_timeout = 5000");

  learningMemoryStore = createLearningMemoryStore({ db: learningDb, logger });
  logger.info("Learning memory store initialized");
} catch (err) {
  logger.warn({ err }, "Learning memory store failed to initialize (fail-open, learning disabled)");
}

const voyageApiKey = process.env.VOYAGE_API_KEY?.trim();
if (voyageApiKey && learningMemoryStore) {
  embeddingProvider = createEmbeddingProvider({
    apiKey: voyageApiKey,
    model: "voyage-code-3",
    dimensions: 1024,
    logger,
  });
  logger.info({ model: "voyage-code-3", dimensions: 1024 }, "Embedding provider initialized");
} else {
  embeddingProvider = createNoOpEmbeddingProvider(logger);
  if (!voyageApiKey) {
    logger.info("VOYAGE_API_KEY not set, embedding generation disabled (no-op provider)");
  }
}
```

2. Add startup purge for run state (after telemetry purge):
```typescript
// Startup maintenance: purge old run state entries
if (knowledgeStore) {
  try {
    const runsPurged = knowledgeStore.purgeOldRuns(30);
    if (runsPurged > 0) {
      logger.info({ runsPurged }, "Run state retention purge complete");
    }
  } catch (err) {
    logger.warn({ err }, "Run state purge failed (non-fatal)");
  }
}
```

3. Pass `learningMemoryStore` and `embeddingProvider` to `createReviewHandler`:
```typescript
createReviewHandler({
  eventRouter,
  jobQueue,
  workspaceManager,
  githubApp,
  executor,
  telemetryStore,
  knowledgeStore,
  learningMemoryStore,
  embeddingProvider,
  logger,
});
```

**Review handler wiring (src/handlers/review.ts):**

1. Update `createReviewHandler` deps type to accept optional `learningMemoryStore` and `embeddingProvider`:
```typescript
import type { LearningMemoryStore, EmbeddingProvider, LearningMemoryRecord } from "../learning/types.ts";

export function createReviewHandler(deps: {
  // ... existing deps
  learningMemoryStore?: LearningMemoryStore;
  embeddingProvider?: EmbeddingProvider;
}): void {
```

2. After the existing knowledge store block (the `if (knowledgeStore)` block that records review, findings, suppressions, global patterns -- around line 1384), add an async memory write:

```typescript
// Async learning memory write (LEARN-06)
// Write accepted and suppressed findings to learning memory with embeddings.
// This is async and fail-open -- errors do not affect the review outcome.
if (learningMemoryStore && embeddingProvider && processedFindings.length > 0) {
  // Fire and forget: don't await, don't block review completion
  Promise.resolve().then(async () => {
    const owner = apiOwner;
    const repo = `${apiOwner}/${apiRepo}`;
    let written = 0;
    let failed = 0;

    for (const finding of processedFindings) {
      try {
        // Determine outcome from finding state
        const outcome: string = finding.suppressed ? 'suppressed' : 'accepted';

        // Build embedding text: finding title + severity + category + file path for context
        const embeddingText = [
          `[${finding.severity}] [${finding.category}]`,
          finding.title,
          `File: ${finding.filePath}`,
        ].join('\n');

        const embeddingResult = await embeddingProvider.generate(embeddingText, 'document');
        if (!embeddingResult) {
          // Embedding failed (already logged by provider), skip this finding
          failed++;
          continue;
        }

        const memoryRecord: LearningMemoryRecord = {
          repo,
          owner,
          findingId: finding.commentId, // Use comment ID as finding reference
          reviewId: reviewId ?? 0,       // reviewId from knowledge store recordReview above
          sourceRepo: repo,
          findingText: finding.title,
          severity: finding.severity,
          category: finding.category,
          filePath: finding.filePath,
          outcome: outcome as any,
          embeddingModel: embeddingResult.model,
          embeddingDim: embeddingResult.dimensions,
          stale: false,
        };

        learningMemoryStore.writeMemory(memoryRecord, embeddingResult.embedding);
        written++;
      } catch (err) {
        failed++;
        logger.warn(
          { err, findingTitle: finding.title, filePath: finding.filePath },
          'Learning memory write failed for finding (fail-open)',
        );
      }
    }

    if (written > 0 || failed > 0) {
      logger.info(
        {
          ...baseLog,
          gate: 'learning-memory-write',
          written,
          failed,
          total: processedFindings.length,
        },
        'Learning memory write batch complete',
      );
    }
  }).catch((err) => {
    logger.warn(
      { ...baseLog, err },
      'Learning memory write pipeline failed (fail-open)',
    );
  });
}
```

**Important notes:**
- The `reviewId` variable is already in scope from the knowledge store block above (the `const reviewId = knowledgeStore.recordReview(...)` call). Make sure the memory write references it. If reviewId is scoped inside the `if (knowledgeStore)` block, hoist it: declare `let reviewId: number | undefined` before the knowledgeStore block and assign inside.
- The memory write is fire-and-forget (Promise.resolve().then). It does not delay review completion or the response to the webhook.
- Each finding gets its own embedding call. For large reviews this could hit rate limits, but with maxComments=7 default and 2 retries in the SDK, this is manageable. Batch embedding can be a future optimization.
  </action>
  <verify>Run `bun test` -- full test suite passes. Check that `src/index.ts` imports learning modules. Check that `src/handlers/review.ts` references learningMemoryStore and embeddingProvider.</verify>
  <done>Application startup initializes learning memory store with sqlite-vec health check, creates embedding provider from VOYAGE_API_KEY (or no-op if missing), purges old run state entries. Review handler writes findings to learning memory asynchronously after review completion. All fail-open: no learning failures block review publication.</done>
</task>

<task type="auto">
  <name>Task 2: Integration tests for learning memory store</name>
  <files>src/learning/memory-store.test.ts</files>
  <action>
Create `src/learning/memory-store.test.ts` with integration tests for the memory store.

Use the same test patterns as `src/knowledge/store.test.ts`: temp directory, file-based Database, cleanup in afterEach.

**Test setup:**
```typescript
import { describe, test, expect, beforeEach, afterEach } from "bun:test";
import { Database } from "bun:sqlite";
import { mkdtempSync, rmSync } from "node:fs";
import { join } from "node:path";
import { tmpdir } from "node:os";
import { createLearningMemoryStore } from "./memory-store.ts";
import type { LearningMemoryStore, LearningMemoryRecord } from "./types.ts";

const mockLogger = {
  info: () => {},
  warn: () => {},
  error: () => {},
  debug: () => {},
  trace: () => {},
  fatal: () => {},
  child: () => mockLogger,
  level: "silent",
} as unknown as import("pino").Logger;
```

**Tests:**

1. **"creates tables on initialization"** -- verify learning_memories and learning_memory_vec tables exist by querying sqlite_master.

2. **"writeMemory stores record and embedding"** -- write a memory record with a random Float32Array(1024), then getMemoryRecord by ID, verify fields match.

3. **"retrieveMemories returns similar vectors for same repo"** -- write two memories for repo "owner/repo-a" with known embeddings (e.g., normalized random vectors), query with one of them, verify it returns both sorted by distance.

4. **"retrieveMemories enforces repo isolation"** -- write memory for "owner/repo-a", query for "owner/repo-b" with same embedding, verify empty results. This is the critical isolation test.

5. **"writeMemory enforces UNIQUE constraint on (repo, finding_id, outcome)"** -- write same finding twice, second should be ignored or error handled gracefully (INSERT OR IGNORE or catch).

6. **"markStale marks old model embeddings"** -- write records with model "voyage-code-2", call markStale("voyage-code-3"), verify records are marked stale.

7. **"purgeStaleEmbeddings removes stale records from both tables"** -- mark stale, purge, verify records gone from learning_memories AND learning_memory_vec.

8. **"no-op store returned if sqlite-vec fails to load"** -- This is harder to test directly. Skip this test or use a comment noting it's tested implicitly by the fail-open try/catch in createLearningMemoryStore.

**Note on sqlite-vec in tests:** sqlite-vec must be loadable in the test environment. If it fails (e.g., macOS without custom SQLite), the store returns a no-op. Tests should detect this and skip with a descriptive message:

```typescript
let store: LearningMemoryStore;
let isNoOp = false;

beforeEach(() => {
  // ... create db
  store = createLearningMemoryStore({ db, logger: mockLogger });
  // Check if store is functional by trying to get a record
  // If sqlite-vec didn't load, retrieveMemories returns []
  // We can check by looking at vec_version
  try {
    db.prepare("SELECT vec_version()").get();
  } catch {
    isNoOp = true;
  }
});

// In each test:
test("writeMemory stores record and embedding", () => {
  if (isNoOp) {
    console.log("SKIP: sqlite-vec not available in test environment");
    return;
  }
  // ... actual test
});
```
  </action>
  <verify>Run `bun test src/learning/memory-store.test.ts` -- all tests pass (or skip gracefully if sqlite-vec unavailable). Run `bun test` -- full test suite green.</verify>
  <done>Learning memory store has integration tests covering write, retrieval, repo isolation, stale management, and unique constraint enforcement. Tests skip gracefully if sqlite-vec is not available in the test environment. Full test suite passes.</done>
</task>

</tasks>

<verification>
1. `bun test` -- full test suite green
2. `src/index.ts` initializes learning memory store and embedding provider at startup
3. `src/index.ts` purges old run state entries at startup
4. `src/handlers/review.ts` writes findings to learning memory async after review
5. Learning memory writes are fire-and-forget (non-blocking)
6. Memory store tests verify repo isolation (repo-a memories not visible to repo-b queries)
7. Application starts successfully without VOYAGE_API_KEY (no-op embedding provider)
8. Application starts successfully if sqlite-vec fails to load (no-op memory store)
</verification>

<success_criteria>
- Learning memory store initialized at startup with sqlite-vec health check
- Embedding provider created from VOYAGE_API_KEY or no-op if missing
- Old run state purged at startup (30-day retention)
- Review handler writes findings to learning memory async after completion
- Memory writes are fail-open and non-blocking
- Integration tests verify write, retrieval, isolation, stale management
- Full test suite passes
- Server starts cleanly with or without VOYAGE_API_KEY
</success_criteria>

<output>
After completion, create `.planning/phases/30-state-memory-and-isolation-foundation/30-03-SUMMARY.md`
</output>
