---
phase: 30-state-memory-and-isolation-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/knowledge/types.ts
  - src/knowledge/store.ts
  - src/knowledge/store.test.ts
  - src/handlers/review.ts
autonomous: true

must_haves:
  truths:
    - "Re-running the same webhook delivery for the same base/head SHA pair does not create duplicate published review state"
    - "Force-pushed PRs mark prior run state as superseded with audit trail"
    - "Run identity is keyed by SHA pair, not delivery ID, so GitHub retries are caught"
    - "Run state survives process restarts (durable SQLite, not in-memory Map)"
  artifacts:
    - path: "src/knowledge/types.ts"
      provides: "RunState and RunStateCheck types"
      contains: "RunStateCheck"
    - path: "src/knowledge/store.ts"
      provides: "run_state table creation, checkAndClaimRun, completeRun, purgeOldRuns methods"
      contains: "run_state"
    - path: "src/handlers/review.ts"
      provides: "Run state idempotency check at ingestion before expensive work"
      contains: "checkAndClaimRun"
  key_links:
    - from: "src/handlers/review.ts"
      to: "src/knowledge/store.ts"
      via: "knowledgeStore.checkAndClaimRun() call before workspace creation"
      pattern: "checkAndClaimRun"
    - from: "src/knowledge/store.ts"
      to: "run_state SQLite table"
      via: "UNIQUE constraint on run_key for idempotency"
      pattern: "run_key TEXT NOT NULL UNIQUE"
---

<objective>
Add durable SHA-keyed run state to the knowledge store and integrate it into the review handler for idempotent webhook processing.

Purpose: Replace the fragile in-memory delivery ID deduplicator (for review path) with a SQLite-backed run state table that survives restarts, handles force-push supersession, and prevents duplicate reviews for the same SHA pair. This satisfies REL-01.
Output: run_state table in knowledge DB, RunState types, checkAndClaimRun/completeRun/purgeOldRuns on KnowledgeStore, review handler integration.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-state-memory-and-isolation-foundation/30-CONTEXT.md
@.planning/phases/30-state-memory-and-isolation-foundation/30-RESEARCH.md
@src/knowledge/store.ts
@src/knowledge/types.ts
@src/knowledge/store.test.ts
@src/handlers/review.ts
@src/handlers/review-idempotency.ts
@src/webhook/dedup.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add run_state table and RunState API to KnowledgeStore</name>
  <files>src/knowledge/types.ts, src/knowledge/store.ts, src/knowledge/store.test.ts</files>
  <action>
**Types (src/knowledge/types.ts):**
Add these types:

```typescript
export type RunStatus = 'pending' | 'running' | 'completed' | 'superseded';

export type RunStateCheck = {
  shouldProcess: boolean;
  runKey: string;
  reason: 'new' | 'duplicate' | 'superseded-prior';
  supersededRunKeys: string[];
};

export type RunStateRecord = {
  id: number;
  runKey: string;
  repo: string;
  prNumber: number;
  baseSha: string;
  headSha: string;
  deliveryId: string;
  action: string;
  status: RunStatus;
  createdAt: string;
  completedAt: string | null;
  supersededBy: string | null;
};
```

Add to `KnowledgeStore` interface:
- `checkAndClaimRun(params: { repo: string; prNumber: number; baseSha: string; headSha: string; deliveryId: string; action: string }): RunStateCheck`
- `completeRun(runKey: string): void`
- `purgeOldRuns(retentionDays: number): number`

**Schema (src/knowledge/store.ts):**
Add the `run_state` table creation after the existing `feedback_reactions` table creation, using the schema from research:

```sql
CREATE TABLE IF NOT EXISTS run_state (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  run_key TEXT NOT NULL UNIQUE,
  repo TEXT NOT NULL,
  pr_number INTEGER NOT NULL,
  base_sha TEXT NOT NULL,
  head_sha TEXT NOT NULL,
  delivery_id TEXT NOT NULL,
  action TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending',
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  completed_at TEXT,
  superseded_by TEXT
);
CREATE INDEX IF NOT EXISTS idx_run_state_repo_pr ON run_state(repo, pr_number);
CREATE INDEX IF NOT EXISTS idx_run_state_status ON run_state(status);
```

Run key format: `{repo}:pr-{prNumber}:base-{baseSha}:head-{headSha}`

**Implementation:**
- `checkAndClaimRun`: Compose run_key from params. Check if exact run_key exists (return duplicate). If new, find all non-superseded runs for same repo+pr_number, mark them superseded (set superseded_by = new run_key), insert new run as 'pending'. All in a transaction. Return `{ shouldProcess: true, runKey, reason, supersededRunKeys }`.
- `completeRun`: Update status to 'completed' and set completed_at to now for the given run_key.
- `purgeOldRuns`: Delete rows where status IN ('completed', 'superseded') AND created_at < datetime('now', '-N days'). Return count deleted. Default 30 days for completed, 7 days for superseded.

Use prepared statements following existing patterns in store.ts (see recordReviewStmt, etc.).

**Tests (src/knowledge/store.test.ts):**
Add a `describe("run state")` block with tests:
1. `checkAndClaimRun returns new for first run` - verify shouldProcess=true, reason='new'
2. `checkAndClaimRun returns duplicate for same SHA pair` - run twice with same params, second returns shouldProcess=false, reason='duplicate'
3. `force push supersedes prior runs` - run with SHA-A, then run with SHA-B for same PR, verify first is superseded
4. `completeRun marks run as completed` - claim then complete, verify status
5. `purgeOldRuns removes old completed runs` - create runs, verify purge respects retention
6. `different delivery IDs for same SHA pair are still duplicates` - verify delivery ID is stored but not part of identity
  </action>
  <verify>Run `bun test src/knowledge/store.test.ts` -- all existing tests plus new run state tests pass.</verify>
  <done>run_state table is created on KnowledgeStore initialization. checkAndClaimRun correctly deduplicates by SHA pair, supersedes prior runs on force-push, and stores delivery_id for correlation. completeRun and purgeOldRuns work as specified. All tests green.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate run state idempotency into review handler</name>
  <files>src/handlers/review.ts</files>
  <action>
In `createReviewHandler`, the `handleReview` function currently checks idempotency via `ensureReviewOutputNotPublished` (GitHub API marker scan) AFTER workspace creation and config loading. This is expensive.

Add an early run state check BEFORE workspace creation, right after the draft PR skip and review_requested reviewer checks (around line 789, before `jobQueue.enqueue`). Actually, the check must be inside the job callback (since we need serialized access), so place it as the FIRST thing inside the `jobQueue.enqueue` callback, before `workspaceManager.create`.

**Changes to `handleReview` inner callback:**

1. Before `workspace = await workspaceManager.create(...)`, add:
```typescript
// Durable run state idempotency check (REL-01)
// Check before expensive workspace creation. Uses SHA pair as identity key.
if (knowledgeStore) {
  const runCheck = knowledgeStore.checkAndClaimRun({
    repo: `${apiOwner}/${apiRepo}`,
    prNumber: pr.number,
    baseSha: pr.base.sha,
    headSha: pr.head.sha,
    deliveryId: event.id,
    action,
  });

  if (!runCheck.shouldProcess) {
    logger.info(
      {
        ...baseLog,
        gate: 'run-state-idempotency',
        gateResult: 'skipped',
        skipReason: runCheck.reason,
        runKey: runCheck.runKey,
      },
      'Skipping review: run state indicates duplicate or already processed',
    );
    return;
  }

  if (runCheck.supersededRunKeys.length > 0) {
    logger.info(
      {
        ...baseLog,
        gate: 'run-state-idempotency',
        gateResult: 'accepted',
        runKey: runCheck.runKey,
        supersededRunKeys: runCheck.supersededRunKeys,
      },
      'New run superseded prior runs (force-push detected)',
    );
  }
}
```

2. After the review execution completes successfully (after the knowledge store block that records review + findings, around line 1384), add a `completeRun` call:
```typescript
// Mark run as completed for idempotency tracking
if (knowledgeStore) {
  try {
    const runKey = `${apiOwner}/${apiRepo}:pr-${pr.number}:base-${pr.base.sha}:head-${pr.head.sha}`;
    knowledgeStore.completeRun(runKey);
  } catch (err) {
    logger.warn({ ...baseLog, err }, 'Failed to mark run as completed (non-fatal)');
  }
}
```

3. The existing `ensureReviewOutputNotPublished` GitHub API marker scan stays as defense-in-depth. The run state check is a fast pre-filter; the marker scan remains for cases where run state was lost (e.g., DB migration).

**Important:** Keep run state check fail-open. If knowledgeStore is undefined (optional dependency), skip the check entirely. If the SQLite query throws, log a warning and proceed (do NOT block review).

Do NOT remove the existing in-memory deduplicator from `src/webhook/dedup.ts` or its usage in `src/index.ts` -- it still handles non-review event dedup at the webhook level. The run state check is specifically for the review handler's SHA-keyed idempotency.
  </action>
  <verify>Run `bun test src/handlers/review.test.ts` -- all existing review handler tests still pass. Run `bun test` -- full test suite passes.</verify>
  <done>Review handler checks run state at ingestion before workspace creation. Duplicate SHA pairs are skipped with structured log. Force-push supersession is logged. completeRun is called after successful review. Existing marker-based idempotency remains as defense-in-depth. Full test suite passes.</done>
</task>

</tasks>

<verification>
1. `bun test src/knowledge/store.test.ts` -- all run state tests pass
2. `bun test src/handlers/review.test.ts` -- existing tests still pass
3. `bun test` -- full test suite green
4. Verify run_state table is created by inspecting KnowledgeStore initialization log
5. Verify checkAndClaimRun uses `repo:pr-N:base-SHA:head-SHA` as run_key (not delivery_id)
</verification>

<success_criteria>
- run_state table exists in knowledge DB with UNIQUE constraint on run_key
- checkAndClaimRun deduplicates by SHA pair, not delivery ID
- Force-push creates new run and marks prior as superseded
- Review handler skips duplicate SHA pairs before workspace creation
- completeRun called after successful review execution
- All existing tests continue to pass
- No review path is blocked if run state check fails (fail-open)
</success_criteria>

<output>
After completion, create `.planning/phases/30-state-memory-and-isolation-foundation/30-01-SUMMARY.md`
</output>
