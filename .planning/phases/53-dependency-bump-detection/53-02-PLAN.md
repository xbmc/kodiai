---
phase: 53-dependency-bump-detection
plan: 02
type: execute
wave: 2
depends_on: ["53-01"]
files_modified:
  - src/handlers/review.ts
  - src/execution/review-prompt.ts
  - src/execution/review-prompt.test.ts
autonomous: true

must_haves:
  truths:
    - "When a Dependabot PR reaches the review handler, depBumpContext is populated and passed to buildReviewPrompt"
    - "When depBumpContext is present, the review prompt includes a Dependency Bump Context section"
    - "Major bumps produce a breaking change warning in the prompt section"
    - "Minor/patch bumps produce low-risk guidance in the prompt section"
    - "When detection returns null (non-dep PR), no depBumpContext is added and no latency is introduced"
    - "Detection failure is caught and logged as warning (fail-open pattern)"
  artifacts:
    - path: "src/handlers/review.ts"
      provides: "Dep bump detection wired between intent parsing and prompt building"
      contains: "detectDepBump"
    - path: "src/execution/review-prompt.ts"
      provides: "depBumpContext parameter and Dependency Bump Context prompt section"
      contains: "buildDepBumpSection"
    - path: "src/execution/review-prompt.test.ts"
      provides: "Tests for dep bump prompt section rendering"
      contains: "depBumpContext"
  key_links:
    - from: "src/handlers/review.ts"
      to: "src/lib/dep-bump-detector.ts"
      via: "import and call detectDepBump -> extractDepBumpDetails -> classifyDepBump"
      pattern: "detectDepBump\\("
    - from: "src/handlers/review.ts"
      to: "src/execution/review-prompt.ts"
      via: "depBumpContext parameter passed to buildReviewPrompt"
      pattern: "depBumpContext"
    - from: "src/execution/review-prompt.ts"
      to: "buildDepBumpSection"
      via: "conditional section injection when depBumpContext is non-null"
      pattern: "buildDepBumpSection"
---

<objective>
Wire the dependency bump detection pipeline into the review handler and prompt builder so detected bumps produce dependency-aware review instructions.

Purpose: Complete the end-to-end integration so Kodiai reviews provide tailored feedback for dependency bump PRs.
Output: Modified review.ts (detection wiring), modified review-prompt.ts (prompt section), new tests.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/53-dependency-bump-detection/53-RESEARCH.md
@.planning/phases/53-dependency-bump-detection/53-01-SUMMARY.md
@src/handlers/review.ts
@src/execution/review-prompt.ts
@src/lib/dep-bump-detector.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire dep bump detection into review.ts handler</name>
  <files>src/handlers/review.ts</files>
  <action>
    Import `detectDepBump`, `extractDepBumpDetails`, `classifyDepBump`, and `DepBumpContext` type from `../lib/dep-bump-detector.ts`.

    Add dep bump detection between the existing `parsePRIntent` block (~line 1267) and the `buildReviewPrompt` call (~line 1701). Place it after intent parsing but before prompt building, following the fail-open enrichment pattern used by all other enrichments.

    Implementation:
    ```typescript
    // ── Dependency bump detection (DEP-01/02/03) ──
    let depBumpContext: DepBumpContext | null = null;
    try {
      const detection = detectDepBump({
        prTitle: pr.title,
        prLabels: (pr.labels as Array<{ name: string }> | undefined)?.map((l) => l.name) ?? [],
        headBranch: pr.head.ref,
        senderLogin: pr.user.login,
      });
      if (detection) {
        const details = extractDepBumpDetails({
          detection,
          prTitle: pr.title,
          prBody: pr.body ?? null,
          changedFiles: allChangedFiles,
        });
        const classification = classifyDepBump({
          oldVersion: details.oldVersion,
          newVersion: details.newVersion,
        });
        depBumpContext = { detection, details, classification };
        logger.info(
          {
            ...baseLog,
            gate: "dep-bump-detect",
            source: detection.source,
            signals: detection.signals,
            packageName: details.packageName,
            ecosystem: details.ecosystem,
            bumpType: classification.bumpType,
            isGroup: details.isGroup,
          },
          "Dependency bump detected",
        );
      }
    } catch (err) {
      logger.warn({ ...baseLog, err }, "Dep bump detection failed (fail-open)");
    }
    ```

    Then pass `depBumpContext` to `buildReviewPrompt` by adding it to the call arguments object:
    ```typescript
    depBumpContext,
    ```

    Place it after the `authorTier` parameter (~line 1756).

    Use `allChangedFiles` (the array of changed file paths already available in the handler scope) for the `changedFiles` parameter. Verify this variable name by checking the handler -- it may be `promptFiles` or another name. Use whichever array contains the full list of changed file paths (not the tiered subset).
  </action>
  <verify>
    - `bun test src/handlers/review.test.ts` passes (existing tests unaffected)
    - `grep -n "detectDepBump" src/handlers/review.ts` shows import and usage
    - `grep -n "depBumpContext" src/handlers/review.ts` shows variable declaration and passing to buildReviewPrompt
  </verify>
  <done>
    review.ts imports and calls the three-stage dep bump pipeline between intent parsing and prompt building, passes result to buildReviewPrompt, and logs detection results. Detection failure is caught and logged as warning without blocking the review.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add depBumpContext to review-prompt.ts and tests</name>
  <files>src/execution/review-prompt.ts, src/execution/review-prompt.test.ts</files>
  <action>
    **In review-prompt.ts:**

    1. Import `DepBumpContext` type from `../lib/dep-bump-detector.ts`.

    2. Add `depBumpContext?: DepBumpContext | null;` to the `buildReviewPrompt` context parameter type, after the `authorTier` field.

    3. Add a `buildDepBumpSection(ctx: DepBumpContext): string` function (not exported, internal helper). Implementation:
    ```typescript
    function buildDepBumpSection(ctx: DepBumpContext): string {
      const lines = [
        "## Dependency Bump Context",
        "",
        `This PR is an automated dependency update (detected via: ${ctx.detection.signals.join(", ")}).`,
        "",
      ];

      if (ctx.details.isGroup) {
        lines.push("This is a **group dependency update** affecting multiple packages.");
      }
      if (ctx.details.packageName) {
        lines.push(`- **Package:** ${ctx.details.packageName}`);
      }
      if (ctx.details.oldVersion && ctx.details.newVersion) {
        lines.push(`- **Version:** ${ctx.details.oldVersion} → ${ctx.details.newVersion}`);
      } else if (ctx.details.newVersion) {
        lines.push(`- **Version:** → ${ctx.details.newVersion}`);
      }
      if (ctx.details.ecosystem) {
        lines.push(`- **Ecosystem:** ${ctx.details.ecosystem}`);
      }
      if (ctx.classification.bumpType !== "unknown") {
        lines.push(`- **Bump type:** ${ctx.classification.bumpType}`);
      }

      lines.push("");

      if (ctx.classification.isBreaking) {
        lines.push(
          "**⚠ MAJOR version bump — potential breaking changes.**",
          "Focus your review on:",
          "- Breaking API changes in the updated dependency",
          "- Deprecated features that may have been removed",
          "- Migration requirements or compatibility issues",
          "- Whether test coverage exercises the dependency's changed API surface",
        );
      } else {
        lines.push(
          "This is a minor/patch dependency update (low risk).",
          "Focus your review on:",
          "- Verify lockfile changes are consistent with the manifest change",
          "- Check for unexpected additions to the dependency tree",
          "- Keep review concise — minor/patch bumps are routine maintenance",
        );
      }

      return lines.join("\n");
    }
    ```

    4. In the `buildReviewPrompt` function body, add the dep bump section injection. Place it after the author tier section and before the final instructions. Find the appropriate location by looking for where other optional context sections are appended and add:
    ```typescript
    if (context.depBumpContext) {
      lines.push("", buildDepBumpSection(context.depBumpContext));
    }
    ```

    **In review-prompt.test.ts:**

    Add a new `describe("depBumpContext")` block with tests:
    1. "includes dependency bump section for major bump" — pass depBumpContext with bumpType "major", verify output contains "Dependency Bump Context", "MAJOR version bump", package name, versions, ecosystem
    2. "includes dependency bump section for minor/patch bump" — pass depBumpContext with bumpType "patch", verify output contains "minor/patch dependency update", no "MAJOR" text
    3. "includes group bump note" — pass depBumpContext with isGroup: true, verify "group dependency update" appears
    4. "omits section when depBumpContext is null" — pass depBumpContext: null, verify "Dependency Bump Context" NOT in output
    5. "omits section when depBumpContext is undefined" — don't pass depBumpContext at all, verify "Dependency Bump Context" NOT in output

    Follow the existing test patterns in review-prompt.test.ts — use the same test helper/factory for building the context object.
  </action>
  <verify>
    - `bun test src/execution/review-prompt.test.ts` passes all tests including new depBumpContext tests
    - `grep -n "depBumpContext" src/execution/review-prompt.ts` shows parameter, type import, and section injection
    - `grep -n "buildDepBumpSection" src/execution/review-prompt.ts` shows the helper function
    - `bun test` — full test suite passes with no regressions
  </verify>
  <done>
    review-prompt.ts accepts optional depBumpContext, renders a Dependency Bump Context section with package/version/ecosystem/bump-type information, provides breaking change warnings for major bumps and low-risk guidance for minor/patch bumps. Tests verify all rendering variants and null/undefined handling.
  </done>
</task>

</tasks>

<verification>
- `bun test` — full test suite passes (all existing + new tests, zero regressions)
- A simulated Dependabot PR (title: "Bump lodash from 4.17.20 to 4.17.21", sender: "dependabot[bot]", branch: "dependabot/npm_and_yarn/lodash-4.17.21") would produce a depBumpContext with source "dependabot", ecosystem "npm", bumpType "patch"
- A simulated human PR (title: "Bump minimum Node to 20", sender: "someuser", branch: "feature/node-20") produces no depBumpContext (null)
- The review prompt for a detected dep bump contains "## Dependency Bump Context" section
- The review prompt for a non-dep PR does NOT contain "## Dependency Bump Context"
</verification>

<success_criteria>
- Dep bump detection is wired into review.ts with fail-open error handling
- Review prompt includes tailored dependency context section when bump is detected
- Major bumps trigger breaking change review guidance
- Minor/patch bumps trigger concise low-risk review guidance
- Non-dependency PRs see zero changes in review prompt output
- Full test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/53-dependency-bump-detection/53-02-SUMMARY.md`
</output>
