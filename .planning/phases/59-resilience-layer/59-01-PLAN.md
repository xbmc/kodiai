---
phase: 59-resilience-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/knowledge/types.ts
  - src/knowledge/store.ts
  - src/execution/mcp/checkpoint-server.ts
  - src/execution/mcp/checkpoint-server.test.ts
autonomous: true

must_haves:
  truths:
    - "Checkpoint MCP tool accepts filesReviewed, findingCount, summaryDraft and persists to knowledge store"
    - "Knowledge store can save, retrieve, update, and delete checkpoint records keyed by reviewOutputKey"
    - "Checkpoint supports upsert semantics so repeated calls overwrite previous checkpoint for the same reviewOutputKey"
  artifacts:
    - path: "src/execution/mcp/checkpoint-server.ts"
      provides: "save_review_checkpoint MCP tool following createSdkMcpServer pattern"
      exports: ["createCheckpointServer"]
    - path: "src/knowledge/types.ts"
      provides: "CheckpointRecord type and KnowledgeStore checkpoint methods"
      contains: "CheckpointRecord"
    - path: "src/knowledge/store.ts"
      provides: "review_checkpoints table with saveCheckpoint, getCheckpoint, deleteCheckpoint, updateCheckpointCommentId"
      contains: "review_checkpoints"
  key_links:
    - from: "src/execution/mcp/checkpoint-server.ts"
      to: "src/knowledge/store.ts"
      via: "knowledgeStore.saveCheckpoint() call"
      pattern: "saveCheckpoint"
---

<objective>
Build the checkpoint accumulation infrastructure: a knowledge store table for persisting checkpoint data, and an MCP tool that Claude invokes during review execution to report progress.

Purpose: Enables the review handler to know what was reviewed and what findings exist when a timeout occurs, which is the prerequisite for partial review publishing and retry scope reduction.
Output: `createCheckpointServer` factory function, `review_checkpoints` table, checkpoint CRUD methods on KnowledgeStore.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/59-resilience-layer/59-RESEARCH.md
@src/knowledge/types.ts
@src/knowledge/store.ts
@src/execution/mcp/inline-review-server.ts
@src/execution/mcp/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add checkpoint schema and CRUD methods to knowledge store</name>
  <files>src/knowledge/types.ts, src/knowledge/store.ts</files>
  <action>
In `src/knowledge/types.ts`:
- Add `CheckpointRecord` type:
  ```typescript
  export type CheckpointRecord = {
    reviewOutputKey: string;
    repo: string;
    prNumber: number;
    filesReviewed: string[];
    findingCount: number;
    summaryDraft: string;
    totalFiles: number;
    partialCommentId?: number | null;
    createdAt?: string;
  };
  ```
- Extend the `KnowledgeStore` type with four new optional methods (optional `?` to maintain backward compatibility with test mocks):
  - `saveCheckpoint?(data: CheckpointRecord): void` -- upsert checkpoint keyed by reviewOutputKey
  - `getCheckpoint?(reviewOutputKey: string): CheckpointRecord | null` -- retrieve latest checkpoint
  - `deleteCheckpoint?(reviewOutputKey: string): void` -- cleanup after successful retry merge
  - `updateCheckpointCommentId?(reviewOutputKey: string, commentId: number): void` -- store the partial review comment ID for retry replacement

In `src/knowledge/store.ts`:
- Add `CREATE TABLE IF NOT EXISTS review_checkpoints` in the initialization section following the existing pattern:
  ```sql
  CREATE TABLE IF NOT EXISTS review_checkpoints (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    review_output_key TEXT NOT NULL,
    repo TEXT NOT NULL,
    pr_number INTEGER NOT NULL,
    checkpoint_data TEXT NOT NULL,
    partial_comment_id INTEGER,
    UNIQUE(review_output_key)
  );
  ```
- Implement `saveCheckpoint`: use `INSERT INTO review_checkpoints ... ON CONFLICT(review_output_key) DO UPDATE SET checkpoint_data = excluded.checkpoint_data, partial_comment_id = COALESCE(excluded.partial_comment_id, review_checkpoints.partial_comment_id)`. The `checkpoint_data` column stores JSON: `{ filesReviewed, findingCount, summaryDraft, totalFiles }`.
- Implement `getCheckpoint`: SELECT by review_output_key, parse checkpoint_data JSON, return CheckpointRecord or null.
- Implement `deleteCheckpoint`: DELETE by review_output_key.
- Implement `updateCheckpointCommentId`: UPDATE partial_comment_id WHERE review_output_key = ?.

Use prepared statements following the existing pattern in store.ts.
  </action>
  <verify>Run `bun test src/knowledge/ --timeout 10000` -- existing knowledge store tests still pass. Grep the store.ts file for `review_checkpoints` to confirm table creation and all four methods exist.</verify>
  <done>Knowledge store has review_checkpoints table with CRUD methods for checkpoint data, CheckpointRecord type exported from types.ts, all existing tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Create checkpoint MCP server with tests</name>
  <files>src/execution/mcp/checkpoint-server.ts, src/execution/mcp/checkpoint-server.test.ts</files>
  <action>
Create `src/execution/mcp/checkpoint-server.ts` following the exact pattern of `inline-review-server.ts`:
- Export `createCheckpointServer` factory function with parameters:
  - `knowledgeStore: KnowledgeStore` (from knowledge/types.ts)
  - `reviewOutputKey: string`
  - `repo: string`
  - `prNumber: number`
  - `totalFiles: number`
  - `logger?: Logger`
- Use `createSdkMcpServer` from `@anthropic-ai/claude-agent-sdk` with name `"review_checkpoint"`, version `"0.1.0"`.
- Register one tool: `save_review_checkpoint` with:
  - Description: `"Save partial review progress. Call after reviewing each batch of files. If the session times out, saved progress will be published as a partial review."`
  - Input schema (zod):
    - `filesReviewed: z.array(z.string()).describe("File paths that have been fully reviewed so far")`
    - `findingCount: z.number().describe("Total number of findings generated so far")`
    - `summaryDraft: z.string().describe("Draft summary of findings so far (will be used as partial review body)")`
  - Handler: call `knowledgeStore.saveCheckpoint?.({ reviewOutputKey, repo, prNumber, filesReviewed, findingCount, summaryDraft, totalFiles })`. Log at debug level. Return JSON response: `{ saved: true, filesReviewed: filesReviewed.length, totalFiles }`.
  - If `knowledgeStore.saveCheckpoint` is undefined, log a warning and return `{ saved: false, reason: "checkpoint storage unavailable" }`.

Create `src/execution/mcp/checkpoint-server.test.ts`:
- Test that `createCheckpointServer` returns an MCP server object (has name property).
- Test the tool handler by constructing a mock knowledgeStore with a `saveCheckpoint` spy and invoking the tool via the MCP server's tool list. Verify saveCheckpoint was called with correct args.
- Test graceful degradation when `saveCheckpoint` is undefined on knowledgeStore.
- Follow the test patterns in `comment-server.test.ts` and `inline-review-server.test.ts`.
  </action>
  <verify>Run `bun test src/execution/mcp/checkpoint-server.test.ts` -- all tests pass. Run `bunx tsc --noEmit` -- no type errors.</verify>
  <done>Checkpoint MCP server creates a save_review_checkpoint tool that persists progress to the knowledge store, tests verify both happy path and graceful degradation.</done>
</task>

</tasks>

<verification>
- `bun test` -- all existing tests plus new checkpoint-server tests pass
- `bunx tsc --noEmit` -- no type errors
- `review_checkpoints` table created in knowledge store initialization
- CheckpointRecord type exported from knowledge/types.ts
- createCheckpointServer exported from checkpoint-server.ts
</verification>

<success_criteria>
Checkpoint accumulation infrastructure is complete: a knowledge store table persists checkpoint data, an MCP tool allows Claude to report review progress, and CRUD methods enable the review handler to read/write/clean checkpoint state.
</success_criteria>

<output>
After completion, create `.planning/phases/59-resilience-layer/59-01-SUMMARY.md`
</output>
