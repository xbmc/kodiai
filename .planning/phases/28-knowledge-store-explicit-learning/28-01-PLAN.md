---
phase: 28-knowledge-store-explicit-learning
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/knowledge/types.ts
  - src/knowledge/store.ts
  - src/knowledge/store.test.ts
autonomous: true

must_haves:
  truths:
    - "Knowledge store persists review records with metrics (files analyzed, lines changed, finding counts by severity)"
    - "Knowledge store persists individual findings with severity, category, confidence, file path, and suppression status"
    - "Knowledge store persists suppression log entries showing which patterns fired per review"
    - "Knowledge store provides repo-level stats queries (total reviews, findings by severity, top files)"
    - "Knowledge store provides daily trend data for time-series analysis"
  artifacts:
    - path: "src/knowledge/types.ts"
      provides: "ReviewRecord, FindingRecord, SuppressionLogEntry, KnowledgeStore, RepoStats, TrendData types"
      exports: ["ReviewRecord", "FindingRecord", "SuppressionLogEntry", "KnowledgeStore", "RepoStats", "TrendData"]
    - path: "src/knowledge/store.ts"
      provides: "createKnowledgeStore factory function with SQLite WAL mode"
      exports: ["createKnowledgeStore"]
    - path: "src/knowledge/store.test.ts"
      provides: "Tests for all knowledge store operations"
      min_lines: 150
  key_links:
    - from: "src/knowledge/store.ts"
      to: "src/knowledge/types.ts"
      via: "type imports for KnowledgeStore interface"
      pattern: "import.*KnowledgeStore.*from.*types"
    - from: "src/knowledge/store.ts"
      to: "bun:sqlite"
      via: "Database class for SQLite operations"
      pattern: "import.*Database.*from.*bun:sqlite"
---

<objective>
Create the SQLite-backed knowledge store that persists review findings, metrics, and suppression history. This is the storage foundation for Phase 28.

Purpose: All other Phase 28 features (suppression tracking, confidence scoring, metrics display, CLI reporting) need a place to persist and query data. The knowledge store follows the exact same factory pattern as the existing telemetry store.

Output: `createKnowledgeStore()` factory function with types, schema, and comprehensive tests.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-knowledge-store-explicit-learning/28-RESEARCH.md
@src/telemetry/store.ts
@src/telemetry/types.ts
</context>

<feature>
  <name>Knowledge Store with SQLite WAL</name>
  <files>src/knowledge/types.ts, src/knowledge/store.ts, src/knowledge/store.test.ts</files>
  <behavior>
    Mirror the telemetry store pattern exactly: `createKnowledgeStore({ dbPath, logger })` factory returning a `KnowledgeStore` interface.

    **Types (src/knowledge/types.ts):**
    - `ReviewRecord`: repo, prNumber, headSha?, deliveryId?, filesAnalyzed, linesChanged, findingsCritical/Major/Medium/Minor, findingsTotal, suppressionsApplied, configSnapshot? (JSON string), durationMs?, model?, conclusion
    - `FindingRecord`: reviewId, filePath, startLine?, endLine?, severity (critical|major|medium|minor), category (security|correctness|performance|style|documentation), confidence (0-100), title, suppressed (boolean), suppressionPattern?
    - `SuppressionLogEntry`: reviewId, pattern, matchedCount, findingIds? (number array)
    - `KnowledgeStore`: recordReview(entry) => number (returns review ID), recordFindings(findings[]) => void, recordSuppressionLog(entries[]) => void, getRepoStats(repo, sinceDays?) => RepoStats, getRepoTrends(repo, days) => TrendData[], checkpoint() => void, close() => void
    - `RepoStats`: totalReviews, totalFindings, findingsBySeverity (Record<string, number>), totalSuppressed, avgFindingsPerReview, avgConfidence, topFiles (Array<{path, findingCount}>)
    - `TrendData`: date (string), reviewCount, findingsCount, suppressionsCount, avgConfidence

    **Schema (in store.ts):**
    Three tables: `reviews`, `findings`, `suppression_log` -- use the exact SQL from RESEARCH.md.
    Enable `PRAGMA foreign_keys = ON` (unlike telemetry, knowledge store has relationships).
    Indexes: `idx_reviews_repo`, `idx_reviews_repo_created`, `idx_reviews_pr`, `idx_findings_review`, `idx_findings_severity`, `idx_findings_repo_file`, `idx_suppression_log_review`.

    **Store operations:**
    - `recordReview`: Prepared INSERT into reviews table, returns lastInsertRowid as number
    - `recordFindings`: Transaction-wrapped batch INSERT into findings table. Store findingIds as JSON string for suppression_log.
    - `recordSuppressionLog`: Batch INSERT into suppression_log table, store finding_ids as JSON array string
    - `getRepoStats`: Query reviews + findings for a given repo, with optional `sinceDays` filter. Returns aggregate counts, severity breakdown, avg confidence, top 10 files by finding count.
    - `getRepoTrends`: Group reviews by date for the given repo over the last N days. Return daily aggregates.
    - `checkpoint`: PRAGMA wal_checkpoint(PASSIVE)
    - `close`: db.close(false)

    Cases:
    - recordReview({repo: "owner/repo", prNumber: 42, ...}) => returns integer review ID > 0
    - recordFindings([{reviewId: 1, filePath: "src/a.ts", severity: "major", ...}]) => void, queryable afterwards
    - recordSuppressionLog([{reviewId: 1, pattern: "missing error handling", matchedCount: 2}]) => void
    - getRepoStats("owner/repo") => { totalReviews: 1, totalFindings: N, ... }
    - getRepoStats("owner/repo", 7) => filters to last 7 days
    - getRepoTrends("owner/repo", 30) => array of daily aggregates
    - Empty repo returns zeros/empty arrays, not errors
  </behavior>
  <implementation>
    Follow TDD RED-GREEN-REFACTOR cycle.

    RED: Create types.ts first (no tests needed, pure types). Then create store.test.ts with failing tests covering: record + retrieve review, record + retrieve findings, suppression log, repo stats, repo trends, empty repo, foreign key enforcement, WAL mode verification, directory creation, close behavior.

    GREEN: Implement createKnowledgeStore in store.ts. Use `bun:sqlite` Database class. Same PRAGMAs as telemetry store (WAL, NORMAL sync, busy_timeout 5000) plus `foreign_keys = ON`. CREATE TABLE IF NOT EXISTS for all three tables plus indexes. Prepared statements for inserts. Use `db.query().get()` with `RETURNING id` for recordReview to get the last insert ID. Use `db.transaction()` for batch inserts in recordFindings. Query methods use parameterized queries with `$` prefix.

    REFACTOR: Clean up if needed. Ensure all tests pass.

    IMPORTANT: Tests should use file-backed temp databases (not :memory:) for consistency with the telemetry store test pattern. Use `import { mkdtempSync } from "node:fs"` and `import { tmpdir } from "node:os"` for temp directories.

    Do NOT add auto-checkpoint or retention purge -- the locked decision says "keep forever" and the knowledge store is read-after-write (not high-frequency like telemetry).
  </implementation>
</feature>

<verification>
```bash
bun test src/knowledge/store.test.ts
bunx tsc --noEmit
```
All tests pass. No TypeScript errors.
</verification>

<success_criteria>
- createKnowledgeStore factory function creates SQLite database with WAL mode and 3 tables
- recordReview returns an integer review ID
- recordFindings batch-inserts findings linked to a review
- recordSuppressionLog records which patterns fired
- getRepoStats returns aggregate stats for a repo
- getRepoTrends returns daily trend data
- All operations handle empty/missing data gracefully (no crashes)
- Foreign key constraints enforced between findings/suppression_log and reviews
</success_criteria>

<output>
After completion, create `.planning/phases/28-knowledge-store-explicit-learning/28-01-SUMMARY.md`
</output>
