---
phase: 04-pr-auto-review
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/handlers/review.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "pull_request.opened event for a non-draft PR triggers the review handler"
    - "pull_request.ready_for_review event triggers the review handler"
    - "Draft PRs on pull_request.opened are skipped with debug logging"
    - "Fork PRs clone from the fork repo (head.repo) but post comments to the base repo"
    - "Base branch is fetched after clone so git diff works"
    - "After successful execution with no inline comments posted, a silent APPROVE review is submitted"
    - "After successful execution with inline comments posted, no approval is submitted"
    - "review.enabled=false in config skips the review"
    - "review.skipAuthors skips PRs from matching authors"
    - "The review handler is wired into the server startup in index.ts"
  artifacts:
    - path: "src/handlers/review.ts"
      provides: "Review event handler with fork support and silent approval"
      exports: ["createReviewHandler"]
    - path: "src/index.ts"
      provides: "Server wiring with review handler registration"
      contains: "createReviewHandler"
  key_links:
    - from: "src/handlers/review.ts"
      to: "src/webhook/types.ts"
      via: "imports EventRouter, WebhookEvent, EventHandler"
      pattern: "import.*webhook/types"
    - from: "src/handlers/review.ts"
      to: "src/execution/executor.ts"
      via: "calls executor.execute() with review context"
      pattern: "executor\\.execute"
    - from: "src/handlers/review.ts"
      to: "src/execution/review-prompt.ts"
      via: "calls buildReviewPrompt() for prompt generation"
      pattern: "buildReviewPrompt"
    - from: "src/handlers/review.ts"
      to: "src/execution/config.ts"
      via: "calls loadRepoConfig() to check review.enabled and skipAuthors"
      pattern: "loadRepoConfig"
    - from: "src/handlers/review.ts"
      to: "src/auth/github-app.ts"
      via: "calls getInstallationOctokit() for approval and getAppSlug() for bot comment detection"
      pattern: "getInstallationOctokit|getAppSlug"
    - from: "src/index.ts"
      to: "src/handlers/review.ts"
      via: "imports and calls createReviewHandler()"
      pattern: "createReviewHandler"
---

<objective>
Create the review handler that registers for PR events, orchestrates the full review pipeline (clone, fetch base branch, build prompt, execute, silent approve), and wire it into the server.

Purpose: This is the core of Phase 4 -- the handler that connects webhook events to the execution engine with review-specific logic. It handles fork PRs, draft PR filtering, author skipping, config-driven enable/disable, and the post-execution silent approval flow.

Output: `src/handlers/review.ts` (new), updated `src/index.ts`
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-pr-auto-review/04-RESEARCH.md
@.planning/phases/04-pr-auto-review/04-01-SUMMARY.md
@src/execution/types.ts
@src/execution/executor.ts
@src/execution/review-prompt.ts
@src/execution/config.ts
@src/execution/mcp/index.ts
@src/webhook/types.ts
@src/webhook/router.ts
@src/auth/github-app.ts
@src/jobs/types.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create review handler with fork support and silent approval</name>
  <files>src/handlers/review.ts</files>
  <action>
Create `src/handlers/review.ts` with a `createReviewHandler()` factory function following the established pattern (see 01-01 decision: factory function pattern for all module exports).

**Dependencies (constructor injection):**
```typescript
export function createReviewHandler(deps: {
  eventRouter: EventRouter;
  jobQueue: JobQueue;
  workspaceManager: WorkspaceManager;
  githubApp: GitHubApp;
  executor: ReturnType<typeof createExecutor>;
  logger: Logger;
}): void
```

The function registers two event handlers and returns void (side effect: registers with eventRouter).

**Core flow for `handleReview(event)`:**

1. **Extract PR data** from `event.payload` cast as `PullRequestOpenedEvent | PullRequestReadyForReviewEvent` (import from `@octokit/webhooks-types`). Use a helper function `extractPRData(payload)` that returns:
   - `number`, `title`, `body`, `author`, `draft`, `baseBranch`, `headBranch`, `headSha`
   - `isFork` (true when `pr.head.repo?.full_name !== payload.repository.full_name`)
   - `cloneOwner`, `cloneRepo` (from `pr.head.repo` with fallback to `payload.repository`)
   - `apiOwner`, `apiRepo` (always from `payload.repository`)
   - `changedFiles` -- NOT available from webhook payload, will be empty array (Claude discovers via git diff)

2. **Skip draft PRs:** If `pr.draft === true`, log debug and return early.

3. **Enqueue job** via `jobQueue.enqueue(event.installationId, async () => { ... })`:

   a. **Create workspace:** Call `workspaceManager.create(event.installationId, { owner: cloneOwner, repo: cloneRepo, ref: headBranch, depth: 50 })`. Use depth 50 (not 1) so git diff has enough history. For fork PRs from public repos, the workspace manager already handles clone via HTTPS with token -- if the fork is public, the clone URL will still work with the base repo's installation token against the fork (GitHub allows this for public repos).

   b. **Fetch base branch:** After workspace creation, run `Bun.$\`git -C ${workspace.dir} fetch origin ${baseBranch} --depth=1\`.quiet()` to fetch the base branch tip for diff comparison. Wrap in try/catch -- if this fails (e.g., deleted fork), log error and return early (cleanup workspace in finally).

   c. **Load repo config:** Call `loadRepoConfig(workspace.dir)` to get the `.kodiai.yml` settings.

   d. **Check review.enabled:** If `config.review.enabled === false`, log info "Review disabled by config" and return early.

   e. **Check review.skipAuthors:** If `config.review.skipAuthors.includes(prData.author)`, log info and return early. This allows skipping dependabot, renovate, etc.

   f. **Build review prompt:** Call `buildReviewPrompt({ owner: apiOwner, repo: apiRepo, prNumber: number, prTitle: title, prBody: body ?? "", prAuthor: author, baseBranch, headBranch, changedFiles: [], customInstructions: config.review.prompt })`. Pass empty changedFiles array -- Claude will discover changed files via git log/diff commands.

   g. **Execute:** Call `executor.execute({ workspace, installationId: event.installationId, owner: apiOwner, repo: apiRepo, prNumber: number, commentId: undefined, eventType: \`pull_request.${payload.action}\`, triggerBody: prompt })`. IMPORTANT: Pass the review prompt as `triggerBody` so the existing `buildPrompt()` in executor includes it. OR better: the executor calls `buildPrompt(context)` which produces a generic prompt. We need to override this. Since `buildPrompt` is called inside `executor.execute()`, we have two options:
      - Option A: Modify executor to accept an optional `promptOverride` field on ExecutionContext
      - Option B: Put the review prompt in `triggerBody` and let `buildPrompt` format it

   Choose Option A: Add an optional `promptOverride?: string` field to `ExecutionContext` in `types.ts`. When set, the executor uses it instead of calling `buildPrompt()`. This is cleaner than stuffing the full review prompt into `triggerBody`. Update `src/execution/types.ts` to add the field, and update `src/execution/executor.ts` to check for it: `const prompt = context.promptOverride ?? buildPrompt(context);`

   h. **Post-execution silent approval:** After `executor.execute()` returns, if `result.conclusion === "success"`, call `maybeApprove()`.

   i. **Workspace cleanup:** Always in `finally` block via `workspace.cleanup()`.

4. **Register handlers:**
   ```typescript
   eventRouter.register("pull_request.opened", handleReview);
   eventRouter.register("pull_request.ready_for_review", handleReview);
   ```

**`maybeApprove` helper** (private function in the module):
- Get `octokit` via `githubApp.getInstallationOctokit(installationId)`
- List recent review comments: `octokit.rest.pulls.listReviewComments({ owner, repo, pull_number: prNumber, sort: "created", direction: "desc", per_page: 10 })`
- Get app slug via `githubApp.getAppSlug()`
- Filter comments where `c.user?.login === \`${appSlug}[bot]\``
- If NO bot comments found AND `config.review.autoApprove !== false` (but wait -- research says autoApprove defaults to false, meaning no silent approval by default? Let me reconsider. The success criteria says "clean PRs receive silent approval". So autoApprove should default to TRUE for the PR auto-review feature. However the research says `autoApprove: false`. The success criteria is authoritative: "A PR with no issues receives a silent approval." So always approve silently when no issues are found. The `autoApprove` config field controls whether to submit a GitHub APPROVE review or just skip quietly. Default it to `false` for now since auto-approving PRs can be controversial -- instead, just don't post any comment (truly silent = no comment AND no approval). Actually re-reading the success criteria: "A PR with no issues receives a silent approval (no comment posted, no noise)." This means: submit an APPROVE review but with no body text. This IS the silent approval.)
- Decision: Always call `maybeApprove`. If no bot comments were posted, submit `createReview({ event: "APPROVE" })` with no body. If bot comments exist, skip the approval (Claude already posted its findings).
- Wrap in try/catch to avoid crashing if approval fails (e.g., PR was closed between review and approval).

**Fork PR handling (Pitfall 2 from research):**
- For fork PRs, `pr.head.repo` might be null (deleted fork). If `pr.head.repo === null`, fall back to cloning from the base repo and fetching the PR ref: use `cloneOwner = apiOwner, cloneRepo = apiRepo, ref = pr.head.ref` but after clone, additionally run `git fetch origin pull/${prNumber}/head:pr-review && git checkout pr-review`. However, this is an edge case. For the common case, just use `pr.head.repo` values. If `head.repo` is null, log a warning and skip the review (user can re-trigger via mention).

**Error handling:**
- All errors within the job are caught and logged (the executor already never throws, but workspace creation and git fetch might). The handler should catch these and log, not crash the server.
  </action>
  <verify>Run `bun build src/handlers/review.ts --no-bundle` to verify it compiles. Check that `src/execution/types.ts` has the `promptOverride` field. Check that `src/execution/executor.ts` uses `promptOverride` when present.</verify>
  <done>
- `createReviewHandler()` registers for `pull_request.opened` and `pull_request.ready_for_review`
- Draft PRs are skipped
- Fork PRs clone from head.repo, null head.repo PRs are skipped with warning
- Base branch is fetched after clone for diff context
- Config-driven review.enabled and review.skipAuthors are respected
- Review prompt is passed via promptOverride on ExecutionContext
- After successful execution, maybeApprove submits APPROVE review if no bot comments found
- ExecutionContext.promptOverride field added to types.ts
- Executor checks for promptOverride before calling buildPrompt
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire review handler into server startup</name>
  <files>src/index.ts</files>
  <action>
Update `src/index.ts` to:

1. Import `createExecutor` from `./execution/executor.ts`
2. Import `createReviewHandler` from `./handlers/review.ts`
3. After the event router is created and before the Hono app is created, instantiate the executor and register the review handler:

```typescript
import { createExecutor } from "./execution/executor.ts";
import { createReviewHandler } from "./handlers/review.ts";

// ... existing code ...

// Execution engine
const executor = createExecutor({ githubApp, logger });

// Register event handlers
createReviewHandler({
  eventRouter,
  jobQueue,
  workspaceManager,
  githubApp,
  executor,
  logger,
});
```

4. Remove the placeholder comment about "Phase 3+ plans will register handlers" since handlers are now registered.

Keep the existing code structure intact. The new code goes between the `eventRouter` creation and the `new Hono()` line. Do NOT modify any existing route mounting or error handling.
  </action>
  <verify>Run `bun build src/index.ts --no-bundle` to verify the full server compiles. Check that imports resolve correctly.</verify>
  <done>
- Server creates executor instance at startup
- Review handler is registered with all required dependencies
- Pull request opened and ready_for_review events are now handled
- No placeholder comments remain about future handler registration
- Server still starts and compiles cleanly
  </done>
</task>

</tasks>

<verification>
- `bun build src/handlers/review.ts --no-bundle` compiles without errors
- `bun build src/index.ts --no-bundle` compiles without errors (full server)
- `bun test` passes all existing tests
- `src/handlers/review.ts` exports `createReviewHandler`
- `src/index.ts` imports and calls `createReviewHandler` with correct dependencies
- `src/execution/types.ts` includes `promptOverride?: string` on ExecutionContext
- `src/execution/executor.ts` uses `promptOverride` when present
</verification>

<success_criteria>
- PR opened and ready_for_review events are handled by the review handler
- Draft PRs are skipped
- Fork PRs work natively (clone from fork, API calls to base repo)
- Base branch is fetched for diff context
- Config-driven review.enabled and review.skipAuthors are respected
- Silent APPROVE review is submitted when no inline comments are posted
- Review handler is wired into the server and all code compiles
</success_criteria>

<output>
After completion, create `.planning/phases/04-pr-auto-review/04-02-SUMMARY.md`
</output>
