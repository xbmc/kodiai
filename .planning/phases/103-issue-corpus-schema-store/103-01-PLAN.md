---
phase: 103-issue-corpus-schema-store
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/migrations/014-issues.sql
  - src/db/migrations/014-issues.down.sql
  - src/knowledge/issue-types.ts
autonomous: true
requirements: [ICORP-01]

must_haves:
  truths:
    - Migration 014 creates `issues` table with HNSW vector index (cosine, m=16) and tsvector GIN index
    - Migration 014 creates `issue_comments` table with HNSW vector index and tsvector GIN index
    - Issues table includes state, author_association, label_names, template_slug, comment_count columns
    - TypeScript types define IssueStore interface with upsert, delete, getByNumber, search, and findSimilar methods
  artifacts:
    - src/db/migrations/014-issues.sql
    - src/db/migrations/014-issues.down.sql
    - src/knowledge/issue-types.ts
  key_links:
    - issue-types.ts exports IssueStore, IssueRecord, IssueInput, IssueSearchResult, IssueCommentRecord, IssueCommentInput, IssueCommentSearchResult
---

<objective>
Create the PostgreSQL migration for the issue corpus (issues + issue_comments tables) and the TypeScript type definitions.

Purpose: Foundation for the issue vector store — schema + contracts first, implementation in Plan 02.
Output: Migration 014, rollback, and issue-types.ts with all store interfaces.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/103-issue-corpus-schema-store/103-RESEARCH.md

<interfaces>
<!-- Existing patterns the executor should follow -->

From src/db/migrations/005-review-comments.sql (reference migration pattern):
- Table with BIGSERIAL PRIMARY KEY, TIMESTAMPTZ created_at
- embedding vector(1024), embedding_model TEXT
- HNSW index: USING hnsw (embedding vector_cosine_ops) WITH (m = 16, ef_construction = 64)
- tsvector via trigger function (BEFORE INSERT OR UPDATE)
- Sync state table for backfill tracking

From src/knowledge/review-comment-types.ts (reference type pattern):
```typescript
export type ReviewCommentStore = {
  writeChunks(chunks: ReviewCommentChunk[]): Promise<void>;
  softDelete(repo: string, commentGithubId: number): Promise<void>;
  searchByEmbedding(params: { queryEmbedding: Float32Array; repo: string; topK: number }): Promise<ReviewCommentSearchResult[]>;
  searchByFullText(params: { query: string; repo: string; topK: number }): Promise<ReviewCommentSearchResult[]>;
  countByRepo(repo: string): Promise<number>;
};
```

From src/db/client.ts:
```typescript
export type Sql = ReturnType<typeof postgres>;
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration 014-issues.sql</name>
  <files>src/db/migrations/014-issues.sql, src/db/migrations/014-issues.down.sql</files>
  <action>
Create `src/db/migrations/014-issues.sql` with two tables:

**issues table:**
```sql
CREATE TABLE IF NOT EXISTS issues (
  id BIGSERIAL PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  repo TEXT NOT NULL,
  owner TEXT NOT NULL,
  issue_number INTEGER NOT NULL,
  title TEXT NOT NULL,
  body TEXT,
  state TEXT NOT NULL DEFAULT 'open',
  author_login TEXT NOT NULL,
  author_association TEXT,
  label_names TEXT[] NOT NULL DEFAULT '{}',
  template_slug TEXT,
  comment_count INTEGER NOT NULL DEFAULT 0,
  assignees JSONB DEFAULT '[]',
  milestone TEXT,
  reaction_count INTEGER NOT NULL DEFAULT 0,
  is_pull_request BOOLEAN NOT NULL DEFAULT false,
  locked BOOLEAN NOT NULL DEFAULT false,
  embedding vector(1024),
  embedding_model TEXT,
  search_tsv tsvector,
  github_created_at TIMESTAMPTZ NOT NULL,
  github_updated_at TIMESTAMPTZ,
  closed_at TIMESTAMPTZ,
  UNIQUE(repo, issue_number)
);
```

Indexes for issues:
- `idx_issues_repo` — B-tree on repo
- `idx_issues_repo_number` — B-tree on (repo, issue_number) — for fast lookup
- `idx_issues_state` — B-tree on state
- `idx_issues_author` — B-tree on author_login
- `idx_issues_labels` — GIN on label_names (for `@>` containment queries)
- `idx_issues_embedding_hnsw` — HNSW vector cosine (m=16, ef_construction=64)
- `idx_issues_search_tsv` — GIN on search_tsv

tsvector trigger for issues — weighted: title (A) + body (B) + labels (C):
```sql
CREATE OR REPLACE FUNCTION issues_search_tsv_update() RETURNS trigger AS $$
BEGIN
  NEW.search_tsv := setweight(to_tsvector('english', COALESCE(NEW.title, '')), 'A') ||
                    setweight(to_tsvector('english', COALESCE(NEW.body, '')), 'B') ||
                    setweight(to_tsvector('english', COALESCE(array_to_string(NEW.label_names, ' '), '')), 'C');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_issues_search_tsv ON issues;
CREATE TRIGGER trg_issues_search_tsv
  BEFORE INSERT OR UPDATE OF title, body, label_names ON issues
  FOR EACH ROW
  EXECUTE FUNCTION issues_search_tsv_update();
```

**issue_comments table:**
```sql
CREATE TABLE IF NOT EXISTS issue_comments (
  id BIGSERIAL PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  repo TEXT NOT NULL,
  issue_number INTEGER NOT NULL,
  comment_github_id BIGINT NOT NULL,
  author_login TEXT NOT NULL,
  author_association TEXT,
  body TEXT NOT NULL,
  embedding vector(1024),
  embedding_model TEXT,
  search_tsv tsvector,
  github_created_at TIMESTAMPTZ NOT NULL,
  github_updated_at TIMESTAMPTZ,
  UNIQUE(repo, comment_github_id)
);
```

Indexes for issue_comments:
- `idx_issue_comments_repo_issue` — B-tree on (repo, issue_number)
- `idx_issue_comments_author` — B-tree on author_login
- `idx_issue_comments_embedding_hnsw` — HNSW vector cosine (m=16, ef_construction=64)
- `idx_issue_comments_search_tsv` — GIN on search_tsv

tsvector trigger for issue_comments — body only:
```sql
CREATE OR REPLACE FUNCTION issue_comments_search_tsv_update() RETURNS trigger AS $$
BEGIN
  NEW.search_tsv := to_tsvector('english', COALESCE(NEW.body, ''));
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_issue_comments_search_tsv ON issue_comments;
CREATE TRIGGER trg_issue_comments_search_tsv
  BEFORE INSERT OR UPDATE OF body ON issue_comments
  FOR EACH ROW
  EXECUTE FUNCTION issue_comments_search_tsv_update();
```

Create `src/db/migrations/014-issues.down.sql`:
```sql
DROP TRIGGER IF EXISTS trg_issue_comments_search_tsv ON issue_comments;
DROP FUNCTION IF EXISTS issue_comments_search_tsv_update();
DROP TABLE IF EXISTS issue_comments;
DROP TRIGGER IF EXISTS trg_issues_search_tsv ON issues;
DROP FUNCTION IF EXISTS issues_search_tsv_update();
DROP TABLE IF EXISTS issues;
```
  </action>
  <verify>
    <automated>grep -c "CREATE TABLE" src/db/migrations/014-issues.sql | grep -q "2" && grep -c "hnsw" src/db/migrations/014-issues.sql | grep -q "2" && echo "PASS" || echo "FAIL"</automated>
  </verify>
  <done>Migration 014 creates issues and issue_comments tables with HNSW + tsvector indexes. Down migration drops both tables cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Create issue-types.ts with store interface</name>
  <files>src/knowledge/issue-types.ts</files>
  <action>
Create `src/knowledge/issue-types.ts` following the pattern from `review-comment-types.ts`.

Define these types:

```typescript
/** Input for upserting an issue into the corpus. */
export type IssueInput = {
  repo: string;
  owner: string;
  issueNumber: number;
  title: string;
  body: string | null;
  state: string;
  authorLogin: string;
  authorAssociation: string | null;
  labelNames: string[];
  templateSlug: string | null;
  commentCount: number;
  assignees: Array<{ id: number; login: string }>;
  milestone: string | null;
  reactionCount: number;
  isPullRequest: boolean;
  locked: boolean;
  githubCreatedAt: Date;
  githubUpdatedAt: Date | null;
  closedAt: Date | null;
  embedding?: Float32Array | null;
};

/** Full database row type. */
export type IssueRecord = {
  id: number;
  createdAt: string;
  repo: string;
  owner: string;
  issueNumber: number;
  title: string;
  body: string | null;
  state: string;
  authorLogin: string;
  authorAssociation: string | null;
  labelNames: string[];
  templateSlug: string | null;
  commentCount: number;
  assignees: Array<{ id: number; login: string }>;
  milestone: string | null;
  reactionCount: number;
  isPullRequest: boolean;
  locked: boolean;
  embedding: unknown;
  embeddingModel: string | null;
  githubCreatedAt: string;
  githubUpdatedAt: string | null;
  closedAt: string | null;
};

/** Search result with cosine distance score. */
export type IssueSearchResult = {
  record: IssueRecord;
  distance: number;
};

/** Input for upserting an issue comment. */
export type IssueCommentInput = {
  repo: string;
  issueNumber: number;
  commentGithubId: number;
  authorLogin: string;
  authorAssociation: string | null;
  body: string;
  githubCreatedAt: Date;
  githubUpdatedAt: Date | null;
  embedding?: Float32Array | null;
};

/** Full issue comment database row. */
export type IssueCommentRecord = {
  id: number;
  createdAt: string;
  repo: string;
  issueNumber: number;
  commentGithubId: number;
  authorLogin: string;
  authorAssociation: string | null;
  body: string;
  embedding: unknown;
  embeddingModel: string | null;
  githubCreatedAt: string;
  githubUpdatedAt: string | null;
};

/** Comment search result with cosine distance. */
export type IssueCommentSearchResult = {
  record: IssueCommentRecord;
  distance: number;
};

/** Store interface for issue corpus CRUD and search. */
export type IssueStore = {
  /** Upsert an issue (ON CONFLICT UPDATE). */
  upsert(issue: IssueInput): Promise<void>;

  /** Delete an issue and its comments by repo + issue number. */
  delete(repo: string, issueNumber: number): Promise<void>;

  /** Get a single issue by repo + issue number. */
  getByNumber(repo: string, issueNumber: number): Promise<IssueRecord | null>;

  /** Vector similarity search scoped by repo. */
  searchByEmbedding(params: {
    queryEmbedding: Float32Array;
    repo: string;
    topK: number;
  }): Promise<IssueSearchResult[]>;

  /** Full-text search using tsvector GIN index. */
  searchByFullText(params: {
    query: string;
    repo: string;
    topK: number;
  }): Promise<IssueSearchResult[]>;

  /** Find issues similar to a given issue by its embedding. Excludes the source issue. */
  findSimilar(repo: string, issueNumber: number, threshold?: number): Promise<IssueSearchResult[]>;

  /** Count issues for a repo. */
  countByRepo(repo: string): Promise<number>;

  /** Upsert a single issue comment. */
  upsertComment(comment: IssueCommentInput): Promise<void>;

  /** Delete a comment by repo + GitHub comment ID. */
  deleteComment(repo: string, commentGithubId: number): Promise<void>;

  /** Get all comments for an issue, ordered by creation time. */
  getCommentsByIssue(repo: string, issueNumber: number): Promise<IssueCommentRecord[]>;

  /** Vector similarity search on issue comments. */
  searchCommentsByEmbedding(params: {
    queryEmbedding: Float32Array;
    repo: string;
    topK: number;
  }): Promise<IssueCommentSearchResult[]>;
};
```
  </action>
  <verify>
    <automated>grep -c "export type" src/knowledge/issue-types.ts | grep -qE "^[7-9]$|^[1-9][0-9]" && echo "PASS" || echo "FAIL"</automated>
  </verify>
  <done>issue-types.ts exports IssueStore, IssueRecord, IssueInput, IssueSearchResult, IssueCommentRecord, IssueCommentInput, IssueCommentSearchResult types.</done>
</task>

</tasks>

<verification>
- [ ] `014-issues.sql` creates `issues` table with HNSW + tsvector indexes
- [ ] `014-issues.sql` creates `issue_comments` table with HNSW + tsvector indexes
- [ ] Issues table has all required metadata columns: state, author_association, label_names, template_slug, comment_count
- [ ] tsvector trigger uses weighted search: title (A) + body (B) + labels (C)
- [ ] `014-issues.down.sql` cleanly drops both tables, triggers, and functions
- [ ] `issue-types.ts` defines complete store interface matching ReviewCommentStore pattern
- [ ] `findSimilar` is a first-class method on IssueStore
</verification>

<success_criteria>
Migration 014 can be applied to an existing Kodiai database, creating the issues and issue_comments tables with proper HNSW vector indexes and tsvector GIN indexes. TypeScript types provide a complete contract for the store implementation in Plan 02.
</success_criteria>

<output>
After completion, create `.planning/phases/103-issue-corpus-schema-store/103-01-SUMMARY.md`
</output>
