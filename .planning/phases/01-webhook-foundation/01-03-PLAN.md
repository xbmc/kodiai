---
phase: 01-webhook-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - src/webhook/router.ts
  - src/webhook/filters.ts
  - src/webhook/types.ts
  - src/routes/webhooks.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Events are dispatched to registered handlers by event type and action"
    - "Multiple handlers can be registered for the same event type"
    - "One handler's failure does not prevent other handlers from running"
    - "Events from bot accounts are silently dropped before reaching handlers"
    - "The app's own events are always filtered regardless of allow-list"
    - "Bots on the configurable allow-list pass through the filter"
    - "Unhandled event types are silently dropped with no error"
    - "Webhook processing happens asynchronously (200 returned before handlers complete)"
  artifacts:
    - path: "src/webhook/router.ts"
      provides: "Event handler registry and dispatch with isolated errors"
      exports: ["createEventRouter"]
      min_lines: 40
    - path: "src/webhook/filters.ts"
      provides: "Bot filtering with configurable allow-list and self-event filtering"
      exports: ["createBotFilter"]
      min_lines: 20
  key_links:
    - from: "src/webhook/router.ts"
      to: "src/webhook/filters.ts"
      via: "bot filter applied before handler dispatch"
      pattern: "shouldProcess|botFilter"
    - from: "src/webhook/router.ts"
      to: "src/webhook/types.ts"
      via: "uses EventHandler and WebhookEvent types"
      pattern: "EventHandler|WebhookEvent"
    - from: "src/routes/webhooks.ts"
      to: "src/webhook/router.ts"
      via: "webhook route dispatches to event router"
      pattern: "router\\.dispatch|processEvent"
    - from: "src/webhook/filters.ts"
      to: "src/auth/github-app.ts"
      via: "uses app slug for self-event filtering"
      pattern: "appSlug|getAppSlug"
---

<objective>
Implement the event handler registry with explicit Map-based routing, bot filtering pipeline, and wire the complete webhook processing flow -- from signature verification through bot filtering to isolated handler dispatch.

Purpose: This completes the Phase 1 goal. After this plan, the webhook foundation is fully functional: events arrive, are verified, deduplicated, filtered for bots, and dispatched to registered handlers with isolated error handling. Phase 2+ handlers can simply register via the event router.
Output: A complete event routing system with `register(eventKey, handler)` and `dispatch(event)`, a bot filter that blocks bot accounts (except those on the allow-list) and always blocks self-events, and the full webhook processing pipeline wired end-to-end.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-webhook-foundation/01-RESEARCH.md
@.planning/phases/01-webhook-foundation/01-CONTEXT.md
@.planning/phases/01-webhook-foundation/01-01-SUMMARY.md
@.planning/phases/01-webhook-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bot filter and event router implementation</name>
  <files>
    src/webhook/filters.ts
    src/webhook/router.ts
    src/webhook/types.ts
  </files>
  <action>
    1. Update `src/webhook/types.ts` -- Add/refine types needed for routing:
       - Ensure `WebhookEvent` has: `id: string` (delivery ID), `name: string` (event name), `payload: Record<string, unknown>` (parsed body). Add `installationId: number` field extracted from `payload.installation.id`.
       - Ensure `EventHandler` type is: `(event: WebhookEvent) => Promise<void>`
       - Add `BotFilter` interface: `{ shouldProcess(sender: { type: string; login: string }): boolean }`
       - Add `EventRouter` interface: `{ register(eventKey: string, handler: EventHandler): void; dispatch(event: WebhookEvent): Promise<void> }`

    2. Create `src/webhook/filters.ts` -- Bot filtering pipeline:
       - Export `createBotFilter(appSlug: string, allowList: string[]): BotFilter`
       - The `shouldProcess(sender)` method implements:
         a. Always filter the app's own events: normalize sender login by lowercasing and removing `[bot]` suffix, compare against `appSlug.toLowerCase()`. If match, return false. This is NOT configurable per user decision.
         b. If sender.type is "User" (not a bot), always return true.
         c. If sender is a bot (type !== "User"): check if the normalized login is in the allow-list. Return true only if allowed.
       - Log at debug level when filtering (include sender login and reason).
       - The allow-list comparison should be case-insensitive (normalize both sides).

    3. Create `src/webhook/router.ts` -- Event handler registry and dispatch:
       - Export `createEventRouter(botFilter: BotFilter, logger: Logger): EventRouter`
       - Internal state: `handlers: Map<string, EventHandler[]>` -- maps event keys to arrays of handlers.
       - `register(eventKey, handler)`: Add handler to the array for that key. Create the array if it doesn't exist. The eventKey format is either `"event_name.action"` (e.g., `"pull_request.opened"`) or just `"event_name"` (for events without action or catch-all).
       - `dispatch(event)`:
         a. Extract sender from `event.payload.sender` (if present -- some events like `installation` may not have sender).
         b. If sender exists, run through `botFilter.shouldProcess(sender)`. If filtered, log at debug level and return (silently drop).
         c. Build lookup keys: primary key is `"${event.name}.${event.payload.action}"` (if action exists), fallback key is `"${event.name}"` (no action).
         d. Collect handlers from BOTH the specific key and the event-only key (support both `"pull_request.opened"` AND `"pull_request"` handlers firing for the same event).
         e. If no handlers found for either key, log at debug level "No handlers registered for {key}" and return silently. Do NOT log at warn/error -- silently dropping unhandled events is per user decision.
         f. Run ALL collected handlers via `Promise.allSettled()` -- one handler's failure MUST NOT affect others per user decision.
         g. After allSettled, iterate results: for each "rejected" result, log at error level with the rejection reason, handler name/key, and delivery ID.
         h. Log at info level the count of handlers run and how many succeeded/failed.
  </action>
  <verify>
    - `bunx tsc --noEmit` passes
    - Code review: `Promise.allSettled` is used (not `Promise.all`), bot filter checks sender.type and login, app slug filtering is unconditional
    - The router supports both "event.action" and "event" key formats
  </verify>
  <done>
    - Event router dispatches to correct handlers based on event type + action
    - Multiple handlers per event key are supported
    - Handler errors are isolated via Promise.allSettled -- one failure does not block others
    - Bot accounts are filtered by default, configurable allow-list passes specified bots through
    - App's own events are always filtered regardless of allow-list
    - Unhandled event types are silently dropped with debug-level logging only
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire the complete webhook processing pipeline</name>
  <files>
    src/routes/webhooks.ts
    src/index.ts
  </files>
  <action>
    1. Update `src/index.ts`:
       - Import `createBotFilter` from `src/webhook/filters.ts`
       - Import `createEventRouter` from `src/webhook/router.ts`
       - After `githubApp.initialize()`, create the bot filter: `const botFilter = createBotFilter(githubApp.getAppSlug(), config.botAllowList)`
       - Create the event router: `const eventRouter = createEventRouter(botFilter, logger)`
       - Register a temporary logging handler for all events to verify the pipeline works: `eventRouter.register("*", async (event) => logger.info({ event: event.name, action: event.payload.action }, "Event received"))` -- OR skip the wildcard and just don't register any handlers yet (unhandled events will be silently dropped, which is correct behavior). Choose whichever is cleaner. The point is: Phase 2+ plans will call `eventRouter.register()` to add real handlers.
       - Pass `eventRouter` to `createWebhookRoutes(...)` deps.

    2. Update `src/routes/webhooks.ts`:
       - Add `eventRouter` to the deps type.
       - Replace the placeholder `processEvent` stub with a real flow that calls `eventRouter.dispatch(event)`.
       - The full webhook handler flow (in order):
         a. Extract headers (x-hub-signature-256, x-github-delivery, x-github-event)
         b. Get raw body via `c.req.text()`
         c. Verify signature -- reject with 401 if invalid/missing (already implemented in Plan 01)
         d. Check deduplication -- skip with 200 if duplicate (already implemented in Plan 01)
         e. Parse JSON body
         f. Construct `WebhookEvent` object: `{ id: deliveryId, name: eventName, payload: parsedBody, installationId: parsedBody?.installation?.id }`
         g. Fire-and-fork: `Promise.resolve().then(() => eventRouter.dispatch(event)).catch(err => logger.error({ err, deliveryId }, "Event dispatch failed"))` -- do NOT await.
         h. Return 200 immediately.
       - Make sure the fire-and-fork does NOT use `await`. The 200 response must be returned to GitHub within milliseconds.

    3. Verify the full pipeline works end-to-end:
       - The flow is: HTTP POST -> signature verify -> dedup check -> parse -> bot filter -> handler lookup -> dispatch with isolated errors -> response already sent.
  </action>
  <verify>
    - `bunx tsc --noEmit` passes
    - Start the server and send a test webhook with valid signature: verify the event flows through bot filter and router (check logs)
    - Send an event with `sender.type: "Bot"` and `sender.login: "some-bot[bot]"`: verify it is filtered (debug log, no handler execution)
    - Send an event with no registered handler: verify it is silently dropped (debug log only, no error)
    - Send two events with the same X-GitHub-Delivery: verify the second is deduplicated
    - Kill the server process after testing
  </verify>
  <done>
    - Complete webhook pipeline wired: signature verify -> dedup -> parse -> bot filter -> dispatch
    - Event router receives events and dispatches to registered handlers
    - Bot filtering runs before handler dispatch
    - Fire-and-fork pattern ensures 200 is returned immediately
    - Unhandled events silently dropped
    - Pipeline is ready for Phase 2+ to register real handlers via eventRouter.register()
  </done>
</task>

</tasks>

<verification>
Full Phase 1 verification (all plans combined):

1. **INFRA-01**: POST /webhooks/github receives GitHub webhook events -- VERIFIED by sending test POST
2. **INFRA-02**: Server verifies HMAC-SHA256 signatures -- VERIFIED by testing valid/invalid signatures
3. **INFRA-03**: GitHub App authenticates via JWT and mints installation tokens -- VERIFIED by startup log showing app slug and getInstallationOctokit availability
4. **INFRA-04**: Events processed asynchronously (acknowledge-then-process) -- VERIFIED by 200 returned before handler completion
5. **INFRA-06**: Bot ignores its own comments and bot accounts -- VERIFIED by sending event with bot sender
6. **INFRA-07**: Event router classifies webhooks and dispatches to handlers -- VERIFIED by registering test handler and sending matching event
7. **INFRA-08**: Health endpoint returns 200 -- VERIFIED by curling /health

Additional verifications:
- Delivery deduplication works (same X-GitHub-Delivery rejected)
- Readiness probe checks GitHub API connectivity
- All logging is structured JSON
- Config validation crashes on missing secrets
- Handler errors are isolated (Promise.allSettled)
- Bot allow-list permits specified bots through
</verification>

<success_criteria>
- Complete webhook event processing pipeline: receive -> verify -> dedup -> parse -> filter -> dispatch
- Event router supports registration of handlers by event type + action
- Multiple handlers per event, errors isolated via Promise.allSettled
- Bot filtering blocks all bot accounts except those on allow-list
- Self-event filtering always active (app's own slug)
- All Phase 1 requirements (INFRA-01 through INFRA-08 minus INFRA-05) satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/01-webhook-foundation/01-03-SUMMARY.md`
</output>
