---
phase: 01-webhook-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/auth/github-app.ts
  - src/routes/health.ts
  - src/index.ts
autonomous: true
user_setup:
  - service: github-app
    why: "GitHub App authentication requires registered app credentials"
    env_vars:
      - name: GITHUB_APP_ID
        source: "GitHub Settings -> Developer settings -> GitHub Apps -> Your App -> App ID"
      - name: GITHUB_PRIVATE_KEY
        source: "GitHub Settings -> Developer settings -> GitHub Apps -> Your App -> Generate a private key (downloads .pem file)"
      - name: GITHUB_WEBHOOK_SECRET
        source: "Set during GitHub App creation (Webhook secret field)"

must_haves:
  truths:
    - "The server authenticates as a GitHub App using JWT signed with the private key"
    - "Installation access tokens are minted per installation ID and cached in memory"
    - "Cached tokens are refreshed before expiry (no stale token errors)"
    - "GET /readiness checks GitHub API connectivity and returns 503 when unreachable"
    - "The app slug is fetched at startup and available for bot self-filtering"
  artifacts:
    - path: "src/auth/github-app.ts"
      provides: "GitHub App JWT auth and installation token management"
      exports: ["createGitHubApp"]
      min_lines: 40
  key_links:
    - from: "src/auth/github-app.ts"
      to: "@octokit/auth-app"
      via: "createAppAuth for JWT and installation token management"
      pattern: "createAppAuth"
    - from: "src/auth/github-app.ts"
      to: "@octokit/rest"
      via: "Octokit client with app auth strategy for API calls"
      pattern: "new Octokit"
    - from: "src/routes/health.ts"
      to: "src/auth/github-app.ts"
      via: "readiness probe calls checkConnectivity"
      pattern: "checkConnectivity"
    - from: "src/index.ts"
      to: "src/auth/github-app.ts"
      via: "createGitHubApp called at startup, app slug fetched"
      pattern: "createGitHubApp"
---

<objective>
Implement GitHub App authentication -- JWT signing, installation access token management with caching, app slug discovery at startup, and a real readiness probe that checks GitHub API connectivity.

Purpose: The auth module is the bridge between receiving webhooks and acting on them. Without it, the server can verify signatures but cannot make API calls (post comments, fetch PRs, etc.). The app slug is also needed for bot self-filtering in Plan 03.
Output: A GitHubApp service with `getInstallationOctokit(installationId)` for repo-level API calls, `getAppSlug()` for self-filtering, `checkConnectivity()` for readiness probes, and a wired-up /readiness endpoint.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-webhook-foundation/01-RESEARCH.md
@.planning/phases/01-webhook-foundation/01-CONTEXT.md
@.planning/phases/01-webhook-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: GitHub App auth module with JWT, installation tokens, and app slug</name>
  <files>
    src/auth/github-app.ts
  </files>
  <action>
    Create `src/auth/github-app.ts` implementing the full GitHub App authentication module:

    1. Export `createGitHubApp(config, logger)` factory function that returns an object with:

       a. `getInstallationOctokit(installationId: number): Promise<Octokit>` -- Creates an Octokit REST client authenticated with an installation access token. Use `@octokit/auth-app`'s `createAppAuth` as the `authStrategy` for the Octokit constructor, passing `appId`, `privateKey`, and `installationId`. The auth-app library handles token caching internally (caches up to 15K tokens, auto-refreshes before expiry ~1 hour TTL). Do NOT build a custom cache -- rely on auth-app's built-in caching per user decision "Cache installation access tokens in memory with TTL-based refresh before expiry". The cache is keyed by installation ID automatically by auth-app.

       b. `getAppSlug(): string` -- Returns the cached app slug (login name without [bot] suffix). This is set during `initialize()`.

       c. `initialize(): Promise<void>` -- Called once at startup. Creates an app-level Octokit (auth type "app", not "installation"), calls `octokit.rest.apps.getAuthenticated()`, and caches the response's `slug` field. This also serves as a startup connectivity check -- if it fails, the server should crash (fail-fast). Log the app slug at info level: "GitHub App authenticated as {slug}".

       d. `checkConnectivity(): Promise<boolean>` -- Calls `octokit.rest.apps.getAuthenticated()` with an app-level JWT. Returns true if successful, false on any error. Cache the result for 30 seconds to avoid rate limiting from frequent Azure readiness probes (Azure probes every 10-30 seconds). Use a simple `lastCheck` timestamp + `lastResult` boolean pattern.

    2. Types:
       - Define `GitHubApp` interface for the return type with all four methods above.
       - Accept config with `githubAppId` and `githubPrivateKey` fields (from the config loaded in Plan 01).

    3. Important implementation details:
       - Private key newline handling: `@octokit/auth-app` handles escaped `\n` replacement automatically -- do not pre-process the key.
       - For `getInstallationOctokit`, create a NEW Octokit instance each time (the auth-app strategy inside handles token caching transparently, but the Octokit instance itself should be fresh to avoid stale state).
       - Log at debug level when creating installation tokens (to avoid noise but enable troubleshooting).
  </action>
  <verify>
    - `bunx tsc --noEmit` passes with no type errors
    - The module exports `createGitHubApp` and `GitHubApp` type
    - Code review: `createAppAuth` is used (not manual JWT signing), `getAuthenticated()` is called in `initialize()`, connectivity check has 30-second cache
  </verify>
  <done>
    - GitHubApp module provides installation-scoped Octokit clients via `getInstallationOctokit(installationId)`
    - App slug is discovered at startup via `initialize()` and available via `getAppSlug()`
    - Connectivity check caches results for 30 seconds
    - No hand-rolled JWT or token caching -- all delegated to @octokit/auth-app
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire auth into server startup and readiness probe</name>
  <files>
    src/routes/health.ts
    src/index.ts
  </files>
  <action>
    1. Update `src/index.ts`:
       - Import `createGitHubApp` from `src/auth/github-app.ts`
       - After loading config and creating logger, create the GitHubApp instance: `const githubApp = createGitHubApp(config, logger)`
       - Call `await githubApp.initialize()` BEFORE starting the server. If this fails, the process crashes (fail-fast). This validates that the GitHub App credentials are correct and fetches the app slug.
       - Log: `"GitHub App initialized"` with the app slug at info level.
       - Pass `githubApp` to `createHealthRoutes(...)` deps.
       - Pass `githubApp` to `createWebhookRoutes(...)` deps (it will be needed in Plan 03 for bot filtering, but include it in the deps now to avoid re-wiring later).
       - Since `initialize()` is async, wrap the startup in an async IIFE or top-level await (Bun supports top-level await). The Bun.serve export pattern with `export default { port, fetch }` is synchronous, so initialize before the export. Use the pattern:
         ```
         const config = loadConfig();
         const logger = createLogger();
         const githubApp = createGitHubApp(config, logger);
         await githubApp.initialize();
         // ... create app, mount routes
         export default { port: config.port, fetch: app.fetch };
         ```

    2. Update `src/routes/health.ts`:
       - Add `githubApp` to the deps parameter type.
       - Replace the placeholder `GET /readiness` handler with a real implementation:
         - Call `githubApp.checkConnectivity()`
         - If true: return `{ status: "ready" }` with 200
         - If false: log at warn level "Readiness check failed: GitHub API unreachable", return `{ status: "not ready", reason: "GitHub API unreachable" }` with 503
       - Keep `GET /health` unchanged (always returns 200).
  </action>
  <verify>
    - `bunx tsc --noEmit` passes
    - Start server with valid GitHub App credentials (if available): server logs "GitHub App authenticated as {slug}" and starts
    - Start server with invalid credentials: server crashes with error (fail-fast)
    - `curl http://localhost:3000/health` returns 200
    - `curl http://localhost:3000/readiness` returns 200 (if GitHub API reachable) or 503 (if not)
    - The readiness endpoint does NOT make a new API call on every request (30-second cache)
  </verify>
  <done>
    - Server initializes GitHub App auth at startup and crashes if credentials are invalid
    - App slug is logged at startup
    - GET /readiness performs a real GitHub API connectivity check with 30-second caching
    - GitHubApp instance is passed to both webhook and health route factories
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles cleanly: `bunx tsc --noEmit`
2. Server startup calls `githubApp.initialize()` and logs the app slug
3. Invalid credentials cause immediate crash with clear error
4. GET /readiness checks GitHub API connectivity (not just returning static 200)
5. `getInstallationOctokit(installationId)` returns an authenticated Octokit instance
6. No hand-rolled JWT signing or token caching in the codebase
</verification>

<success_criteria>
- GitHub App authenticates via JWT using @octokit/auth-app
- Installation access tokens can be minted for any installation ID with built-in caching
- App slug is discovered at startup for use in bot self-filtering (Plan 03)
- Readiness probe checks real GitHub API connectivity with 30-second result caching
- Server fails fast on invalid credentials
</success_criteria>

<output>
After completion, create `.planning/phases/01-webhook-foundation/01-02-SUMMARY.md`
</output>
