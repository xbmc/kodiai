---
phase: 01-webhook-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - src/index.ts
  - src/config.ts
  - src/lib/logger.ts
  - src/routes/webhooks.ts
  - src/routes/health.ts
  - src/webhook/verify.ts
  - src/webhook/dedup.ts
  - src/webhook/types.ts
  - .env.example
autonomous: true

must_haves:
  truths:
    - "POST /webhooks/github with valid HMAC-SHA256 signature returns 200"
    - "POST /webhooks/github with invalid or missing signature returns 401"
    - "Duplicate deliveries (same X-GitHub-Delivery) are detected and skipped"
    - "GET /health returns 200 with {status: ok}"
    - "Server crashes on startup if GITHUB_APP_ID, GITHUB_PRIVATE_KEY, or GITHUB_WEBHOOK_SECRET is missing"
    - "All log output is structured JSON to stdout (no pretty-print)"
  artifacts:
    - path: "package.json"
      provides: "Project dependencies and scripts"
      contains: "hono"
    - path: "src/index.ts"
      provides: "Server entry point with fail-fast config"
      exports: ["default"]
    - path: "src/config.ts"
      provides: "Zod-validated config from env vars"
      exports: ["loadConfig"]
    - path: "src/lib/logger.ts"
      provides: "pino JSON logger factory"
      exports: ["createLogger"]
    - path: "src/routes/webhooks.ts"
      provides: "POST /webhooks/github route"
      exports: ["createWebhookRoutes"]
    - path: "src/routes/health.ts"
      provides: "GET /health and GET /readiness routes"
      exports: ["createHealthRoutes"]
    - path: "src/webhook/verify.ts"
      provides: "HMAC-SHA256 signature verification"
      exports: ["verifyWebhookSignature"]
    - path: "src/webhook/dedup.ts"
      provides: "Delivery ID deduplication"
      exports: ["createDeduplicator"]
    - path: "src/webhook/types.ts"
      provides: "Webhook event types and handler interfaces"
  key_links:
    - from: "src/index.ts"
      to: "src/config.ts"
      via: "loadConfig() call at startup"
      pattern: "loadConfig"
    - from: "src/index.ts"
      to: "src/routes/webhooks.ts"
      via: "app.route() mount"
      pattern: "app\\.route.*webhooks"
    - from: "src/routes/webhooks.ts"
      to: "src/webhook/verify.ts"
      via: "signature verification before processing"
      pattern: "verifyWebhookSignature"
    - from: "src/routes/webhooks.ts"
      to: "src/webhook/dedup.ts"
      via: "delivery ID check after verification"
      pattern: "isDuplicate|dedup"
---

<objective>
Initialize the Kodiai project, create the Hono HTTP server, implement webhook signature verification, delivery deduplication, health/readiness endpoints, and fail-fast configuration validation.

Purpose: Establish the foundation that all subsequent plans build on -- a running HTTP server that can receive GitHub webhooks, verify their authenticity, and reject invalid/duplicate requests.
Output: A working Bun + Hono server with POST /webhooks/github (signature verified, deduplicated), GET /health, GET /readiness endpoints, structured JSON logging via pino, and Zod-validated config that crashes on missing secrets.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-webhook-foundation/01-RESEARCH.md
@.planning/phases/01-webhook-foundation/01-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Project initialization, config, and logger</name>
  <files>
    package.json
    tsconfig.json
    src/config.ts
    src/lib/logger.ts
    src/webhook/types.ts
    .env.example
  </files>
  <action>
    1. Initialize the Bun project:
       - `bun init` to create package.json and tsconfig.json
       - Set `"name": "kodiai"` in package.json
       - Add scripts: `"dev": "bun run --watch src/index.ts"`, `"start": "bun run src/index.ts"`
       - Install dependencies: `bun add hono @octokit/auth-app @octokit/webhooks-methods @octokit/rest pino zod`
       - Install dev dependencies: `bun add -d @octokit/webhooks-types @types/bun`

    2. Create `src/config.ts` -- Fail-fast config validation using Zod:
       - Define a Zod schema for: githubAppId (string, required), githubPrivateKey (string, required), webhookSecret (string, required), port (number, default 3000), logLevel (string, default "info"), botAllowList (comma-separated string transformed to string array, default empty)
       - Create `loadPrivateKey()` function that supports: inline PEM (starts with "-----BEGIN"), file path (starts with "/" or "./") read via `Bun.file().text()`, or base64-encoded string (decode with atob). Throw with clear error message if GITHUB_PRIVATE_KEY env var is missing.
       - `loadConfig()` calls `loadPrivateKey()`, parses all env vars through Zod schema, and if validation fails: logs each issue to stderr and calls `process.exit(1)`. Export the config type using `z.infer`.
       - Create `.env.example` with all env vars documented (GITHUB_APP_ID, GITHUB_PRIVATE_KEY, GITHUB_WEBHOOK_SECRET, PORT, LOG_LEVEL, BOT_ALLOW_LIST)

    3. Create `src/lib/logger.ts` -- pino logger factory:
       - Export `createLogger()` that returns a pino instance with level from LOG_LEVEL env (default "info"). No transports, no pretty-print -- JSON to stdout only per user decision.
       - Export `createChildLogger(logger, context)` for request-scoped loggers (child logger with deliveryId, eventName).

    4. Create `src/webhook/types.ts` -- Shared types for the webhook system:
       - `WebhookEvent` interface: `{ id: string; name: string; payload: Record<string, unknown> }`
       - `EventHandler` type: `(event: WebhookEvent) => Promise<void>`
       - `AppConfig` type: exported from config.ts via z.infer (re-export or use directly)
       - Import and re-export relevant types from `@octokit/webhooks-types` as needed.
  </action>
  <verify>
    - `bun run src/config.ts` with no env vars set should exit with non-zero code and print missing var errors
    - `GITHUB_APP_ID=test GITHUB_PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----\ntest\n-----END RSA PRIVATE KEY-----" GITHUB_WEBHOOK_SECRET=secret bun run -e "import { loadConfig } from './src/config'; console.log(JSON.stringify(loadConfig()))"` should output valid JSON config
    - `bun run -e "import { createLogger } from './src/lib/logger'; const l = createLogger(); l.info({test: true}, 'hello')"` should output a single JSON line to stdout
    - TypeScript compiles without errors: `bunx tsc --noEmit`
  </verify>
  <done>
    - package.json has all required dependencies installed
    - Config validation crashes with clear messages when env vars are missing
    - Config loads successfully when all required vars are set (including PEM and file path modes for private key)
    - Logger outputs structured JSON to stdout with no pretty-printing
    - Shared webhook types are defined and importable
  </done>
</task>

<task type="auto">
  <name>Task 2: HTTP server, webhook endpoint, signature verification, and dedup</name>
  <files>
    src/index.ts
    src/routes/webhooks.ts
    src/routes/health.ts
    src/webhook/verify.ts
    src/webhook/dedup.ts
  </files>
  <action>
    1. Create `src/webhook/verify.ts` -- Signature verification wrapper:
       - Import `verify` from `@octokit/webhooks-methods`
       - Export `verifyWebhookSignature(secret: string, payload: string, signature: string): Promise<boolean>` that wraps the octokit verify function in a try/catch, returning false on any error.
       - Do NOT hand-roll HMAC -- use @octokit/webhooks-methods which handles timing-safe comparison and sha256= prefix.

    2. Create `src/webhook/dedup.ts` -- Delivery ID deduplication:
       - Export `createDeduplicator()` factory that returns `{ isDuplicate(deliveryId: string): boolean }`.
       - Use a plain `Map<string, number>` internally (delivery ID -> timestamp).
       - `isDuplicate` returns true if the ID is already in the map. If not, adds it with `Date.now()`.
       - Every 1000 inserts, run cleanup: evict entries older than 24 hours.
       - Export the factory, not a singleton -- allows testing and prevents module-level side effects.

    3. Create `src/routes/health.ts`:
       - Export `createHealthRoutes(deps)` that returns a Hono app with:
         - `GET /health` -- always returns `{ status: "ok" }` as JSON with 200. This is the liveness probe.
         - `GET /readiness` -- placeholder that returns `{ status: "ready" }` for now. Plan 02 will wire this to check GitHub API connectivity. Add a TODO comment noting this.

    4. Create `src/routes/webhooks.ts`:
       - Export `createWebhookRoutes(deps)` where deps include config, logger, and a deduplicator instance.
       - Implement `POST /github` (mounted under `/webhooks` prefix in index.ts, so full path is `/webhooks/github`):
         a. Extract headers: `x-hub-signature-256`, `x-github-delivery`, `x-github-event`
         b. Get raw body with `c.req.text()` -- CRITICAL: get raw text BEFORE any JSON parsing
         c. Validate signature using `verifyWebhookSignature`. If missing or invalid, log at warn level with deliveryId and return 401.
         d. Check deduplication. If duplicate, log at info level and return 200.
         e. Parse body with `JSON.parse(body)`
         f. Fire-and-fork: `Promise.resolve().then(() => processEvent(...)).catch(err => logger.error(...))` -- do NOT await. The processEvent function is a placeholder stub for now that just logs the event name and action. Plan 03 will replace this with the real event router dispatch.
         g. Return 200 immediately (empty body or `{ received: true }`).
       - Log signature verification failures at warn/error severity per user decision.

    5. Create `src/index.ts` -- Server entry point:
       - Import and call `loadConfig()` at the top level (fail-fast).
       - Create logger via `createLogger()`.
       - Create deduplicator via `createDeduplicator()`.
       - Create Hono app.
       - Mount routes: `app.route("/webhooks", createWebhookRoutes({...}))`, `app.route("/", createHealthRoutes({...}))`.
       - Add global error handler via `app.onError()` that logs the error and returns 500.
       - Export default `{ port: config.port, fetch: app.fetch }` (Bun.serve pattern).
       - Log startup message with port number.
  </action>
  <verify>
    - Start the server: `GITHUB_APP_ID=123 GITHUB_PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----\nfake\n-----END RSA PRIVATE KEY-----" GITHUB_WEBHOOK_SECRET=testsecret bun run src/index.ts &`
    - Health check: `curl -s http://localhost:3000/health` returns `{"status":"ok"}` with 200
    - Readiness check: `curl -s http://localhost:3000/readiness` returns `{"status":"ready"}` with 200
    - Webhook with no signature: `curl -s -o /dev/null -w "%{http_code}" -X POST http://localhost:3000/webhooks/github -H "Content-Type: application/json" -d '{}'` returns 401
    - Webhook with valid signature (generate using: `echo -n '{"action":"opened"}' | openssl dgst -sha256 -hmac testsecret` and use result as x-hub-signature-256 header with sha256= prefix): returns 200
    - Sending the same X-GitHub-Delivery twice logs "Duplicate delivery skipped" on second request
    - All log lines are JSON (no plain text output)
    - `bunx tsc --noEmit` passes
  </verify>
  <done>
    - Server starts on configured port and logs startup message as JSON
    - GET /health returns 200 with JSON status
    - GET /readiness returns 200 (placeholder, will be enhanced in Plan 02)
    - POST /webhooks/github with valid HMAC-SHA256 signature returns 200
    - POST /webhooks/github with invalid/missing signature returns 401 and logs warning
    - Duplicate X-GitHub-Delivery values are detected and skipped
    - Event processing is fire-and-forget (200 returned before processing completes)
    - Server exits immediately with clear error if env vars are missing
  </done>
</task>

</tasks>

<verification>
1. Server starts successfully with required env vars set
2. Server crashes with clear error when any required env var is missing
3. `curl http://localhost:3000/health` returns 200
4. Valid webhook request returns 200, invalid signature returns 401
5. Duplicate delivery IDs are detected
6. All stdout output is JSON (pipe output through `python3 -c "import sys,json; [json.loads(l) for l in sys.stdin]"` to confirm)
7. TypeScript compiles cleanly: `bunx tsc --noEmit`
</verification>

<success_criteria>
- A running Hono HTTP server on Bun that receives webhook POSTs, verifies HMAC-SHA256 signatures, deduplicates deliveries, and responds within milliseconds
- Health and readiness endpoints functional
- Fail-fast config validation operational
- Structured JSON logging via pino with no pretty-print mode
- Clean TypeScript with no type errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-webhook-foundation/01-01-SUMMARY.md`
</output>
