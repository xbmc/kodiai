---
phase: 23-telemetry-foundation
plan: 03
type: execute
wave: 2
depends_on: ["23-01", "23-02"]
files_modified:
  - src/index.ts
  - src/handlers/review.ts
  - src/handlers/mention.ts
  - Dockerfile
autonomous: true

must_haves:
  truths:
    - "After a PR review completes, a telemetry row exists in SQLite with deliveryId, repo, prNumber, eventType, model, inputTokens, outputTokens, costUsd, and durationMs"
    - "After a mention execution completes, the same telemetry fields are recorded with a different eventType"
    - "Telemetry writes do not delay the next queued job -- a failed write never blocks the critical path"
    - "Rows older than 90 days are automatically deleted on startup"
    - "The SQLite database uses WAL mode and can be read by an external process while the server is running"
    - "Dockerfile creates /app/data directory with correct ownership before USER bun"
  artifacts:
    - path: "src/index.ts"
      provides: "TelemetryStore initialization, startup purge and checkpoint, injection into handlers"
      contains: "createTelemetryStore"
    - path: "src/handlers/review.ts"
      provides: "Fire-and-forget telemetry capture after review execution"
      contains: "telemetryStore.record"
    - path: "src/handlers/mention.ts"
      provides: "Fire-and-forget telemetry capture after mention execution"
      contains: "telemetryStore.record"
    - path: "Dockerfile"
      provides: "Data directory for SQLite database"
      contains: "mkdir.*data"
  key_links:
    - from: "src/index.ts"
      to: "src/telemetry/store.ts"
      via: "createTelemetryStore import and initialization"
      pattern: "createTelemetryStore"
    - from: "src/handlers/review.ts"
      to: "src/telemetry/types.ts"
      via: "TelemetryStore type in deps"
      pattern: "telemetryStore"
    - from: "src/handlers/mention.ts"
      to: "src/telemetry/types.ts"
      via: "TelemetryStore type in deps"
      pattern: "telemetryStore"
    - from: "src/index.ts"
      to: "src/handlers/review.ts"
      via: "telemetryStore passed in deps object"
      pattern: "telemetryStore"
---

<objective>
Wire the TelemetryStore into the server startup and both handlers so every execution is recorded to SQLite, with fire-and-forget semantics ensuring telemetry never blocks the critical path.

Purpose: TELEM-03 (handlers capture telemetry), TELEM-05 (non-blocking writes), plus startup purge (TELEM-07) and Dockerfile data directory. This completes the telemetry pipeline: SDK data -> ExecutionResult -> handler -> TelemetryStore -> SQLite.
Output: Fully wired telemetry capture for review and mention executions.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-telemetry-foundation/23-RESEARCH.md
@.planning/phases/23-telemetry-foundation/23-01-SUMMARY.md
@.planning/phases/23-telemetry-foundation/23-02-SUMMARY.md
@src/index.ts
@src/handlers/review.ts
@src/handlers/mention.ts
@src/execution/types.ts
@Dockerfile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize TelemetryStore in server startup and update Dockerfile</name>
  <files>src/index.ts, Dockerfile</files>
  <action>
    **src/index.ts changes:**

    1. Add import at the top: `import { createTelemetryStore } from "./telemetry/store.ts";`

    2. After the `workspaceManager.cleanupStale()` block and before the event processing pipeline section, add TelemetryStore initialization:

    ```typescript
    // Telemetry storage (SQLite with WAL mode)
    const telemetryDbPath = process.env.TELEMETRY_DB_PATH ?? "./data/kodiai-telemetry.db";
    const telemetryStore = createTelemetryStore({ dbPath: telemetryDbPath, logger });

    // Startup maintenance: purge old rows (TELEM-07) and checkpoint WAL (TELEM-08)
    const purgedCount = telemetryStore.purgeOlderThan(90);
    if (purgedCount > 0) {
      logger.info({ purgedCount }, "Telemetry retention purge complete");
    }
    telemetryStore.checkpoint();
    ```

    3. Pass `telemetryStore` to both handler factory calls:

    ```typescript
    createReviewHandler({
      eventRouter,
      jobQueue,
      workspaceManager,
      githubApp,
      executor,
      telemetryStore,  // <-- add this
      logger,
    });
    createMentionHandler({
      eventRouter,
      jobQueue,
      workspaceManager,
      githubApp,
      executor,
      telemetryStore,  // <-- add this
      logger,
    });
    ```

    **Dockerfile changes:**

    Add a line BEFORE `USER bun` to create the data directory and set ownership:

    ```dockerfile
    # Create data directory for telemetry SQLite database
    RUN mkdir -p /app/data && chown bun:bun /app/data
    ```

    This goes after the `COPY src/ ./src/` line and before `USER bun`.
  </action>
  <verify>`bunx tsc --noEmit` passes. Dockerfile syntax valid: `docker build --check .` (or just verify the RUN line is syntactically correct by reading the file). The new import resolves to the store module created in Plan 01.</verify>
  <done>TelemetryStore is initialized at startup with configurable path, 90-day purge runs on boot, WAL checkpoint runs on boot, store is passed to both handlers. Dockerfile creates /app/data with bun ownership.</done>
</task>

<task type="auto">
  <name>Task 2: Add fire-and-forget telemetry capture to review and mention handlers</name>
  <files>src/handlers/review.ts, src/handlers/mention.ts</files>
  <action>
    **Both handlers need two changes: (a) accept telemetryStore in deps, (b) call record() after executor.execute().**

    **src/handlers/review.ts:**

    1. Add `TelemetryStore` to the deps type. Import it: `import type { TelemetryStore } from "../telemetry/types.ts";`
    2. Add `telemetryStore: TelemetryStore` to the `createReviewHandler(deps)` parameter type.
    3. Destructure `telemetryStore` from deps.
    4. After the `executor.execute()` call and the existing `logger.info("Review execution completed")` log (around line 479), add fire-and-forget telemetry:

    ```typescript
    // Fire-and-forget telemetry capture (TELEM-03, TELEM-05)
    try {
      telemetryStore.record({
        deliveryId: event.id,
        repo: `${apiOwner}/${apiRepo}`,
        prNumber: pr.number,
        eventType: `pull_request.${payload.action}`,
        model: result.model,
        inputTokens: result.inputTokens,
        outputTokens: result.outputTokens,
        cacheReadTokens: result.cacheReadTokens,
        cacheCreationTokens: result.cacheCreationTokens,
        durationMs: result.durationMs,
        costUsd: result.costUsd,
        conclusion: result.conclusion,
        sessionId: result.sessionId,
        numTurns: result.numTurns,
        stopReason: result.stopReason,
      });
    } catch (err) {
      logger.warn({ err }, "Telemetry write failed (non-blocking)");
    }
    ```

    Place this AFTER the logger.info for "Review execution completed" but BEFORE the error comment posting (`if (result.conclusion === "error")`). This ensures telemetry is recorded for ALL outcomes (success, failure, error) -- even errors should be tracked.

    **src/handlers/mention.ts:**

    1. Same import: `import type { TelemetryStore } from "../telemetry/types.ts";`
    2. Add `telemetryStore: TelemetryStore` to `createMentionHandler(deps)` parameter type.
    3. Destructure `telemetryStore` from deps.
    4. After the `executor.execute()` call and the existing `logger.info("Mention execution completed")` log (around line 692), add the same fire-and-forget block:

    ```typescript
    // Fire-and-forget telemetry capture (TELEM-03, TELEM-05)
    try {
      telemetryStore.record({
        deliveryId: event.id,
        repo: `${mention.owner}/${mention.repo}`,
        prNumber: mention.prNumber,
        eventType: `${event.name}.${action ?? ""}`.replace(/\.$/, ""),
        model: result.model,
        inputTokens: result.inputTokens,
        outputTokens: result.outputTokens,
        cacheReadTokens: result.cacheReadTokens,
        cacheCreationTokens: result.cacheCreationTokens,
        durationMs: result.durationMs,
        costUsd: result.costUsd,
        conclusion: result.conclusion,
        sessionId: result.sessionId,
        numTurns: result.numTurns,
        stopReason: result.stopReason,
      });
    } catch (err) {
      logger.warn({ err }, "Telemetry write failed (non-blocking)");
    }
    ```

    Place this AFTER the "Mention execution completed" log and BEFORE the write-mode section (`if (writeEnabled && ...)`).

    CRITICAL: The telemetry record() call MUST be inside its own try-catch, separate from the handler's main try-catch. A telemetry failure must NEVER cause the handler to fail or skip error reporting. This is TELEM-05 (non-blocking).
  </action>
  <verify>`bunx tsc --noEmit` passes. `bun test` passes (existing handler tests should still pass since telemetryStore is a new dep -- may need to provide a mock in test fixtures. If handler tests construct the handler directly, add a no-op telemetryStore mock: `{ record: () => {}, purgeOlderThan: () => 0, checkpoint: () => {}, close: () => {} }`). Grep to confirm: `grep -n "telemetryStore.record" src/handlers/review.ts src/handlers/mention.ts` shows capture in both files.</verify>
  <done>Both review.ts and mention.ts record telemetry after every execution. Writes are fire-and-forget (try-catch isolated). All TELEM-04 fields are populated from ExecutionResult. Existing handler tests pass with mock telemetryStore.</done>
</task>

</tasks>

<verification>
- `bunx tsc --noEmit` compiles cleanly across entire project
- `bun test` -- all tests pass (including handler tests with telemetryStore mock)
- `grep -rn "telemetryStore" src/index.ts src/handlers/review.ts src/handlers/mention.ts` confirms wiring in all three files
- Dockerfile has `mkdir -p /app/data && chown bun:bun /app/data` before `USER bun`
- Telemetry capture is inside isolated try-catch in both handlers (non-blocking)
</verification>

<success_criteria>
- TelemetryStore initialized at server startup with configurable DB path
- 90-day purge runs on startup
- WAL checkpoint runs on startup
- Review handler records telemetry for every execution (success, failure, error)
- Mention handler records telemetry for every execution (success, failure, error)
- Telemetry failures logged as warnings, never thrown
- Dockerfile creates data directory with correct ownership
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/23-telemetry-foundation/23-03-SUMMARY.md`
</output>
