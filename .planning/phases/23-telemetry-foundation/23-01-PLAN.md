---
phase: 23-telemetry-foundation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/telemetry/types.ts
  - src/telemetry/store.ts
  - src/telemetry/store.test.ts
autonomous: true

must_haves:
  truths:
    - "TelemetryStore.record() inserts a row into the executions table with all TELEM-04 fields"
    - "TelemetryStore.purgeOlderThan(90) deletes rows older than 90 days and returns the count"
    - "TelemetryStore.checkpoint() runs WAL checkpoint without error"
    - "Database uses WAL mode after initialization"
    - "Auto-checkpoint triggers after 1000 writes"
    - "Indexes exist on created_at and repo columns"
  artifacts:
    - path: "src/telemetry/types.ts"
      provides: "TelemetryRecord type and TelemetryStore interface"
      exports: ["TelemetryRecord", "TelemetryStore"]
    - path: "src/telemetry/store.ts"
      provides: "createTelemetryStore factory function"
      exports: ["createTelemetryStore"]
    - path: "src/telemetry/store.test.ts"
      provides: "Tests for TelemetryStore"
      min_lines: 80
  key_links:
    - from: "src/telemetry/store.ts"
      to: "bun:sqlite"
      via: "Database constructor"
      pattern: "new Database"
    - from: "src/telemetry/store.ts"
      to: "src/telemetry/types.ts"
      via: "TelemetryRecord import"
      pattern: "import.*TelemetryRecord.*from.*types"
---

<objective>
Create the TelemetryStore module with SQLite-backed persistent storage for execution telemetry, using TDD to ensure correctness of insert, purge, and checkpoint operations.

Purpose: TELEM-02 (storage layer exists), TELEM-04 (record schema), TELEM-06 (WAL mode), TELEM-07 (90-day retention), TELEM-08 (WAL checkpoint on startup + every 1000 writes). This is the foundation that handlers will write to in Plan 03.
Output: Working, tested TelemetryStore with all storage requirements satisfied.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-telemetry-foundation/23-RESEARCH.md
</context>

<feature>
  <name>TelemetryStore - SQLite execution telemetry storage</name>
  <files>src/telemetry/types.ts, src/telemetry/store.ts, src/telemetry/store.test.ts</files>
  <behavior>
    TelemetryStore is created via `createTelemetryStore({ dbPath, logger })` factory function.

    Types (src/telemetry/types.ts):
    - TelemetryRecord: { deliveryId?: string, repo: string, prNumber?: number, eventType: string, provider?: string, model: string, inputTokens?: number, outputTokens?: number, cacheReadTokens?: number, cacheCreationTokens?: number, durationMs?: number, costUsd?: number, conclusion: string, sessionId?: string, numTurns?: number, stopReason?: string }
    - TelemetryStore interface: { record(entry: TelemetryRecord): void, purgeOlderThan(days: number): number, checkpoint(): void, close(): void }

    Store (src/telemetry/store.ts):
    - Uses `bun:sqlite` (built-in, zero dependencies). Import: `import { Database } from "bun:sqlite"`
    - On creation: opens DB at dbPath with `{ create: true }`, runs PRAGMAs: `journal_mode = WAL`, `synchronous = NORMAL`, `busy_timeout = 5000`
    - Creates `executions` table IF NOT EXISTS with columns: id (INTEGER PRIMARY KEY AUTOINCREMENT), created_at (TEXT NOT NULL DEFAULT datetime('now')), delivery_id (TEXT), repo (TEXT NOT NULL), pr_number (INTEGER), event_type (TEXT NOT NULL), provider (TEXT NOT NULL DEFAULT 'anthropic'), model (TEXT NOT NULL), input_tokens (INTEGER NOT NULL DEFAULT 0), output_tokens (INTEGER NOT NULL DEFAULT 0), cache_read_tokens (INTEGER NOT NULL DEFAULT 0), cache_creation_tokens (INTEGER NOT NULL DEFAULT 0), duration_ms (INTEGER NOT NULL DEFAULT 0), cost_usd (REAL NOT NULL DEFAULT 0), conclusion (TEXT NOT NULL), session_id (TEXT), num_turns (INTEGER), stop_reason (TEXT)
    - Creates indexes IF NOT EXISTS: idx_executions_created_at on created_at, idx_executions_repo on repo
    - Uses prepared statement (db.query()) for INSERT, cached on creation
    - record(): runs prepared INSERT with $-prefixed named parameters. Increments write counter. When counter reaches 1000, calls checkpoint() and resets counter.
    - purgeOlderThan(days): runs DELETE WHERE created_at < datetime('now', '-{days} days'), returns result.changes
    - checkpoint(): runs PRAGMA wal_checkpoint(PASSIVE)
    - close(): calls db.close(false)
    - Ensure the data directory exists before opening DB: use `mkdirSync(dirname(dbPath), { recursive: true })` (import from "node:fs" and "node:path")

    Test cases (RED phase -- all must fail before implementation):
    1. record() inserts a row -> query DB directly, verify row exists with correct fields
    2. record() with minimal fields (only required) -> verify defaults applied (provider = 'anthropic', tokens = 0)
    3. purgeOlderThan(0) on a store with rows -> returns count > 0, rows deleted (insert a row, manually update created_at to past)
    4. purgeOlderThan(90) preserves recent rows -> insert row, purge, verify row still exists
    5. checkpoint() runs without error
    6. WAL mode is active -> query `PRAGMA journal_mode` returns 'wal'
    7. close() makes subsequent record() throw (or at least not work)
    8. Auto-checkpoint after 1000 writes (spy/verify checkpoint called)

    All tests use `:memory:` databases for isolation. Use a mock logger (pino with level 'silent' or a simple object with no-op methods).
  </behavior>
  <implementation>
    Follow codebase patterns: factory function `createTelemetryStore(opts)` returning the TelemetryStore interface (same pattern as createJobQueue, createWorkspaceManager, etc.).

    For the auto-checkpoint test (#8): since checkpoint() is a method on the returned object, you can test by inserting 1000 records and then verifying via a spy or by checking the WAL file behavior. Simplest approach: track checkpoint calls internally and expose a `getWriteCount()` method only in tests, OR just verify that 1000 inserts don't throw and the DB is still functional (functional test rather than behavioral).

    For purge date manipulation in test (#3): use db.run() directly to UPDATE the created_at of a test row to a past date, then call purgeOlderThan().
  </implementation>
</feature>

<verification>
- `bun test src/telemetry/store.test.ts` passes all tests
- `bun run typecheck` (or `bunx tsc --noEmit`) passes
- No new npm dependencies added (bun:sqlite is built-in)
</verification>

<success_criteria>
- TelemetryStore inserts, purges, and checkpoints correctly (all tests green)
- WAL mode confirmed active
- 90-day retention purge works with correct date math
- Auto-checkpoint triggers at 1000 writes
- Factory function follows existing codebase DI pattern
</success_criteria>

<output>
After completion, create `.planning/phases/23-telemetry-foundation/23-01-SUMMARY.md`
</output>
