---
phase: 72-telemetry-follow-through
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/telemetry/types.ts
  - src/telemetry/store.ts
  - src/telemetry/store.test.ts
  - src/handlers/review.ts
  - src/handlers/review.test.ts
autonomous: true

must_haves:
  truths:
    - "A degraded execution writes at most one rate-limit telemetry row for the same delivery/event identity, even when retry logic runs"
    - "Exactly-once identity for rate-limit telemetry is keyed by delivery_id plus event type, and duplicate emission for the same pair is impossible"
    - "If rate-limit telemetry persistence throws, review execution still completes and publishes its normal output path"
  artifacts:
    - path: "src/telemetry/store.ts"
      provides: "Composite-idempotent rate_limit_events persistence keyed by delivery_id + event_type"
      contains: "idx_rate_limit_events_delivery_event"
    - path: "src/handlers/review.ts"
      provides: "Single per-run rate-limit telemetry emission using original webhook identity and fail-open write handling"
      contains: "telemetryStore.recordRateLimitEvent"
    - path: "src/handlers/review.test.ts"
      provides: "Regression coverage for exactly-once emission and non-blocking telemetry write failures"
      contains: "recordRateLimitEvent"
  key_links:
    - from: "src/handlers/review.ts"
      to: "src/telemetry/store.ts"
      via: "recordRateLimitEvent payload uses deliveryId + eventType identity from webhook execution context"
      pattern: "recordRateLimitEvent\(|deliveryId|eventType"
    - from: "src/telemetry/store.ts"
      to: "rate_limit_events"
      via: "unique index enforces idempotency on delivery_id + event_type"
      pattern: "CREATE UNIQUE INDEX IF NOT EXISTS idx_rate_limit_events_delivery_event"
    - from: "src/handlers/review.test.ts"
      to: "src/handlers/review.ts"
      via: "tests assert one emission per degraded run and fail-open continuation on telemetry persistence errors"
      pattern: "degraded|recordRateLimitEvent|conclusion"
---

<objective>
Lock OPS-05 runtime guarantees so degraded executions always emit exactly-once telemetry without risking review completion.

Purpose: Phase 72 requires production-safe proof that telemetry idempotency and non-blocking behavior hold under real retry/degraded conditions, with duplicate emission treated as a milestone failure.
Output: Composite telemetry identity in persistence, deterministic once-per-run emission wiring, and regression coverage that fails on duplicate emission or blocking write behavior.
</objective>

<execution_context>
@/home/keith/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/keith/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/72-telemetry-follow-through/72-CONTEXT.md
@.planning/phases/67-rate-limit-resilience-telemetry/67-02-SUMMARY.md
@.planning/phases/71-search-cache-telemetry-wiring-fix/71-01-SUMMARY.md
@src/telemetry/store.ts
@src/telemetry/store.test.ts
@src/handlers/review.ts
@src/handlers/review.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enforce composite exactly-once telemetry identity in storage</name>
  <files>src/telemetry/types.ts, src/telemetry/store.ts, src/telemetry/store.test.ts</files>
  <action>
Implement the locked exactly-once identity decision at the DB layer using `delivery_id + event_type` as the idempotency key for `rate_limit_events`:

- Replace delivery-only idempotency enforcement with a composite unique index for `(delivery_id, event_type)` (partial on non-null delivery_id).
- Keep migration behavior additive-safe for existing telemetry DBs: preserve table data, handle older index presence, and avoid destructive table rebuilds.
- Keep store write semantics deterministic and non-throwing by contract (callers remain fail-open); update TypeScript types/comments to explicitly document the composite identity rule.
- Add targeted store tests that prove duplicates with same `delivery_id + event_type` are deduped while different event types under the same delivery remain distinct records.
  </action>
  <verify>
Run `bun test src/telemetry/store.test.ts --timeout 30000`.
Run `bunx tsc --noEmit`.
  </verify>
  <done>
`rate_limit_events` enforces composite idempotency on `delivery_id + event_type`, and storage regressions fail if duplicate rows can be inserted for the same identity.
  </done>
</task>

<task type="auto">
  <name>Task 2: Guarantee once-per-run emission and fail-open behavior in degraded review flow</name>
  <files>src/handlers/review.ts, src/handlers/review.test.ts</files>
  <action>
Harden review-handler telemetry emission so retry/degraded execution paths still produce exactly one rate-limit event per run and never block completion:

- Ensure `recordRateLimitEvent` is invoked from a single deterministic emission point per review execution, after Search enrichment outcomes are finalized.
- Reuse original webhook identity (`deliveryId` and runtime `eventType`) for any retry path wiring so no second telemetry identity is created.
- Preserve non-blocking semantics: if `recordRateLimitEvent` throws, review flow must continue to completion with existing success/degraded output behavior.
- Add regressions asserting exactly-one emission on degraded retries and success-path completion even when telemetry writes throw.
  </action>
  <verify>
Run `bun test src/handlers/review.test.ts --timeout 30000`.
Run `bunx tsc --noEmit`.
  </verify>
  <done>
Degraded review executions emit one rate-limit telemetry event per run identity, retries do not produce duplicates, and telemetry persistence failures do not block review completion.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add cross-layer regression proof for duplicate prevention and completion safety</name>
  <files>src/telemetry/store.test.ts, src/handlers/review.test.ts</files>
  <action>
Add/extend cross-layer tests that codify milestone failure conditions and acceptance rules:

- DB-layer truth assertions for duplicate detection (`delivery_id + event_type`) and no-duplicate guarantees for replay/retry semantics.
- Handler-layer assertions that a degraded execution with telemetry persistence failure still returns completed review behavior (no crash, no early return).
- Keep tests deterministic (in-memory DB, mocked telemetry failures, no network) and align naming with OPS-04/OPS-05 reliability intent.
  </action>
  <verify>
Run `bun test src/telemetry/store.test.ts src/handlers/review.test.ts --timeout 30000`.
Run `bun test`.
Run `bunx tsc --noEmit`.
  </verify>
  <done>
Regression suite fails on duplicate telemetry emission or blocking write behavior and passes only when exactly-once + non-blocking guarantees are met.
  </done>
</task>

</tasks>

<verification>
- `bun test src/telemetry/store.test.ts --timeout 30000` passes with composite-key idempotency assertions.
- `bun test src/handlers/review.test.ts --timeout 30000` passes with once-per-run emission and fail-open completion assertions.
- `bun test` and `bunx tsc --noEmit` pass.
</verification>

<success_criteria>
OPS-05 runtime contract is enforced: exactly-once telemetry identity uses `delivery_id + event_type`, duplicate emission is prevented in degraded retry paths, and telemetry write failures remain non-blocking for user-visible review completion.
</success_criteria>

<output>
After completion, create `.planning/phases/72-telemetry-follow-through/72-01-SUMMARY.md`
</output>
