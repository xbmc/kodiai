---
phase: 57-analysis-layer
plan: "03"
type: execute
wave: 2
depends_on: ["57-01", "57-02"]
files_modified:
  - src/lib/dep-bump-detector.ts
  - src/handlers/review.ts
  - src/handlers/review.test.ts
  - src/execution/review-prompt.ts
  - src/execution/review-prompt.test.ts
autonomous: true

must_haves:
  truths:
    - "When a dep bump has breaking changes, Kodiai greps workspace and surfaces file:line usage evidence in the review prompt"
    - "When multiple scoped packages are updated together, Kodiai notes the coordination in the review prompt"
    - "Recency weighting is applied after language reranking in the retrieval pipeline"
    - "Usage analysis completes within 3-second budget and fails open"
    - "Recency weighting chains without disrupting existing retrieval quality telemetry"
  artifacts:
    - path: "src/handlers/review.ts"
      provides: "Wiring for usage analysis, scope coordination, and recency weighting"
      contains: "analyzePackageUsage"
    - path: "src/execution/review-prompt.ts"
      provides: "Prompt sections for usage evidence and scope coordination"
      contains: "Workspace Usage Evidence"
    - path: "src/lib/dep-bump-detector.ts"
      provides: "Extended DepBumpContext with usageEvidence and scopeGroups fields"
      contains: "usageEvidence"
  key_links:
    - from: "src/handlers/review.ts"
      to: "src/lib/usage-analyzer.ts"
      via: "analyzePackageUsage call with workspace.dir"
      pattern: "analyzePackageUsage"
    - from: "src/handlers/review.ts"
      to: "src/lib/scope-coordinator.ts"
      via: "detectScopeCoordination call with package names"
      pattern: "detectScopeCoordination"
    - from: "src/handlers/review.ts"
      to: "src/learning/retrieval-recency.ts"
      via: "applyRecencyWeighting call after rerankByLanguage"
      pattern: "applyRecencyWeighting"
    - from: "src/execution/review-prompt.ts"
      to: "DepBumpContext.usageEvidence"
      via: "buildDepBumpSection renders usage evidence"
      pattern: "usageEvidence"
---

<objective>
Wire usage analysis, scope coordination, and recency weighting into the review pipeline and prompt rendering.

Purpose: Connect the three pure-function modules from Plans 01 and 02 into the live review handler and prompt builder, completing DEP-04, DEP-06, and RET-04 integration.

Output: Modified review handler, review prompt builder, and DepBumpContext type
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/57-analysis-layer/57-RESEARCH.md
@.planning/phases/57-analysis-layer/57-01-SUMMARY.md
@.planning/phases/57-analysis-layer/57-02-SUMMARY.md
@src/handlers/review.ts
@src/execution/review-prompt.ts
@src/lib/dep-bump-detector.ts
@src/learning/retrieval-rerank.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire usage analysis and scope coordination into dep bump pipeline</name>
  <files>src/lib/dep-bump-detector.ts, src/handlers/review.ts, src/handlers/review.test.ts, src/execution/review-prompt.ts, src/execution/review-prompt.test.ts</files>
  <action>
**1. Extend DepBumpContext type** in `src/lib/dep-bump-detector.ts`:
Add two optional fields to `DepBumpContext`:
```typescript
/** Phase 57: Workspace usage evidence for breaking changes (null when analysis skipped/failed) */
usageEvidence?: import("./usage-analyzer.ts").UsageAnalysisResult | null;
/** Phase 57: Multi-package scope coordination groups */
scopeGroups?: import("./scope-coordinator.ts").ScopeGroup[] | null;
```

**2. Wire usage analysis in review.ts:**
- Import `analyzePackageUsage` from `../lib/usage-analyzer.ts`.
- After the existing dep bump enrichment block (around line 1472, after merge confidence), add a new block for usage analysis:
  - Guard: only run when `depBumpContext` exists, `depBumpContext.details.packageName` is non-null, not a group bump, AND `depBumpContext.changelog?.breakingChanges` has entries.
  - Call `analyzePackageUsage({ workspaceDir: workspace.dir, packageName, breakingChangeSnippets: depBumpContext.changelog.breakingChanges, ecosystem: depBumpContext.details.ecosystem ?? "npm", timeBudgetMs: 3000 })`.
  - Wrap in try/catch, fail-open: on error, log warn and leave usageEvidence as null.
  - Assign result to `depBumpContext.usageEvidence`.
  - Log: `{ gate: "usage-analysis", evidenceCount, timedOut, searchTerms }`.

**3. Wire scope coordination in review.ts:**
- Import `detectScopeCoordination` from `../lib/scope-coordinator.ts`.
- After usage analysis block, add scope coordination:
  - Guard: only run when `depBumpContext` exists AND `depBumpContext.details.isGroup` is true.
  - For group bumps, parse package names from PR body. Use a simple regex to find npm package patterns: `/@[\w-]+\/[\w.-]+/g` applied to `pr.body`. If no packages found, skip.
  - Call `detectScopeCoordination(packageNames)`.
  - Assign non-empty result to `depBumpContext.scopeGroups`.
  - Log: `{ gate: "scope-coordination", groupCount: scopeGroups.length }`.
  - Wrap in try/catch, fail-open.

**4. Render usage evidence in review-prompt.ts:**
- In `buildDepBumpSection(ctx)`, after the existing breaking changes rendering, add a conditional block:
  - If `ctx.usageEvidence?.evidence?.length > 0`:
    - Add `### Workspace Usage Evidence` heading.
    - Add "The following files in this repo import or use APIs affected by this bump:".
    - For each evidence item (cap at 10): render `` - `{filePath}:{line}` -- `{snippet}` ``.
    - If more than 10: add `- ... and {N} more locations`.
  - If `ctx.usageEvidence?.timedOut`: add "(usage analysis timed out -- evidence may be incomplete)".

**5. Render scope coordination in review-prompt.ts:**
- In `buildDepBumpSection(ctx)`, after usage evidence, add:
  - If `ctx.scopeGroups?.length > 0`:
    - Add `### Multi-Package Coordination` heading.
    - For each group: "Packages from `{scope}` scope updated together: {packages.join(', ')}. Review for cross-package compatibility."

**6. Update tests:**
- In `review-prompt.test.ts`: Add test that `buildDepBumpSection` renders usage evidence when present. Add test that scope coordination renders when groups present.
- In `review.test.ts`: Add focused test that usage analysis is called when breaking changes exist and workspace is available. Verify fail-open behavior (mock analyzePackageUsage to throw, confirm no error propagation). Use existing test patterns for mocking deps.
  </action>
  <verify>
```bash
bun test src/handlers/review.test.ts src/execution/review-prompt.test.ts
```
Both pass. Usage evidence appears in prompt output when breaking changes have evidence.
  </verify>
  <done>Usage analysis and scope coordination are wired into the dep bump pipeline, rendered in the review prompt, and fail-open on errors</done>
</task>

<task type="auto">
  <name>Task 2: Wire recency weighting into retrieval pipeline</name>
  <files>src/handlers/review.ts, src/handlers/review.test.ts</files>
  <action>
**1. Wire recency weighting in review.ts:**
- Import `applyRecencyWeighting` from `../learning/retrieval-recency.ts`.
- Find the retrieval reranking section (around line 1614-1616):
  ```typescript
  const reranked = retrieval.results.length > 0
    ? rerankByLanguage({ results: retrieval.results, prLanguages })
    : [];
  ```
- Chain recency weighting AFTER language reranking but BEFORE telemetry recording:
  ```typescript
  const languageReranked = retrieval.results.length > 0
    ? rerankByLanguage({ results: retrieval.results, prLanguages })
    : [];
  const reranked = languageReranked.length > 0
    ? applyRecencyWeighting({ results: languageReranked })
    : [];
  ```
- The existing telemetry code (lines 1618-1646) continues to use `reranked` -- this is correct because telemetry should capture the FINAL reranked distances (after recency), matching what the prompt actually uses.
- Log: add to the existing retrieval log (if one exists nearby) a note about recency weighting being applied, e.g., `recencyApplied: languageReranked.length > 0`.

**2. Update tests in review.test.ts:**
- The existing retrieval tests should continue to pass since recency weighting with default config and recent-ish mock data produces near-neutral adjustments.
- Add a focused test: verify that `applyRecencyWeighting` is called after `rerankByLanguage` in the retrieval pipeline. Mock both functions, verify call order and that the output of rerankByLanguage is passed to applyRecencyWeighting.
- Verify telemetry records metrics from the final (post-recency) reranked results.
  </action>
  <verify>
```bash
bun test src/handlers/review.test.ts
```
Passes. Recency weighting is chained after language reranking.
  </verify>
  <done>Recency weighting chains after language reranking in the retrieval pipeline, telemetry captures final distances, and existing tests still pass</done>
</task>

</tasks>

<verification>
Full test suite passes with no regressions:
```bash
bun test
```

Specific verification:
- Usage evidence renders in prompt when breaking changes + evidence present
- Scope coordination renders when group bumps have 2+ scoped packages
- Recency weighting adjusts retrieval distances (recent < old for same base distance)
- All enrichments fail open (errors logged, never block review)
</verification>

<success_criteria>
- Review prompt shows "Workspace Usage Evidence" section with file:line evidence when breaking changes exist and grep finds usage
- Review prompt shows "Multi-Package Coordination" section when group bumps have scoped packages
- Retrieval results are recency-weighted after language reranking
- Usage analysis respects 3-second timeout, fails open
- All fail-open: errors logged as warnings, never block review execution
- Full test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/57-analysis-layer/57-03-SUMMARY.md`
</output>
