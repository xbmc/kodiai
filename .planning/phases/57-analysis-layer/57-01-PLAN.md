---
phase: 57-analysis-layer
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/usage-analyzer.ts
  - src/lib/usage-analyzer.test.ts
  - src/lib/scope-coordinator.ts
  - src/lib/scope-coordinator.test.ts
autonomous: true

must_haves:
  truths:
    - "analyzePackageUsage returns file:line evidence for imports of a given package"
    - "analyzePackageUsage respects a time budget and returns timedOut=true on timeout"
    - "analyzePackageUsage fails open (returns empty evidence on error, never throws)"
    - "detectScopeCoordination groups scoped packages sharing a prefix when 2+ present"
    - "detectScopeCoordination returns empty array for single-package or non-scoped packages"
  artifacts:
    - path: "src/lib/usage-analyzer.ts"
      provides: "Workspace grep for package imports with time budget"
      exports: ["analyzePackageUsage", "UsageEvidence", "UsageAnalysisResult"]
    - path: "src/lib/usage-analyzer.test.ts"
      provides: "Unit tests for usage analyzer"
      contains: "analyzePackageUsage"
    - path: "src/lib/scope-coordinator.ts"
      provides: "Multi-package scope coordination detection"
      exports: ["detectScopeCoordination", "ScopeGroup"]
    - path: "src/lib/scope-coordinator.test.ts"
      provides: "Unit tests for scope coordinator"
      contains: "detectScopeCoordination"
  key_links:
    - from: "src/lib/usage-analyzer.ts"
      to: "git grep subprocess"
      via: "Bun $ shell with Promise.race timeout"
      pattern: "git.*grep"
---

<objective>
Create the usage analyzer and scope coordinator pure-function modules.

Purpose: These modules implement the core analysis logic for DEP-04 (workspace usage evidence) and DEP-06 (multi-package coordination). They are pure functions with no side effects, testable in isolation, wired into the review handler in a later plan.

Output: Two new modules with tests in src/lib/
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/57-analysis-layer/57-RESEARCH.md
@src/lib/dep-bump-enrichment.ts
@src/lib/dep-bump-detector.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create usage analyzer module</name>
  <files>src/lib/usage-analyzer.ts, src/lib/usage-analyzer.test.ts</files>
  <action>
Create `src/lib/usage-analyzer.ts` with:

1. Types: `UsageEvidence` (filePath, line, snippet), `UsageAnalysisResult` (evidence[], searchTerms[], timedOut).

2. Export `analyzePackageUsage(params)` accepting: `workspaceDir: string`, `packageName: string`, `breakingChangeSnippets: string[]`, `ecosystem: string`, `timeBudgetMs?: number` (default 3000).

3. Internal `buildSearchTerms(packageName, snippets)`:
   - Always include the bare package name for import detection (e.g., `"react-router"` to find `import ... from "react-router"`).
   - Extract API identifiers from breaking change snippets using regex: `/\b[a-zA-Z_]\w*(?:\.\w+)+\(\)/g` to find things like `foo.bar()`.
   - Also extract backtick-wrapped identifiers: `/`([^`]+)`/g`.
   - Deduplicate and return string[]. If no terms found, return empty (caller gets empty evidence).

4. Use `git -C ${workspaceDir} grep -rn --max-count=20 ${pattern}` via Bun `$` shell with `.quiet().nothrow()`.
   - Join search terms with `\|` for git grep OR syntax.
   - Wrap with `Promise.race` against `setTimeout(timeBudgetMs)` for timeout enforcement. Do NOT rely on Bun `$` `.timeout()` -- use the defensive `Promise.race` pattern per research pitfall 5.
   - Parse output lines matching `^([^:]+):(\d+):(.*)$` into UsageEvidence objects. Cap at 20 results.
   - On timeout: return `{ evidence: [], searchTerms, timedOut: true }`.
   - On any error (catch block): return `{ evidence: [], searchTerms, timedOut: false }`. Never throw.

5. Tests in `usage-analyzer.test.ts`:
   - Test `buildSearchTerms` extraction from snippets with backtick identifiers and dot-call patterns.
   - Test that `analyzePackageUsage` returns empty evidence when workspaceDir doesn't exist (fail-open).
   - Test timeout behavior: use a mock that delays beyond budget.
   - Note: For the git grep integration test, create a temp git repo with `Bun.spawn` or use the existing test pattern. If creating a real subprocess test is impractical, test the search term building and output parsing logic with unit tests on the internal helpers (export them as needed for testing).
  </action>
  <verify>`bun test src/lib/usage-analyzer.test.ts` passes with all tests green</verify>
  <done>analyzePackageUsage extracts search terms from package name + breaking change snippets, greps workspace via git grep with time budget, returns typed UsageEvidence[], and fails open on error/timeout</done>
</task>

<task type="auto">
  <name>Task 2: Create scope coordinator module</name>
  <files>src/lib/scope-coordinator.ts, src/lib/scope-coordinator.test.ts</files>
  <action>
Create `src/lib/scope-coordinator.ts` with:

1. Type: `ScopeGroup` (scope: string, packages: string[]).

2. Export `detectScopeCoordination(packageNames: string[]): ScopeGroup[]`:
   - For each package starting with `@`, extract scope via `pkg.split("/")[0]`.
   - Group by scope. Only return groups with 2+ packages.
   - Return sorted by scope name for deterministic output.
   - Non-scoped packages are ignored (no scope to coordinate).

This is a simple pure function -- no async, no I/O, no external deps.

3. Tests in `scope-coordinator.test.ts`:
   - `@babel/core` + `@babel/parser` -> one group with scope `@babel`.
   - `@babel/core` + `@types/node` -> no groups (each scope has only 1 package).
   - `@babel/core` + `@babel/parser` + `@types/node` + `@types/jest` -> two groups.
   - Empty array -> empty result.
   - Non-scoped packages like `react`, `lodash` -> empty result.
   - Single scoped package -> empty result (need 2+).
  </action>
  <verify>`bun test src/lib/scope-coordinator.test.ts` passes with all tests green</verify>
  <done>detectScopeCoordination correctly groups scoped packages and returns empty for single-package or non-scoped inputs</done>
</task>

</tasks>

<verification>
```bash
bun test src/lib/usage-analyzer.test.ts src/lib/scope-coordinator.test.ts
```
Both test suites pass. No regressions in existing tests:
```bash
bun test
```
</verification>

<success_criteria>
- usage-analyzer.ts exports analyzePackageUsage with typed result
- scope-coordinator.ts exports detectScopeCoordination with typed result
- Both modules are pure functions with no side effects
- Usage analyzer respects time budget via Promise.race
- Usage analyzer fails open on all error paths
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/57-analysis-layer/57-01-SUMMARY.md`
</output>
