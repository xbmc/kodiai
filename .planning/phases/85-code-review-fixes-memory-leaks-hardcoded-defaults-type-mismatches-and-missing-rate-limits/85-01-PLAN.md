---
phase: 85-code-review-fixes-memory-leaks-hardcoded-defaults-type-mismatches-and-missing-rate-limits
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/in-memory-cache.ts
  - src/lib/in-memory-cache.test.ts
  - src/slack/thread-session-store.ts
  - src/slack/thread-session-store.test.ts
  - src/slack/write-confirmation-store.ts
  - src/slack/write-confirmation-store.test.ts
  - src/webhook/dedup.ts
  - src/webhook/dedup.test.ts
  - src/index.ts
autonomous: true
requirements: []

must_haves:
  truths:
    - "All in-memory stores have bounded size and cannot grow without limit"
    - "Expired entries are automatically evicted on access, not requiring manual pruning"
    - "ThreadSessionStore, WriteConfirmationStore, Deduplicator, and Slack installation cache use the shared InMemoryCache"
    - "Existing tests continue to pass after migration"
  artifacts:
    - path: "src/lib/in-memory-cache.ts"
      provides: "Generic InMemoryCache<K,V> with TTL and maxSize"
      exports: ["createInMemoryCache", "InMemoryCache"]
    - path: "src/lib/in-memory-cache.test.ts"
      provides: "Tests for TTL expiry, maxSize eviction, and edge cases"
  key_links:
    - from: "src/slack/thread-session-store.ts"
      to: "src/lib/in-memory-cache.ts"
      via: "import createInMemoryCache"
      pattern: "createInMemoryCache"
    - from: "src/slack/write-confirmation-store.ts"
      to: "src/lib/in-memory-cache.ts"
      via: "import createInMemoryCache"
      pattern: "createInMemoryCache"
    - from: "src/webhook/dedup.ts"
      to: "src/lib/in-memory-cache.ts"
      via: "import createInMemoryCache"
      pattern: "createInMemoryCache"
    - from: "src/index.ts"
      to: "src/lib/in-memory-cache.ts"
      via: "import createInMemoryCache"
      pattern: "createInMemoryCache"
---

<objective>
Create a shared InMemoryCache utility with configurable TTL and maxSize, then migrate all unbounded in-memory stores to use it. This eliminates 4 memory leak vectors (C-2, C-3, H-1, H-3) in one pattern.

Purpose: Prevent OOM crashes from unbounded Maps/Sets that grow indefinitely in long-running server processes.
Output: `src/lib/in-memory-cache.ts` + migrated stores with bounded memory.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/slack/thread-session-store.ts
@src/slack/write-confirmation-store.ts
@src/webhook/dedup.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create InMemoryCache utility with TTL and maxSize</name>
  <files>
    src/lib/in-memory-cache.ts
    src/lib/in-memory-cache.test.ts
  </files>
  <action>
Create `src/lib/in-memory-cache.ts` exporting:

```typescript
export interface InMemoryCacheOptions {
  maxSize: number;       // Max entries before LRU eviction
  ttlMs: number;         // Time-to-live in milliseconds
  now?: () => number;    // Injectable clock for testing
}

export interface InMemoryCache<K, V> {
  get(key: K): V | undefined;
  set(key: K, value: V): void;
  has(key: K): boolean;
  delete(key: K): boolean;
  size(): number;
  clear(): void;
}
```

Implementation details:
- Back with a `Map<K, { value: V; expiresAt: number }>` for O(1) access
- `get()` returns undefined for expired entries and deletes them lazily
- `has()` checks expiry before returning true
- `set()` evicts expired entries first, then if still over maxSize, evict oldest entries (by insertion order — Map iteration order) until under limit
- `now` defaults to `Date.now` for testability
- No intervals or timers — purely lazy eviction on access/insert

Create `src/lib/in-memory-cache.test.ts` with tests:
- Basic get/set/has/delete operations
- TTL expiry: set entry, advance clock past TTL, get returns undefined
- maxSize eviction: insert maxSize+1 entries, oldest is evicted
- Expired entries don't count toward size for eviction decisions
- `clear()` removes all entries
- `size()` only counts non-expired entries
  </action>
  <verify>Run `bun test src/lib/in-memory-cache.test.ts` — all tests pass.</verify>
  <done>InMemoryCache utility exists with TTL and maxSize support, fully tested.</done>
</task>

<task type="auto">
  <name>Task 2: Migrate stores to InMemoryCache — fix C-2, C-3, H-1, H-3</name>
  <files>
    src/slack/thread-session-store.ts
    src/slack/write-confirmation-store.ts
    src/webhook/dedup.ts
    src/index.ts
  </files>
  <action>
**C-2: ThreadSessionStore** (`src/slack/thread-session-store.ts`)
- Replace the internal `Set<string>` with `InMemoryCache<string, true>`
- Config: `maxSize: 10_000`, `ttlMs: 24 * 60 * 60 * 1000` (24 hours — threads older than 24h are stale)
- `markThreadStarted`: use `cache.has()` then `cache.set(key, true)`, return `!existed`
- `isThreadStarted`: use `cache.has()`
- Keep the same public interface (`SlackThreadSessionStore`)
- Accept optional `options?: { maxSize?: number; ttlMs?: number }` parameter on factory for testability

**C-3: WriteConfirmationStore** (`src/slack/write-confirmation-store.ts`)
- Replace the internal `Map<string, SlackWritePendingConfirmation>` with `InMemoryCache<string, SlackWritePendingConfirmation>`
- Config: `maxSize: 1_000`, `ttlMs: 15 * 60 * 1000` (15 minutes — matches existing confirmation timeout)
- This inherently fixes the "pruneExpired never called" bug since InMemoryCache does lazy eviction
- Keep the same public interface (`SlackWriteConfirmationStore`)
- The `expiresAt` field on `SlackWritePendingConfirmation` still exists for domain logic (confirm checks), but the cache TTL handles memory cleanup

**H-1: Deduplicator** (`src/webhook/dedup.ts`)
- Replace the internal `Map<string, number>` with `InMemoryCache<string, true>`
- Config: `maxSize: 50_000`, `ttlMs: 24 * 60 * 60 * 1000` (24 hours — matches existing MAX_AGE_MS)
- Remove the manual `insertCount` and periodic cleanup loop — InMemoryCache handles this
- Keep the same public interface (`Deduplicator`)

**H-3: Slack installation cache** (`src/index.ts`)
- Replace `const slackInstallationCache = new Map<string, ...>()` with `createInMemoryCache<string, { installationId: number; defaultBranch: string }>({ maxSize: 500, ttlMs: 60 * 60 * 1000 })` (1 hour TTL)
- Import `createInMemoryCache` from `../lib/in-memory-cache.ts`
- The `resolveSlackInstallationContext` function needs no interface change — just swap `.get()`/`.set()` calls

Run existing tests to confirm no regressions in behavior.
  </action>
  <verify>Run `bun test src/slack/ src/webhook/dedup.test.ts` — all existing tests pass. Run `bun test` for full suite — no regressions.</verify>
  <done>All 4 stores are bounded by maxSize and TTL. No unbounded Map/Set remains in any in-memory store.</done>
</task>

</tasks>

<verification>
- `bun test` — full test suite passes
- `grep -r "new Map\b" src/slack/thread-session-store.ts src/slack/write-confirmation-store.ts src/webhook/dedup.ts` returns no hits (all migrated)
- `grep -r "new Set\b" src/slack/thread-session-store.ts` returns no hits
- InMemoryCache tests demonstrate TTL and maxSize behavior
</verification>

<success_criteria>
- All 4 unbounded stores (C-2, C-3, H-1, H-3) are migrated to InMemoryCache with explicit bounds
- Shared utility is tested independently
- Full test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/85-code-review-fixes-memory-leaks-hardcoded-defaults-type-mismatches-and-missing-rate-limits/85-01-SUMMARY.md`
</output>
