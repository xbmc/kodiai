---
phase: 07-operational-resilience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/errors.ts
  - src/lib/errors.test.ts
  - src/execution/types.ts
  - src/execution/config.ts
  - src/execution/executor.ts
autonomous: true

must_haves:
  truths:
    - "Error messages are classified into user-understandable categories (timeout, api_error, config_error, clone_error, internal_error)"
    - "Error comments are formatted as clear, actionable markdown with a header, detail, and suggestion"
    - "A job exceeding the configured timeout is terminated via AbortController and returns isTimeout: true"
    - "Timeout duration is configurable via timeoutSeconds in .kodiai.yml (default 300)"
    - "Tokens/secrets in error messages are redacted before they can reach any comment-posting code"
  artifacts:
    - path: "src/lib/errors.ts"
      provides: "Error classification, formatting, and comment posting utility"
      exports: ["classifyError", "formatErrorComment", "postOrUpdateErrorComment", "ErrorCategory"]
    - path: "src/lib/errors.test.ts"
      provides: "Tests for error classification and formatting"
      contains: "test"
    - path: "src/execution/types.ts"
      provides: "Updated ExecutionResult with isTimeout field"
      contains: "isTimeout"
    - path: "src/execution/config.ts"
      provides: "Updated RepoConfig with timeoutSeconds field"
      contains: "timeoutSeconds"
    - path: "src/execution/executor.ts"
      provides: "AbortController-based timeout enforcement in execute()"
      contains: "AbortController"
  key_links:
    - from: "src/execution/executor.ts"
      to: "src/execution/config.ts"
      via: "reads config.timeoutSeconds"
      pattern: "config\\.timeoutSeconds"
    - from: "src/execution/executor.ts"
      to: "@anthropic-ai/claude-agent-sdk"
      via: "passes abortController to query() options"
      pattern: "abortController"
    - from: "src/lib/errors.ts"
      to: "src/lib/sanitizer.ts"
      via: "imports redactGitHubTokens for defense-in-depth"
      pattern: "redactGitHubTokens"
---

<objective>
Create the error handling foundation and timeout enforcement for Phase 7: Operational Resilience.

Purpose: Both handlers (review and mention) need shared error formatting and the executor needs timeout enforcement. This plan creates the foundation that Plan 02 wires into the handlers.

Output: Error classification/formatting module (`src/lib/errors.ts`), updated executor with AbortController-based timeout, updated config with `timeoutSeconds`, updated types with `isTimeout` field.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-operational-resilience/07-RESEARCH.md

@src/lib/errors.ts (new file)
@src/lib/sanitizer.ts
@src/execution/types.ts
@src/execution/config.ts
@src/execution/executor.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Error classification module and config/type extensions</name>
  <files>src/lib/errors.ts, src/lib/errors.test.ts, src/execution/types.ts, src/execution/config.ts</files>
  <action>
Create `src/lib/errors.ts` with:

1. Export `ErrorCategory` type: `"timeout" | "api_error" | "config_error" | "clone_error" | "internal_error"`

2. Export `classifyError(error: unknown, isTimeout: boolean): ErrorCategory`:
   - If `isTimeout` is true, return `"timeout"`
   - Check `error instanceof Error ? error.message : String(error)` for patterns:
     - Contains `.kodiai.yml` -> `"config_error"`
     - Contains `clone` or `git` (case insensitive) -> `"clone_error"`
     - Contains `rate limit` or `API` or status code patterns -> `"api_error"`
     - Default -> `"internal_error"`

3. Export `formatErrorComment(category: ErrorCategory, detail: string): string`:
   - Headers map: timeout -> "Kodiai timed out", api_error -> "Kodiai encountered an API error", config_error -> "Kodiai found a configuration problem", clone_error -> "Kodiai couldn't access the repository", internal_error -> "Kodiai encountered an error"
   - Suggestions map: timeout -> "Try breaking the task into smaller pieces, or increase the timeout in `.kodiai.yml`.", api_error -> "This is usually temporary. Try again in a few minutes.", config_error -> "Check your `.kodiai.yml` file for syntax or schema errors.", clone_error -> "Verify the repository is accessible and the branch exists.", internal_error -> "If this persists, please report this issue."
   - Format: `> **{header}**\n\n_{sanitized_detail}_\n\n{suggestion}`
   - IMPORTANT: Run `detail` through `redactGitHubTokens()` from `src/lib/sanitizer.ts` before including in output (defense-in-depth per research Pitfall 4)

4. Export `postOrUpdateErrorComment(octokit: Octokit, target: { owner: string; repo: string; issueNumber: number; trackingCommentId?: number }, body: string): Promise<void>`:
   - If `trackingCommentId` is provided, call `octokit.rest.issues.updateComment({ owner, repo, comment_id: trackingCommentId, body })`
   - If no `trackingCommentId`, call `octokit.rest.issues.createComment({ owner, repo, issue_number: issueNumber, body })`
   - Wrap the entire function body in try/catch -- if the GitHub API call itself fails, log the error but do NOT throw (Pitfall 6 from research: never let error reporting mask the original error)
   - Import Logger type from pino, accept `logger` as parameter for logging the API failure

5. The Octokit type: use `import type { Octokit } from "@octokit/rest"` for the parameter type.

Create `src/lib/errors.test.ts` with tests:
- `classifyError` returns correct category for each classification
- `classifyError` with `isTimeout: true` always returns "timeout" regardless of error message
- `formatErrorComment` produces correct markdown structure for each category
- `formatErrorComment` redacts GitHub tokens in detail (pass `ghs_aaaaaabbbbbbccccccddddddeeeeeefffff` in detail, assert it becomes `[REDACTED_GITHUB_TOKEN]`)

Update `src/execution/types.ts`:
- Add `isTimeout?: boolean` field to `ExecutionResult` type (optional, only set when timeout occurs)

Update `src/execution/config.ts`:
- Add `timeoutSeconds: z.number().min(30).max(1800).default(300)` to the top-level `repoConfigSchema` (not nested under review or mention -- it applies to all executions)
- Default is 300 (5 minutes). Min 30 seconds, max 1800 (30 minutes).
  </action>
  <verify>Run `bun test src/lib/errors.test.ts` -- all tests pass. Run `bun build src/execution/types.ts src/execution/config.ts --no-bundle` to verify TypeScript compiles.</verify>
  <done>Error classification correctly categorizes 5 error types. Error formatting produces sanitized markdown. Config has `timeoutSeconds` field with 300s default. ExecutionResult has `isTimeout` field.</done>
</task>

<task type="auto">
  <name>Task 2: AbortController-based timeout in executor</name>
  <files>src/execution/executor.ts</files>
  <action>
Modify `src/execution/executor.ts` to add timeout enforcement:

1. After `loadRepoConfig(context.workspace.dir)`, extract `config.timeoutSeconds` and convert to ms: `const timeoutMs = config.timeoutSeconds * 1000`

2. Create AbortController and manual setTimeout (NOT `AbortSignal.timeout()` because we need to clearTimeout on success -- see research Pitfall 5):
   ```
   const controller = new AbortController();
   const timeoutId = setTimeout(() => controller.abort(new Error("timeout")), timeoutMs);
   ```

3. Pass `abortController: controller` into the `query()` options object alongside the existing options.

4. After the `for await` loop completes successfully, call `clearTimeout(timeoutId)`.

5. In the catch block:
   - Call `clearTimeout(timeoutId)` first.
   - Check `if (controller.signal.aborted)`:
     - Return ExecutionResult with `conclusion: "error"`, `isTimeout: true`, `errorMessage: "Job timed out after {timeoutSeconds} seconds. The operation was taking too long and was automatically terminated."`
   - Otherwise, fall through to the existing error handling (which returns `conclusion: "error"` with the error message).

6. Add `isTimeout: undefined` (or omit) to all non-timeout return paths for type consistency (the field is optional, so omitting is fine).

7. Log at info level when timeout is configured: `logger.info({ timeoutMs }, "Timeout enforcement configured")`

Do NOT change any other behavior of the executor. The existing catch-all error handling, result building, and MCP server setup remain exactly as-is.
  </action>
  <verify>Run `bun build src/execution/executor.ts --no-bundle` -- compiles without errors. Manually verify the AbortController is passed to query() options and clearTimeout is called on both success and error paths.</verify>
  <done>Executor creates AbortController with configurable timeout, passes it to Agent SDK query(), clears timeout on success, and returns `isTimeout: true` when the abort signal fires. No orphaned timers on success path.</done>
</task>

</tasks>

<verification>
- `bun test src/lib/errors.test.ts` passes
- `bun build src/lib/errors.ts src/execution/executor.ts src/execution/types.ts src/execution/config.ts --no-bundle` compiles without type errors
- `classifyError(new Error("test"), true)` returns `"timeout"`
- `formatErrorComment("timeout", "detail with ghs_aaaaaabbbbbbccccccddddddeeeeeefffff")` contains `[REDACTED_GITHUB_TOKEN]` instead of the token
- executor.ts contains `abortController: controller` in query() options
- executor.ts contains `clearTimeout(timeoutId)` in both success and catch paths
- config.ts contains `timeoutSeconds` with default 300
</verification>

<success_criteria>
1. Error module classifies errors into 5 categories and formats actionable markdown comments with token redaction
2. Executor enforces configurable timeout via AbortController passed to Agent SDK
3. Timeout returns `isTimeout: true` on ExecutionResult for downstream handlers to detect
4. Config supports `timeoutSeconds` (default 300, range 30-1800)
5. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-operational-resilience/07-01-SUMMARY.md`
</output>
