---
phase: 07-operational-resilience
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/handlers/review.ts
  - src/handlers/mention.ts
autonomous: true

must_haves:
  truths:
    - "A review handler failure (execution error, timeout, clone failure, config error) posts a new error comment on the PR"
    - "A mention handler failure posts or updates the tracking comment with a classified, actionable error message"
    - "Error comments are clear and actionable -- never stack traces, never generic 'something went wrong'"
    - "Timeout errors specifically mention the timeout duration and suggest increasing it or breaking work into smaller pieces"
    - "Failed error comment posting is caught and logged but never masks the original error"
  artifacts:
    - path: "src/handlers/review.ts"
      provides: "Review handler with error comment posting on all failure paths"
      contains: "postOrUpdateErrorComment"
    - path: "src/handlers/mention.ts"
      provides: "Mention handler with classified error reporting via shared errors module"
      contains: "classifyError"
  key_links:
    - from: "src/handlers/review.ts"
      to: "src/lib/errors.ts"
      via: "imports classifyError, formatErrorComment, postOrUpdateErrorComment"
      pattern: "from.*lib/errors"
    - from: "src/handlers/mention.ts"
      to: "src/lib/errors.ts"
      via: "imports classifyError, formatErrorComment, postOrUpdateErrorComment"
      pattern: "from.*lib/errors"
    - from: "src/handlers/review.ts"
      to: "src/execution/executor.ts"
      via: "checks result.isTimeout and result.conclusion for error reporting"
      pattern: "result\\.isTimeout|result\\.conclusion.*error"
---

<objective>
Wire error reporting into both handlers so that every failure path results in a user-visible, actionable error comment -- never silent failure.

Purpose: The review handler currently catches errors and only logs them (user sees nothing). The mention handler has partial error reporting but uses hardcoded messages instead of classified errors. This plan upgrades both handlers to use the shared errors module from Plan 01.

Output: Updated `src/handlers/review.ts` and `src/handlers/mention.ts` with comprehensive error reporting on all failure paths.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-operational-resilience/07-RESEARCH.md
@.planning/phases/07-operational-resilience/07-01-SUMMARY.md

@src/handlers/review.ts
@src/handlers/mention.ts
@src/lib/errors.ts
@src/execution/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire error reporting into review handler</name>
  <files>src/handlers/review.ts</files>
  <action>
Modify `src/handlers/review.ts` to post error comments on all failure paths:

1. Add imports at top:
   ```
   import { classifyError, formatErrorComment, postOrUpdateErrorComment } from "../lib/errors.ts";
   ```

2. After the `executor.execute()` call (around line 171-181), add error result handling:
   - If `result.conclusion === "error"`, post an error comment to the PR:
     ```
     const category = result.isTimeout ? "timeout" : classifyError(new Error(result.errorMessage ?? "Unknown error"), false);
     const errorBody = formatErrorComment(category, result.errorMessage ?? "An unexpected error occurred during review.");
     const octokit = await githubApp.getInstallationOctokit(event.installationId);
     await postOrUpdateErrorComment(octokit, {
       owner: apiOwner,
       repo: apiRepo,
       issueNumber: pr.number,
     }, errorBody, logger);
     ```
   - Place this BEFORE the silent approval check (only attempt approval if conclusion is "success").

3. Update the outer catch block (currently lines 237-241 which only logs):
   - Replace the catch-and-log-only pattern with error comment posting:
     ```
     catch (err) {
       logger.error({ err, prNumber: pr.number }, "Review handler failed");
       const category = classifyError(err, false);
       const detail = err instanceof Error ? err.message : "An unexpected error occurred";
       const errorBody = formatErrorComment(category, detail);
       try {
         const errOctokit = await githubApp.getInstallationOctokit(event.installationId);
         await postOrUpdateErrorComment(errOctokit, {
           owner: apiOwner,
           repo: apiRepo,
           issueNumber: pr.number,
         }, errorBody, logger);
       } catch (commentErr) {
         logger.error({ err: commentErr }, "Failed to post error comment to PR");
       }
     }
     ```
   - Note: The review handler has NO tracking comment (Pitfall 7 from research), so `trackingCommentId` is NOT passed -- `postOrUpdateErrorComment` will create a new comment.

4. Do NOT add a tracking comment to the review handler's happy path. Per research recommendation, the review itself IS the output. Only post a comment when something goes wrong.

5. Keep the existing `finally` block with workspace cleanup exactly as-is.
  </action>
  <verify>Run `bun build src/handlers/review.ts --no-bundle` -- compiles without errors. Verify that both the executor error path (result.conclusion === "error") and the outer catch block now post error comments.</verify>
  <done>Review handler posts a classified, actionable error comment on the PR for every failure mode: execution errors, timeouts, clone failures, config errors, and unhandled exceptions. No more silent failures.</done>
</task>

<task type="auto">
  <name>Task 2: Upgrade mention handler error reporting</name>
  <files>src/handlers/mention.ts</files>
  <action>
Modify `src/handlers/mention.ts` to use the shared errors module instead of hardcoded messages:

1. Add imports at top:
   ```
   import { classifyError, formatErrorComment, postOrUpdateErrorComment } from "../lib/errors.ts";
   ```

2. Replace the inline `trackingError` function and `TRACKING_INITIAL` with:
   - Keep `TRACKING_INITIAL` as-is (it's the "thinking..." message, not an error).
   - Remove the `trackingError` function entirely -- it will be replaced by `formatErrorComment`.

3. Update the execution error handling (around lines 218-231). Replace:
   ```
   if (result.conclusion === "error" && trackingCommentId) {
     // ... existing updateComment with trackingError()
   }
   ```
   With:
   ```
   if (result.conclusion === "error") {
     const category = result.isTimeout ? "timeout" : classifyError(new Error(result.errorMessage ?? "Unknown error"), false);
     const errorBody = formatErrorComment(category, result.errorMessage ?? "An unexpected error occurred while processing your request.");
     const errOctokit = await githubApp.getInstallationOctokit(event.installationId);
     await postOrUpdateErrorComment(errOctokit, {
       owner: mention.owner,
       repo: mention.repo,
       issueNumber: mention.issueNumber,
       trackingCommentId,
     }, errorBody, logger);
   }
   ```
   Note: This now works whether or not `trackingCommentId` exists. If it does, the tracking comment is updated. If not (rare edge case where tracking comment creation failed), a new comment is created.

4. Update the outer catch block (around lines 232-251). Replace:
   ```
   catch (err) {
     logger.error(...);
     if (trackingCommentId) {
       // ... existing updateComment with hardcoded "Something went wrong"
     }
   }
   ```
   With:
   ```
   catch (err) {
     logger.error({ err, surface: mention.surface, issueNumber: mention.issueNumber }, "Mention handler failed");
     const category = classifyError(err, false);
     const detail = err instanceof Error ? err.message : "An unexpected error occurred";
     const errorBody = formatErrorComment(category, detail);
     try {
       const errOctokit = await githubApp.getInstallationOctokit(event.installationId);
       await postOrUpdateErrorComment(errOctokit, {
         owner: mention.owner,
         repo: mention.repo,
         issueNumber: mention.issueNumber,
         trackingCommentId,
       }, errorBody, logger);
     } catch (commentErr) {
       logger.error({ err: commentErr }, "Failed to post error comment");
     }
   }
   ```

5. Keep TRACKING_INITIAL constant (used for the initial "thinking..." comment, which is NOT an error path).

6. Keep everything else exactly as-is: event registration, mention normalization, workspace creation, config loading, prompt building.
  </action>
  <verify>Run `bun build src/handlers/mention.ts --no-bundle` -- compiles without errors. Verify that the `trackingError` function is removed and replaced by `formatErrorComment`. Verify both the execution error path and outer catch block use `postOrUpdateErrorComment`.</verify>
  <done>Mention handler uses classified, actionable error messages from the shared errors module. Both the execution error path and the outer catch-all post or update error comments. The hardcoded "Something went wrong" message is replaced with specific, categorized messages.</done>
</task>

</tasks>

<verification>
- `bun build src/handlers/review.ts src/handlers/mention.ts --no-bundle` compiles without type errors
- `review.ts` imports from `../lib/errors.ts`
- `review.ts` contains `postOrUpdateErrorComment` calls in both the executor error path and the outer catch block
- `review.ts` outer catch block no longer only logs (the "Review handler failed" log remains, but now followed by error comment posting)
- `mention.ts` imports from `../lib/errors.ts`
- `mention.ts` does NOT contain the old `trackingError` function
- `mention.ts` uses `formatErrorComment` and `postOrUpdateErrorComment` in both error paths
- `mention.ts` still contains `TRACKING_INITIAL` for the "thinking..." comment
- Neither handler contains hardcoded error messages like "Something went wrong"
- Both handlers pass `trackingCommentId` (mention) or omit it (review) correctly
</verification>

<success_criteria>
1. Review handler posts a new error comment on the PR for any failure (execution error, timeout, clone failure, unhandled exception)
2. Mention handler updates tracking comment (or creates new comment if tracking failed) with classified error for any failure
3. All error comments use the shared `formatErrorComment` with category-specific headers and actionable suggestions
4. Timeout errors explicitly mention the duration and suggest increasing it
5. No hardcoded error messages remain in either handler
6. Failed error comment posting is caught, logged, but never masks the original error
</success_criteria>

<output>
After completion, create `.planning/phases/07-operational-resilience/07-02-SUMMARY.md`
</output>
