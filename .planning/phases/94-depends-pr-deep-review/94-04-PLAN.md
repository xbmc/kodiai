---
phase: 94-depends-pr-deep-review
plan: 04
type: execute
wave: 3
depends_on: [94-01, 94-02, 94-03]
files_modified:
  - src/lib/depends-review-builder.ts
  - src/lib/depends-review-builder.test.ts
  - src/handlers/review.ts
autonomous: true
requirements: [DEPS-01, DEPS-02, DEPS-03, DEPS-04, DEPS-05, DEPS-06, DEPS-07, DEPS-08]

must_haves:
  truths:
    - "A [depends] PR triggers the deep-review pipeline and produces a structured comment"
    - "A Dependabot PR still triggers only the existing Dependabot pipeline"
    - "The review comment starts with a TL;DR verdict (safe/risky/needs-attention)"
    - "The review comment includes version diff, changelog highlights, impact assessment, and hash verification"
    - "If enrichment partially fails, the comment still posts with degradation notes"
    - "If the PR touches source files beyond build configs, the standard Claude review runs IN ADDITION to the deep-review"
    - "Inline review comments are posted on specific files with relevant findings (hash mismatches on cmake files)"
    - "Past dependency context from retrieval (learning memories, wiki) surfaces in the review"
  artifacts:
    - path: "src/lib/depends-review-builder.ts"
      provides: "Structured review comment builder with TL;DR verdict"
      exports: ["buildDependsReviewComment", "buildDependsInlineComments", "computeDependsVerdict"]
    - path: "src/lib/depends-review-builder.test.ts"
      provides: "Test suite for comment builder"
      min_lines: 80
    - path: "src/handlers/review.ts"
      provides: "Integration of detectDependsBump() before detectDepBump(), deep-review pipeline execution"
  key_links:
    - from: "src/handlers/review.ts"
      to: "src/lib/depends-bump-detector.ts"
      via: "import and call detectDependsBump() before detectDepBump()"
      pattern: "detectDependsBump.*detectDepBump"
    - from: "src/handlers/review.ts"
      to: "src/lib/depends-review-builder.ts"
      via: "buildDependsReviewComment() called to produce the PR comment"
      pattern: "buildDependsReviewComment"
    - from: "src/handlers/review.ts"
      to: "src/lib/depends-bump-enrichment.ts"
      via: "fetchDependsChangelog(), verifyHash(), detectPatchChanges()"
      pattern: "fetchDependsChangelog|verifyHash|detectPatchChanges"
    - from: "src/handlers/review.ts"
      to: "src/lib/depends-impact-analyzer.ts"
      via: "findDependencyConsumers(), checkTransitiveDependencies()"
      pattern: "findDependencyConsumers|checkTransitiveDependencies"
    - from: "src/handlers/review.ts"
      to: "Octokit"
      via: "octokit.rest.pulls.createReview() for inline comments, octokit.rest.issues.createComment() for summary"
      pattern: "createReview|createComment"
---

<objective>
Build the structured review comment builder and wire the complete [depends] deep-review pipeline into the review handler.

Purpose: This is the integration plan that connects detection (Plan 01), enrichment (Plan 02), and impact analysis (Plan 03) into a working end-to-end pipeline. When a `[depends]` PR is detected, the handler runs enrichment, builds a structured comment, posts it, and conditionally runs the standard Claude review if source code beyond build configs was changed.

Output: `src/lib/depends-review-builder.ts` with comment builder, updated `src/handlers/review.ts` with pipeline integration.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/94-depends-pr-deep-review/94-RESEARCH.md
@.planning/phases/94-depends-pr-deep-review/94-01-SUMMARY.md
@.planning/phases/94-depends-pr-deep-review/94-02-SUMMARY.md
@.planning/phases/94-depends-pr-deep-review/94-03-SUMMARY.md
@src/handlers/review.ts
@src/lib/depends-bump-detector.ts
@src/lib/depends-bump-enrichment.ts
@src/lib/depends-impact-analyzer.ts
@src/execution/review-prompt.ts
@src/knowledge/retrieval.ts
</context>

<interfaces>
<!-- Types from Plan 01 -->
From src/lib/depends-bump-detector.ts:
```typescript
export type DependsBumpInfo = { packages: DependsBumpPackage[]; platform: string | null; isGroup: boolean; rawTitle: string; };
export type DependsBumpContext = { info: DependsBumpInfo; changelog?; hashVerification?; impactAssessment?; transitiveCheck?; retrievalContext?; hasSourceChanges?: boolean; };
export function detectDependsBump(params: { prTitle: string }): DependsBumpInfo | null;
```

<!-- Types from Plan 02 -->
From src/lib/depends-bump-enrichment.ts:
```typescript
export type VersionFileDiff = { oldVersion, newVersion, oldSha512, newSha512, oldArchive, newArchive, oldBaseUrl, newBaseUrl };
export type DependsChangelogContext = { source, highlights, breakingChanges, url, degradationNote };
export type HashVerificationResult = { status: "verified"|"mismatch"|"unavailable"|"skipped", detail, expectedHash?, actualHash? };
export type PatchChange = { file, action };
export function parseVersionFileDiff(patch: string): VersionFileDiff;
export function fetchDependsChangelog(params): Promise<DependsChangelogContext>;
export function verifyHash(params): Promise<HashVerificationResult>;
export function detectPatchChanges(files): PatchChange[];
```

<!-- Types from Plan 03 -->
From src/lib/depends-impact-analyzer.ts:
```typescript
export type ImpactResult = { consumers: IncludeConsumer[]; transitive: TransitiveResult; timeLimitReached: boolean; degradationNote: string | null; };
export function findDependencyConsumers(params): Promise<ImpactResult>;
export function checkTransitiveDependencies(params): Promise<TransitiveResult>;
```

<!-- Existing review handler pattern for dep bump detection (lines ~1727-1810) -->
From src/handlers/review.ts:
```typescript
// Current flow:
// 1. detectDepBump() -> depBumpContext
// 2. fetchSecurityAdvisories() + fetchChangelog() (if depBumpContext)
// 3. computeMergeConfidence()
// 4. analyzePackageUsage()
// 5. detectScopeCoordination()
// 6. depBumpContext passed to buildReviewPrompt()
```

<!-- Retrieval for past dependency context -->
From src/knowledge/retrieval.ts:
```typescript
export function createRetriever(): { retrieve(params: { query: string; ... }): Promise<...> };
```
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Build the structured review comment builder with tests</name>
  <files>
    src/lib/depends-review-builder.ts
    src/lib/depends-review-builder.test.ts
  </files>
  <action>
Create `src/lib/depends-review-builder.ts` and its test file.

**Types:**
```typescript
export type DependsVerdict = {
  level: "safe" | "risky" | "needs-attention";
  emoji: string;  // checkmark, warning, stop sign
  label: string;  // "Safe to merge", "Needs attention", "Risky — review carefully"
  summary: string;  // one-line reason
};

export type DependsReviewData = {
  info: DependsBumpInfo;
  versionDiffs: Array<{
    packageName: string;
    oldVersion: string | null;
    newVersion: string | null;
    versionFileDiff: VersionFileDiff | null;
  }>;
  changelogs: Array<{ packageName: string; changelog: DependsChangelogContext }>;
  hashResults: Array<{ packageName: string; result: HashVerificationResult }>;
  patchChanges: PatchChange[];
  impact: ImpactResult | null;
  transitive: TransitiveResult | null;
  retrievalContext: string | null;  // formatted past dependency context
  platform: string | null;
};

export type InlineComment = {
  path: string;
  line: number;
  body: string;
};
```

**computeDependsVerdict(data: DependsReviewData): DependsVerdict:**
Heuristic-based verdict:
- "safe": no breaking changes, no hash mismatches, no new transitive deps, < 5 consumers
- "needs-attention": has breaking changes OR new transitive deps OR > 5 consumers OR hash unavailable
- "risky": hash mismatch OR breaking changes + many consumers OR patch removals

**buildDependsReviewComment(data: DependsReviewData): string:**
Structured markdown comment following user decisions:

1. **TL;DR verdict first:** `## {emoji} {label}` followed by summary line.
2. **Version Diff table:** `| | Old | New |` for each package with version and hash status.
3. **Changelog Highlights:** Kodi-relevant entries from upstream changelog (or degradation note).
4. **Impact Assessment:** Consumer count, file list (top 10), transitive dependencies.
   - Inline suggestions woven into this section (per user decision: "Inline suggestions woven into relevant sections rather than a separate action-item checklist").
5. **Hash Verification:** Status for each package with detail.
6. **Patch Changes:** Added/removed patches listed.
7. **Past Context:** If retrieval found relevant past reviews/wiki content, include as a "Historical Context" subsection.
8. **Platform note** for Windows bumps: "Windows dependencies use pre-built binaries without hash verification."

For multi-package bumps, structure with per-package sub-sections under shared verdict.

**buildDependsInlineComments(data: DependsReviewData, prFiles: {filename: string; patch?: string}[]): InlineComment[]:**
Generate inline comments for specific file findings:
- Hash mismatch on VERSION files -> inline comment on the SHA512 line
- Removed patches -> inline comment noting removal
- New `find_dependency()` calls in cmake files -> inline comment noting new transitive dep

**Test file:**
- Test `computeDependsVerdict()` with safe, risky, and needs-attention scenarios.
- Test `buildDependsReviewComment()` output contains expected sections: TL;DR, version diff table, changelog, impact, hash.
- Test with single-package and multi-package data.
- Test degradation: when changelog is unavailable, comment includes degradation note.
- Test `buildDependsInlineComments()` produces inline comments for hash mismatches.
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && bun test src/lib/depends-review-builder.test.ts 2>&1 | tail -10</automated>
  </verify>
  <done>Comment builder produces structured markdown with TL;DR verdict, version diff, changelog, impact, and hash sections. Inline comments generated for file-specific findings. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Wire the [depends] deep-review pipeline into the review handler</name>
  <files>src/handlers/review.ts</files>
  <action>
Modify `src/handlers/review.ts` to integrate the complete [depends] deep-review pipeline.

**Step 1: Add imports (near top of file, alongside existing dep-bump imports):**
```typescript
import { detectDependsBump, type DependsBumpInfo, type DependsBumpContext } from "../lib/depends-bump-detector.ts";
import { parseVersionFileDiff, fetchDependsChangelog, verifyHash, detectPatchChanges } from "../lib/depends-bump-enrichment.ts";
import { findDependencyConsumers, checkTransitiveDependencies } from "../lib/depends-impact-analyzer.ts";
import { buildDependsReviewComment, buildDependsInlineComments, computeDependsVerdict, type DependsReviewData } from "../lib/depends-review-builder.ts";
```

**Step 2: Insert [depends] detection BEFORE existing dep bump detection (before line ~1727):**

```typescript
// ── [depends] deep-review detection (DEPS-01/02) ──
// Runs BEFORE Dependabot detection. If matched, Dependabot path is skipped entirely.
let dependsBumpInfo: DependsBumpInfo | null = null;
try {
  dependsBumpInfo = detectDependsBump({ prTitle: pr.title });
  if (dependsBumpInfo) {
    logger.info({
      ...baseLog,
      gate: "depends-bump-detect",
      packages: dependsBumpInfo.packages.map(p => p.name),
      platform: dependsBumpInfo.platform,
      isGroup: dependsBumpInfo.isGroup,
    }, "[depends] bump detected — entering deep-review pipeline");
  }
} catch (err) {
  logger.warn({ ...baseLog, err, gate: "depends-bump-detect" }, "[depends] detection failed (fail-open)");
}
```

**Step 3: Wrap existing Dependabot detection in `if (!dependsBumpInfo)` guard:**
The existing `detectDepBump()` call and all its downstream enrichment (security advisories, changelog, merge confidence, usage analysis, scope coordination) must only run when `dependsBumpInfo` is null. This ensures mutual exclusivity (DEPS-02).

**Step 4: If `dependsBumpInfo` matched, run the [depends] enrichment pipeline (after detection, before Claude execution):**

```typescript
if (dependsBumpInfo) {
  // 1. Parse VERSION file diffs from PR files
  const versionDiffs = [];
  for (const pkg of dependsBumpInfo.packages) {
    // Find VERSION files in PR changed files matching this package
    const versionFile = prFiles.find(f =>
      f.filename.toLowerCase().includes(pkg.name.toLowerCase()) &&
      f.filename.toUpperCase().includes('VERSION')
    );
    const vFileDiff = versionFile?.patch ? parseVersionFileDiff(versionFile.patch) : null;
    versionDiffs.push({
      packageName: pkg.name,
      oldVersion: vFileDiff?.oldVersion ?? pkg.oldVersion,
      newVersion: vFileDiff?.newVersion ?? pkg.newVersion,
      versionFileDiff: vFileDiff,
    });
  }

  // 2. Fetch changelogs (parallel, with timeout)
  const changelogs = await Promise.all(
    dependsBumpInfo.packages.map(async pkg => {
      const vd = versionDiffs.find(v => v.packageName === pkg.name);
      const changelog = await fetchDependsChangelog({
        libraryName: pkg.name,
        oldVersion: vd?.oldVersion ?? null,
        newVersion: vd?.newVersion ?? pkg.newVersion,
        octokit: idempotencyOctokit,
        timeoutMs: 4000,
        versionFileDiff: vd?.versionFileDiff ?? null,
      });
      return { packageName: pkg.name, changelog };
    })
  );

  // 3. Verify hashes (parallel)
  const hashResults = await Promise.all(
    versionDiffs.map(async vd => {
      if (!vd.versionFileDiff?.newSha512) return { packageName: vd.packageName, result: { status: "skipped" as const, detail: "No hash in VERSION file" } };
      const result = await verifyHash({
        url: /* construct from versionFileDiff.newBaseUrl + newArchive */ null,
        expectedSha512: vd.versionFileDiff.newSha512,
        timeoutMs: 5000,
      });
      return { packageName: vd.packageName, result };
    })
  );

  // 4. Detect patch changes
  const patchChanges = detectPatchChanges(prFiles);

  // 5. Impact analysis (with workspace if available)
  let impact = null;
  let transitive = null;
  if (workspace) {
    try {
      const primaryPkg = dependsBumpInfo.packages[0];
      if (primaryPkg) {
        impact = await findDependencyConsumers({
          workspaceDir: workspace.dir,
          libraryName: primaryPkg.name,
          timeBudgetMs: 3000,
        });
        transitive = await checkTransitiveDependencies({
          libraryName: primaryPkg.name,
          octokit: idempotencyOctokit,
          owner: installationMeta.owner,
          repo: installationMeta.repo,
        });
      }
    } catch (err) {
      logger.warn({ ...baseLog, err, gate: "depends-impact" }, "Impact analysis failed (fail-open)");
    }
  }

  // 6. Retrieval context (past reviews/wiki about this dependency)
  let retrievalContext = null;
  try {
    // Use createRetriever() to search for past context about this dependency
    const retriever = createRetriever();
    const primaryPkg = dependsBumpInfo.packages[0];
    if (primaryPkg) {
      const results = await retriever.retrieve({
        query: `${primaryPkg.name} dependency bump update`,
        languages: ["c", "cpp", "cmake"],
        limit: 5,
      });
      if (results && results.length > 0) {
        retrievalContext = formatUnifiedContext({ results, maxTokens: 500 });
      }
    }
  } catch (err) {
    logger.warn({ ...baseLog, err, gate: "depends-retrieval" }, "Retrieval context failed (fail-open)");
  }

  // 7. Build and post the deep-review comment
  const reviewData: DependsReviewData = {
    info: dependsBumpInfo,
    versionDiffs,
    changelogs,
    hashResults,
    patchChanges,
    impact,
    transitive,
    retrievalContext,
    platform: dependsBumpInfo.platform,
  };

  const verdict = computeDependsVerdict(reviewData);
  const commentBody = buildDependsReviewComment(reviewData);
  const inlineComments = buildDependsInlineComments(reviewData, prFiles);

  // Post top-level summary comment
  await idempotencyOctokit.rest.issues.createComment({
    owner: installationMeta.owner,
    repo: installationMeta.repo,
    issue_number: pr.number,
    body: commentBody,
  });

  // Post inline review comments (if any)
  if (inlineComments.length > 0) {
    await idempotencyOctokit.rest.pulls.createReview({
      owner: installationMeta.owner,
      repo: installationMeta.repo,
      pull_number: pr.number,
      event: "COMMENT",
      comments: inlineComments.map(c => ({
        path: c.path,
        line: c.line,
        body: c.body,
      })),
    });
  }

  // 8. Determine if standard Claude review should also run
  // Per user decision: only run standard review if PR touches source code
  // beyond build configs (tools/depends/, cmake/modules/, project/BuildDependencies/)
  const buildConfigPaths = ['tools/depends/', 'cmake/modules/', 'project/BuildDependencies/', 'project/cmake/'];
  const hasSourceChanges = prFiles.some(f =>
    !buildConfigPaths.some(prefix => f.filename.startsWith(prefix)) &&
    !f.filename.toUpperCase().includes('VERSION') &&
    !f.filename.endsWith('.patch')
  );

  if (!hasSourceChanges) {
    // Pure dependency bump — skip standard Claude review, we're done
    logger.info({ ...baseLog, gate: "depends-review-complete", verdict: verdict.level }, "[depends] deep review posted, no source changes — skipping standard review");
    return; // or continue to next PR depending on handler structure
  }

  // If source changes exist, fall through to standard Claude review
  logger.info({ ...baseLog, gate: "depends-review-complete", verdict: verdict.level, hasSourceChanges }, "[depends] deep review posted, source changes detected — continuing to standard review");
}
```

**CRITICAL:** The above is pseudo-code showing the logic structure. The executor must adapt it to the actual handler structure, variable names, and error handling patterns already established in review.ts. Key points:
- Use the same `idempotencyOctokit` instance for all API calls
- Follow the existing fail-open pattern (try/catch with logger.warn, never block the pipeline)
- Use the same `baseLog` pattern for structured logging
- The `return` for pure dependency bumps must handle the handler's existing flow (check how it early-returns for other cases like isDraft)
- Wrap the entire [depends] pipeline in a try/catch so any unexpected error falls through to standard review

**Step 5: Adapt idempotency check.**
The deep-review comment should include the existing idempotency marker so re-runs don't post duplicate comments. Check the existing `idempotencyCheck` pattern and apply it to the [depends] comment.
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && bun test src/lib/depends-review-builder.test.ts 2>&1 | tail -5 && bun build src/handlers/review.ts --no-bundle 2>&1 | tail -5 && bun test src/handlers/review.test.ts 2>&1 | tail -5</automated>
  </verify>
  <done>
    1. Review handler calls detectDependsBump() before detectDepBump() -- mutual exclusivity enforced
    2. When [depends] matched, enrichment pipeline runs (changelog, hash, impact, retrieval)
    3. Structured comment posted with TL;DR verdict, version diff, changelog, impact, hash sections
    4. Inline comments posted on specific files with findings
    5. Standard Claude review only runs if PR touches source code beyond build configs
    6. All functions fail-open with logging
    7. All tests pass and handler compiles
  </done>
</task>

</tasks>

<verification>
- `bun test src/lib/depends-review-builder.test.ts` -- all tests pass
- `bun build src/handlers/review.ts --no-bundle` -- handler compiles without errors
- `bun test src/handlers/review.test.ts` -- existing review handler tests still pass
- `detectDependsBump()` is called before `detectDepBump()` in the handler
- When `detectDependsBump()` returns non-null, `detectDepBump()` is not called
- Deep review comment is posted via `issues.createComment()`
- Inline comments are posted via `pulls.createReview()` for file-specific findings
- Standard review is skipped for pure dependency bumps (no source changes)
- Standard review runs IN ADDITION when source changes are present
</verification>

<success_criteria>
1. [depends] detection gates the pipeline before Dependabot detection
2. Structured deep-review comment posted with all required sections
3. Inline review comments on files with specific findings
4. Standard Claude review conditional on source code changes
5. Entire pipeline is fail-open -- enrichment failures produce degradation notes, never block
6. Past dependency context from retrieval surfaces in the review
7. Existing Dependabot pipeline remains unchanged
8. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/94-depends-pr-deep-review/94-04-SUMMARY.md`
</output>
