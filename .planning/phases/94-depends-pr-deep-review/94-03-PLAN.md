---
phase: 94-depends-pr-deep-review
plan: 03
type: tdd
wave: 2
depends_on: [94-02]
files_modified:
  - src/lib/depends-impact-analyzer.ts
  - src/lib/depends-impact-analyzer.test.ts
autonomous: true
requirements: [DEPS-05, DEPS-07]

must_haves:
  truths:
    - "Files that #include a given library's headers and cmake files that target_link_libraries the library are found via git grep"
    - "One level of transitive includes is traced (if A includes B and B includes target, A is listed)"
    - "cmake Find modules are parsed to detect transitive dependency relationships"
    - "New transitive dependencies introduced by a bump are flagged"
    - "Analysis times out gracefully rather than blocking the review pipeline"
  artifacts:
    - path: "src/lib/depends-impact-analyzer.ts"
      provides: "Include tracing, cmake dependency parsing, transitive dependency checking"
      exports: ["findDependencyConsumers", "parseCmakeFindModule", "checkTransitiveDependencies"]
    - path: "src/lib/depends-impact-analyzer.test.ts"
      provides: "Test suite for impact analysis"
      min_lines: 100
  key_links:
    - from: "src/lib/depends-impact-analyzer.ts"
      to: "Bun shell ($)"
      via: "git grep for #include tracing"
      pattern: "\\$.*git grep"
    - from: "src/lib/depends-impact-analyzer.ts"
      to: "Octokit"
      via: "octokit.rest.repos.getContent() for cmake module files"
      pattern: "getContent"
---

<objective>
Build the impact analysis module for [depends] dependency bumps: #include tracing, cmake dependency parsing, and transitive dependency detection.

Purpose: Determine which parts of the Kodi codebase consume a bumped dependency and whether the bump introduces new transitive dependencies or version conflicts. This data powers the "Impact Assessment" section of the deep-review comment.

Output: `src/lib/depends-impact-analyzer.ts` with exported analysis functions, plus test suite.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/94-depends-pr-deep-review/94-RESEARCH.md
@src/lib/usage-analyzer.ts
@src/lib/depends-bump-enrichment.ts
</context>

<interfaces>
<!-- Existing pattern from usage-analyzer.ts for git grep -->

From src/lib/usage-analyzer.ts:
```typescript
export type UsageEvidence = { filePath: string; line: number; snippet: string; };
export type UsageAnalysisResult = { evidence: UsageEvidence[]; searchTerms: string[]; timeLimitReached: boolean; };
export function buildSearchTerms(packageName: string, snippets: string[]): string[];
export function parseGitGrepOutput(stdout: string): UsageEvidence[];
```

<!-- Types from Plan 02 -->
From src/lib/depends-bump-enrichment.ts (created in Plan 02):
```typescript
export type VersionFileDiff = { oldVersion, newVersion, oldSha512, newSha512, ... };
export function resolveUpstreamRepo(libraryName: string): { owner: string; repo: string } | null;
```
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for include tracing, cmake parsing, and transitive dependency checking</name>
  <files>src/lib/depends-impact-analyzer.test.ts</files>
  <action>
Create test file `src/lib/depends-impact-analyzer.test.ts`.

**findDependencyConsumers() tests:**
These test the pure parsing logic (mock git grep output, don't actually run git grep in tests).

1. Standard `#include <zlib.h>` -- matched for library "zlib"
2. Subdirectory include `#include <openssl/ssl.h>` -- matched for library "openssl"
3. Quoted include `#include "libxml/parser.h"` -- matched for library "libxml"
4. Non-matching include `#include <string.h>` -- NOT matched for library "zlib"
5. Multiple files with includes -- all returned
6. Empty grep output -> empty results
7. Timeout scenario -> partial results with `timeLimitReached: true`
8. cmake `target_link_libraries(foo zlib)` in CMakeLists.txt -- matched as `isDirect: true` consumer for library "zlib"
9. cmake `target_link_libraries(bar PRIVATE openssl::ssl)` -- matched for library "openssl"
10. Deduplication: file found via both `#include` and `target_link_libraries` appears only once

**parseCmakeFindModule() tests:**
Parse cmake `Find*.cmake` module content for dependency declarations.

1. Module with `find_dependency(Freetype)` -- returns ["freetype"] as dependency
2. Module with `find_package(Iconv REQUIRED)` -- returns ["iconv"]
3. Module with multiple dependencies
4. Module with no dependencies -- returns empty array
5. Comment-only lines with find_dependency -- ignored

**checkTransitiveDependencies() tests:**
1. Library A depends on library B (via cmake), and B is being bumped -> flag "A depends on B"
2. No transitive dependencies found -> empty result
3. Circular dependency (freetype <-> harfbuzz) -> detected and noted
4. New `find_dependency()` call in updated cmake config vs old -> flagged as new transitive dep

Run tests -- they MUST fail (RED).
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && bun test src/lib/depends-impact-analyzer.test.ts 2>&1 | tail -5</automated>
  </verify>
  <done>Test file exists with 15+ test cases covering all impact analysis functions, all failing</done>
</task>

<task type="auto">
  <name>Task 2: Implement impact analysis functions to pass all tests</name>
  <files>src/lib/depends-impact-analyzer.ts</files>
  <action>
Create `src/lib/depends-impact-analyzer.ts` implementing:

**Types:**
```typescript
export type IncludeConsumer = {
  filePath: string;
  line: number;
  includeDirective: string;
  isDirect: boolean;  // true = directly includes library, false = transitive (one level)
};

export type CmakeDependency = {
  moduleName: string;  // e.g., "FindHarfBuzz"
  dependsOn: string[];  // e.g., ["freetype", "icu"]
};

export type TransitiveResult = {
  dependents: string[];  // libraries that depend on the bumped library
  newDependencies: string[];  // new find_dependency() calls not in old version
  circular: string[];  // circular dependency pairs detected
};

export type ImpactResult = {
  consumers: IncludeConsumer[];
  transitive: TransitiveResult;
  timeLimitReached: boolean;
  degradationNote: string | null;
};
```

**findDependencyConsumers(params):**
Accept `{workspaceDir, libraryName, octokit, owner, repo, timeBudgetMs}`.

1. Build grep patterns for the library:
   - `#include.*<${libraryName}[/.]` -- angle bracket includes
   - `#include.*"${libraryName}[/.]` -- quoted includes
   - Also match the bare header: `#include.*<${libraryName}.h>` for libraries like zlib
2. Run `git grep -n` in the workspace with Bun shell `$`, with `AbortSignal.timeout(timeBudgetMs)`.
3. Parse output using a function similar to `parseGitGrepOutput()` from usage-analyzer.ts.
4. Mark all as `isDirect: true`.
4b. **cmake consumer pass:** Run a second `git grep -n` for `target_link_libraries.*${libraryName}` scoped to `CMakeLists.txt` files (use `-- '*/CMakeLists.txt'` pathspec). Parse results and add as `isDirect: true` consumers with `includeDirective` set to the matched `target_link_libraries(...)` line. Deduplicate by filePath if a file already appeared in the `#include` results.
5. For one-level transitive tracing: from the found files, extract which headers THEY export/include, and search for consumers of those. Mark as `isDirect: false`. Keep this bounded (max 50 transitive results).
6. On timeout, return partial results with `timeLimitReached: true`.
7. On error, return empty results with `degradationNote`.

**parseCmakeFindModule(content: string): CmakeDependency:**
Parse cmake module file content.
1. Look for `find_dependency(XXX)` and `find_package(XXX ...)` calls.
2. Extract the package name (first argument).
3. Normalize to lowercase.
4. Return `{moduleName, dependsOn}`.

**checkTransitiveDependencies(params):**
Accept `{libraryName, octokit, owner, repo, oldFiles?, newFiles?}`.

1. Fetch cmake `Find*.cmake` modules from the repo (use Octokit `getContent` on `cmake/modules/` directory).
2. Parse each module to find dependencies.
3. Find modules where the bumped library appears in `dependsOn` -- these are dependents.
4. If old/new cmake file content is provided (from PR diff), compare `find_dependency` calls to detect new transitive deps.
5. Detect circular dependencies (A depends on B AND B depends on A).
6. Fail-open: on any error, return empty results with note.

All functions must respect time budgets and fail gracefully. Import `resolveUpstreamRepo` from `depends-bump-enrichment.ts` if needed.
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && bun test src/lib/depends-impact-analyzer.test.ts 2>&1 | tail -10</automated>
  </verify>
  <done>All impact analysis tests pass. Include tracing, cmake parsing, and transitive dependency checking all work correctly with timeouts and graceful degradation.</done>
</task>

</tasks>

<verification>
- `bun test src/lib/depends-impact-analyzer.test.ts` -- all tests pass
- `findDependencyConsumers()` finds direct and one-level transitive includes
- `parseCmakeFindModule()` extracts dependency declarations from cmake modules
- `checkTransitiveDependencies()` identifies dependents and new transitive deps
- All functions timeout gracefully and never throw
</verification>

<success_criteria>
1. #include consumers found via git grep patterns for C/C++ libraries
2. One level of transitive include tracing works
3. cmake Find modules parsed for dependency declarations
4. New transitive dependencies flagged by comparing old/new cmake configs
5. All functions respect time budgets with fail-open degradation
6. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/94-depends-pr-deep-review/94-03-SUMMARY.md`
</output>
