---
phase: 51-timeout-resilience
plan: 02
type: execute
wave: 2
depends_on: ["51-01"]
files_modified:
  - src/handlers/review.ts
  - src/lib/errors.ts
autonomous: true

must_haves:
  truths:
    - "Before executing a review, the handler estimates timeout risk and logs the assessment"
    - "High-risk PRs with auto-selected profile get scope reduced to minimal profile and capped file count"
    - "High-risk PRs with user-explicit profile are NOT scope-reduced (user choice respected)"
    - "When a timeout occurs and inline comments were published, the user sees a partial-review message (not an error)"
    - "When a timeout occurs and nothing was published, the user sees an informative error with PR complexity context"
    - "Telemetry conclusion distinguishes timeout_partial from timeout"
  artifacts:
    - path: "src/handlers/review.ts"
      provides: "Pre-review timeout estimation, scope reduction, informative timeout messages"
      contains: "estimateTimeoutRisk"
    - path: "src/lib/errors.ts"
      provides: "timeout_partial error category"
      contains: "timeout_partial"
  key_links:
    - from: "src/handlers/review.ts"
      to: "src/lib/timeout-estimator.ts"
      via: "import estimateTimeoutRisk, computeLanguageComplexity"
      pattern: "import.*estimateTimeoutRisk.*timeout-estimator"
    - from: "src/handlers/review.ts"
      to: "src/execution/executor.ts"
      via: "passes dynamicTimeoutSeconds in execute() call"
      pattern: "dynamicTimeoutSeconds.*timeoutEstimate"
    - from: "src/handlers/review.ts"
      to: "src/lib/errors.ts"
      via: "uses timeout_partial category for partial review messages"
      pattern: "timeout_partial"
---

<objective>
Integrate timeout estimation into the review handler for scope reduction and informative timeout messages.

Purpose: TMO-02 (auto-reduce scope for high-risk PRs) and TMO-03 (informative timeout messages instead of generic errors). This completes all four timeout resilience requirements.

Output: Review handler that estimates timeout risk before execution, reduces scope when appropriate, and posts informative messages on timeout with partial review context.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/51-timeout-resilience/51-RESEARCH.md
@.planning/phases/51-timeout-resilience/51-01-SUMMARY.md
@src/handlers/review.ts
@src/lib/errors.ts
@src/lib/auto-profile.ts
@src/lib/timeout-estimator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add timeout estimation and scope reduction to review handler</name>
  <files>src/handlers/review.ts</files>
  <action>
Import `estimateTimeoutRisk` and `computeLanguageComplexity` from `../lib/timeout-estimator.ts`.

**Integration point 1: After diff analysis, before executor.execute() (around line 1467-1614)**

After `profileSelection` is computed (around line 1472) and after `diffAnalysis` is available (around line 1356), add timeout estimation:

```typescript
// TMO-01: Estimate timeout risk
const languageComplexity = computeLanguageComplexity(
  diffAnalysis?.filesByLanguage ?? {},
);
const timeoutEstimate = estimateTimeoutRisk({
  fileCount: changedFiles.length,
  linesChanged: (diffAnalysis?.metrics.totalLinesAdded ?? 0) +
    (diffAnalysis?.metrics.totalLinesRemoved ?? 0),
  languageComplexity,
  isLargePR: diffAnalysis?.isLargePR ?? false,
  baseTimeoutSeconds: config.timeoutSeconds,
});

logger.info(
  {
    ...baseLog,
    gate: "timeout-estimation",
    riskLevel: timeoutEstimate.riskLevel,
    dynamicTimeout: timeoutEstimate.dynamicTimeoutSeconds,
    shouldReduceScope: timeoutEstimate.shouldReduceScope,
    complexity: timeoutEstimate.reasoning,
  },
  "Timeout risk estimated",
);
```

**Integration point 2: Scope reduction for high-risk auto-profile PRs**

After the timeout estimation, BEFORE the prompt is built, check if scope should be reduced. Only reduce when BOTH conditions are true:
- `timeoutEstimate.shouldReduceScope === true`
- `profileSelection.source === "auto"` (user did NOT explicitly set a profile)
- `config.timeout.autoReduceScope === true` (feature enabled in config, defaults true)

When reducing scope:
- Override `profileSelection` to use "minimal" profile: set `selectedProfile` to "minimal" and apply the minimal preset settings (same pattern as the existing keyword/auto profile application)
- If `timeoutEstimate.reducedFileCount` is set and `tieredFiles` has more than that many full-review files, truncate `tieredFiles.full` to that count (move extras to `tieredFiles.abbreviated`)
- Log the scope reduction decision:
  ```typescript
  logger.info(
    {
      ...baseLog,
      gate: "timeout-scope-reduction",
      originalProfile: originalProfileSelection.selectedProfile,
      reducedProfile: "minimal",
      originalFileCount: tieredFiles.full.length,
      reducedFileCount: timeoutEstimate.reducedFileCount,
    },
    "Auto-reduced review scope for high timeout risk",
  );
  ```

When NOT reducing scope because user explicitly set profile, log a warning:
```typescript
if (timeoutEstimate.shouldReduceScope && profileSelection.source !== "auto") {
  logger.warn(
    {
      ...baseLog,
      gate: "timeout-scope-reduction",
      gateResult: "skipped",
      skipReason: "explicit-profile",
      profile: profileSelection.selectedProfile,
      source: profileSelection.source,
    },
    "Skipping scope reduction: user explicitly configured profile",
  );
}
```

**Integration point 3: Pass dynamic timeout to executor**

In the `executor.execute()` call (around line 1614), add `dynamicTimeoutSeconds`:
```typescript
dynamicTimeoutSeconds: config.timeout.dynamicScaling
  ? timeoutEstimate.dynamicTimeoutSeconds
  : undefined,
```

This respects the config flag -- when dynamicScaling is disabled, the executor falls back to config.timeoutSeconds.

IMPORTANT: Place the timeout estimation code AFTER diffAnalysis is computed (line ~1356) and AFTER profileSelection is computed (line ~1468), but BEFORE the prompt is built and the executor is called.
  </action>
  <verify>Run `npx tsc --noEmit` -- no type errors. Run `npx vitest run src/handlers/` -- existing handler tests pass.</verify>
  <done>Review handler estimates timeout risk before execution, auto-reduces scope for high-risk auto-profile PRs, respects explicit user profiles, and passes dynamic timeout to executor.</done>
</task>

<task type="auto">
  <name>Task 2: Replace generic timeout errors with informative messages</name>
  <files>src/handlers/review.ts, src/lib/errors.ts</files>
  <action>
**src/lib/errors.ts** -- Add `"timeout_partial"` to the `ErrorCategory` union type:
```typescript
export type ErrorCategory =
  | "timeout"
  | "timeout_partial"
  | "api_error"
  | "config_error"
  | "clone_error"
  | "internal_error";
```

Add entries to HEADERS and SUGGESTIONS:
```typescript
// In HEADERS:
timeout_partial: "Kodiai completed a partial review",

// In SUGGESTIONS:
timeout_partial:
  "Some inline comments were posted above. To get a full review, increase `timeoutSeconds` in `.kodiai.yml` or break the PR into smaller changes.",
```

Update `classifyError` to return `"timeout_partial"` when both `isTimeout` and a new `published` parameter are true. Change the signature:
```typescript
export function classifyError(
  error: unknown,
  isTimeout: boolean,
  published?: boolean,
): ErrorCategory {
  if (isTimeout && published) return "timeout_partial";
  if (isTimeout) return "timeout";
  // ... rest unchanged
}
```

**src/handlers/review.ts** -- Replace the timeout error handling block (lines 2279-2294). Currently it posts a generic error for all timeout/error results. Change to:

```typescript
// Post error or partial-review comment if execution failed or timed out
if (result.conclusion === "error") {
  const category = classifyError(
    new Error(result.errorMessage ?? "Unknown error"),
    result.isTimeout ?? false,
    result.published ?? false,
  );

  let errorBody: string;
  if (category === "timeout_partial") {
    // TMO-03: Partial review -- inline comments were published before timeout
    errorBody = formatErrorComment(
      category,
      `Timed out after ${timeoutEstimate.dynamicTimeoutSeconds}s. ` +
      `PR complexity: ${timeoutEstimate.reasoning}`,
    );
  } else if (category === "timeout") {
    // TMO-03: Full timeout -- nothing was published
    errorBody = formatErrorComment(
      category,
      `Timed out after ${timeoutEstimate.dynamicTimeoutSeconds}s with no review output. ` +
      `PR complexity: ${timeoutEstimate.reasoning}`,
    );
  } else {
    errorBody = formatErrorComment(
      category,
      result.errorMessage ?? "An unexpected error occurred during review.",
    );
  }

  const octokit = await githubApp.getInstallationOctokit(event.installationId);
  await postOrUpdateErrorComment(octokit, {
    owner: apiOwner,
    repo: apiRepo,
    issueNumber: pr.number,
  }, sanitizeOutgoingMentions(errorBody, [githubApp.getAppSlug(), "claude"]), logger);
}
```

Make sure `timeoutEstimate` is accessible in this scope. It should be declared in the same function scope as the executor call (both are inside the review handler's main try block). If `timeoutEstimate` is not available (e.g., error happened before estimation), fall back to `config.timeoutSeconds` for the timeout value in the message.

Also update the telemetry conclusion recording (if it exists in the handler). When `result.isTimeout && result.published`, record conclusion as `"timeout_partial"`. When `result.isTimeout && !result.published`, record as `"timeout"`. Search for where `result.conclusion` is used in telemetry/logging and ensure the distinction is captured.

IMPORTANT per research Pitfall 1: Do NOT change knowledge store recording. When `result.isTimeout === true`, the existing behavior of skipping learning memory writes should remain unchanged.
  </action>
  <verify>Run `npx tsc --noEmit` -- no type errors. Run `npx vitest run src/lib/errors` -- error classification tests pass (including new timeout_partial). Run `npx vitest run src/handlers/` -- handler tests pass.</verify>
  <done>Timeout errors show informative messages with PR complexity context. Partial reviews (published=true) get a different message than full timeouts (published=false). Users see what was reviewed and actionable suggestions instead of a generic "timed out" error. Telemetry distinguishes timeout_partial from timeout.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npx vitest run` -- all tests pass (estimator, errors, handlers, executor)
- Manually trace code path: large PR (80 files, 2000 lines) -> high risk -> scope reduced to minimal + 50 files -> dynamic timeout ~1.5x base -> if timeout with published=true -> partial review message
- Manually trace code path: small PR (3 files, 50 lines) -> low risk -> no scope change -> dynamic timeout ~0.5x base -> if timeout -> full timeout message with complexity info
- Manually trace code path: user sets profile=strict on large PR -> high risk -> scope NOT reduced (explicit profile) -> warning logged -> dynamic timeout still applied
</verification>

<success_criteria>
- High-risk auto-profile PRs get scope reduced to minimal profile with capped file count
- Explicit user profiles are never overridden by scope reduction
- Timeout with published inline comments produces "partial review" message with scope context
- Timeout with no published output produces informative error with complexity reasoning
- All four requirements satisfied: TMO-01 (estimation), TMO-02 (scope reduction), TMO-03 (informative messages), TMO-04 (dynamic timeout)
- telemetry distinguishes timeout_partial from timeout conclusions
</success_criteria>

<output>
After completion, create `.planning/phases/51-timeout-resilience/51-02-SUMMARY.md`
</output>
