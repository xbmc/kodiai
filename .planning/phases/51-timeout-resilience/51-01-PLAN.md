---
phase: 51-timeout-resilience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/timeout-estimator.ts
  - src/lib/timeout-estimator.test.ts
  - src/execution/types.ts
  - src/execution/executor.ts
  - src/execution/config.ts
autonomous: true

must_haves:
  truths:
    - "A pure function computes timeout risk level, dynamic timeout, and scope reduction recommendation from PR metrics"
    - "The executor uses a dynamic timeout passed via ExecutionContext instead of only the static config value"
    - "Dynamic timeout scales between 0.5x and 1.5x of the base timeout, clamped to [30, 1800]"
    - "Language complexity is computed from the existing LANGUAGE_RISK map weighted by file count per language"
  artifacts:
    - path: "src/lib/timeout-estimator.ts"
      provides: "estimateTimeoutRisk() and computeLanguageComplexity() pure functions"
      exports: ["estimateTimeoutRisk", "computeLanguageComplexity", "TimeoutEstimate", "TimeoutRiskLevel"]
    - path: "src/lib/timeout-estimator.test.ts"
      provides: "Unit tests for timeout estimator"
      contains: "estimateTimeoutRisk"
    - path: "src/execution/types.ts"
      provides: "dynamicTimeoutSeconds field on ExecutionContext"
      contains: "dynamicTimeoutSeconds"
    - path: "src/execution/executor.ts"
      provides: "Dynamic timeout override from context"
      contains: "dynamicTimeoutSeconds"
    - path: "src/execution/config.ts"
      provides: "Timeout config subsection with dynamicScaling and autoReduceScope flags"
      contains: "dynamicScaling"
  key_links:
    - from: "src/lib/timeout-estimator.ts"
      to: "src/lib/file-risk-scorer.ts"
      via: "import LANGUAGE_RISK"
      pattern: "import.*LANGUAGE_RISK.*file-risk-scorer"
    - from: "src/execution/executor.ts"
      to: "src/execution/types.ts"
      via: "reads dynamicTimeoutSeconds from context"
      pattern: "context\\.dynamicTimeoutSeconds"
---

<objective>
Create the timeout estimation engine and wire dynamic timeouts into the executor.

Purpose: TMO-01 (estimate timeout risk from PR metrics) and TMO-04 (dynamic timeout scaling) form the foundation that Plan 02 builds on for scope reduction and informative messages.

Output: A pure-function timeout estimator module with tests, ExecutionContext extended with dynamicTimeoutSeconds, executor using the dynamic value, and config schema supporting timeout tuning flags.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/51-timeout-resilience/51-RESEARCH.md
@src/execution/types.ts
@src/execution/executor.ts
@src/execution/config.ts
@src/lib/file-risk-scorer.ts
@src/execution/diff-analysis.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create timeout estimator module with tests</name>
  <files>src/lib/timeout-estimator.ts, src/lib/timeout-estimator.test.ts</files>
  <action>
Create `src/lib/timeout-estimator.ts` with two exported pure functions:

1. `computeLanguageComplexity(filesByLanguage: Record<string, string[]>): number`
   - Import `LANGUAGE_RISK` from `../lib/file-risk-scorer.ts` (the existing map: C=1.0, TypeScript=0.4, etc.)
   - Compute weighted average: for each language, multiply its LANGUAGE_RISK value by the number of files, sum all, divide by total files
   - Default to 0.3 (the "Unknown" risk) when no files present
   - Return a number between 0 and 1

2. `estimateTimeoutRisk(params: { fileCount: number; linesChanged: number; languageComplexity: number; isLargePR: boolean; baseTimeoutSeconds: number }): TimeoutEstimate`
   - Compute complexity score: `fileScore * 0.4 + lineScore * 0.4 + langScore * 0.2`
     - `fileScore = Math.min(fileCount / 100, 1.0)` (100 files = max)
     - `lineScore = Math.min(linesChanged / 5000, 1.0)` (5000 lines = max)
     - `langScore = languageComplexity` (0-1 from computeLanguageComplexity)
   - Risk level: complexity < 0.3 = "low", < 0.6 = "medium", >= 0.6 = "high"
   - Dynamic timeout: `baseTimeoutSeconds * (0.5 + complexity)` -- this gives range [0.5x, 1.5x] of base
     - Clamp to `Math.max(30, Math.min(computed, 1800))`
     - Round to nearest integer
   - shouldReduceScope: true when riskLevel === "high"
   - reducedFileCount: when shouldReduceScope, cap at 50 files; otherwise null
   - reasoning: human-readable string with complexity score, file count, line count, lang risk percentage, risk level, and computed timeout

Export types: `TimeoutRiskLevel = "low" | "medium" | "high"` and `TimeoutEstimate` (with fields: riskLevel, dynamicTimeoutSeconds, shouldReduceScope, reducedFileCount, reasoning).

Create `src/lib/timeout-estimator.test.ts` with tests covering:
- Small PR (3 files, 50 lines, TypeScript): risk=low, timeout < baseTimeout
- Medium PR (30 files, 800 lines, mixed languages): risk=medium
- Large PR (80 files, 2000 lines, C/C++): risk=high, shouldReduceScope=true, reducedFileCount=50
- Edge: 0 files returns low risk
- Edge: empty filesByLanguage returns default 0.3 complexity
- Timeout clamping: never below 30, never above 1800
- Dynamic timeout scales proportionally (small PR gets less time than large PR)

Use the project's existing test setup (vitest). Follow existing test file patterns in the codebase.
  </action>
  <verify>Run `npx vitest run src/lib/timeout-estimator.test.ts` -- all tests pass. Run `npx tsc --noEmit` -- no type errors.</verify>
  <done>estimateTimeoutRisk and computeLanguageComplexity are pure functions with full test coverage. A 3-file/50-line TypeScript PR produces low risk with reduced timeout; an 80-file/2000-line C PR produces high risk with increased timeout and scope reduction recommendation.</done>
</task>

<task type="auto">
  <name>Task 2: Wire dynamic timeout into executor and config</name>
  <files>src/execution/types.ts, src/execution/executor.ts, src/execution/config.ts</files>
  <action>
**src/execution/types.ts** -- Add to `ExecutionContext`:
```typescript
/** Optional dynamic timeout override (seconds). When set, overrides config.timeoutSeconds. */
dynamicTimeoutSeconds?: number;
```
Place it after the existing `deliveryId` field.

**src/execution/executor.ts** -- At line ~41 where `timeoutSeconds = config.timeoutSeconds;` is set, change to:
```typescript
timeoutSeconds = context.dynamicTimeoutSeconds ?? config.timeoutSeconds;
```
Add a log line after the existing timeout log that includes the source:
```typescript
logger.info(
  { timeoutMs, source: context.dynamicTimeoutSeconds ? "dynamic" : "config" },
  "Timeout enforcement configured",
);
```
(Replace the existing log line at line ~48, do not add a duplicate.)

**src/execution/config.ts** -- Add a timeout configuration subsection to the config parsing. After the `timeoutSeconds` parsing block (around line 517), add parsing for two new optional boolean fields:
- `timeout.dynamicScaling` (boolean, default true) -- enables dynamic timeout scaling
- `timeout.autoReduceScope` (boolean, default true) -- enables automatic scope reduction for high-risk PRs

These go into the config object as `timeout: { dynamicScaling: boolean; autoReduceScope: boolean }`. Add the type to the `RepoConfig` type definition. Use the same zod parsing pattern as other config fields (safeParse with fallback defaults). The `.kodiai.yml` shape would be:
```yaml
timeout:
  dynamicScaling: true
  autoReduceScope: true
```

Make sure the existing `timeoutSeconds` field continues to work unchanged -- it is the base timeout. The new `timeout` subsection controls whether the dynamic features are enabled.
  </action>
  <verify>Run `npx tsc --noEmit` -- no type errors. Run `npx vitest run src/execution/` -- existing executor tests still pass. Verify that `RepoConfig` type now includes `timeout` field.</verify>
  <done>ExecutionContext accepts dynamicTimeoutSeconds. Executor uses it when present, falls back to config.timeoutSeconds. Config schema supports timeout.dynamicScaling and timeout.autoReduceScope flags with defaults of true.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npx vitest run src/lib/timeout-estimator.test.ts` -- all estimator tests pass
- `npx vitest run src/execution/` -- all existing executor/config tests pass
- The timeout estimator is a pure function with no I/O dependencies
- LANGUAGE_RISK is imported from existing file-risk-scorer.ts, not duplicated
</verification>

<success_criteria>
- estimateTimeoutRisk() correctly classifies small/medium/large PRs into low/medium/high risk
- Dynamic timeout scales between 0.5x-1.5x of base, clamped to [30, 1800]
- High-risk PRs get shouldReduceScope=true with reducedFileCount capped at 50
- ExecutionContext.dynamicTimeoutSeconds flows through to executor timeout enforcement
- Config supports enabling/disabling dynamic timeout features
- All tests pass, no type errors
</success_criteria>

<output>
After completion, create `.planning/phases/51-timeout-resilience/51-01-SUMMARY.md`
</output>
