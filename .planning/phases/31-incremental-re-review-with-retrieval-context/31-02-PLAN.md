---
phase: 31-incremental-re-review-with-retrieval-context
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/incremental-diff.ts
  - src/lib/finding-dedup.ts
  - src/lib/incremental-diff.test.ts
  - src/lib/finding-dedup.test.ts
autonomous: true

must_haves:
  truths:
    - "computeIncrementalDiff returns mode=incremental with changed files when prior SHA is reachable"
    - "computeIncrementalDiff returns mode=full with reason when prior SHA is unreachable or missing"
    - "buildPriorFindingContext partitions findings into unchanged-code context vs suppression fingerprints"
    - "Findings on changed files are NOT suppressed (treated as new)"
    - "Findings on unchanged files generate suppression fingerprints"
  artifacts:
    - path: "src/lib/incremental-diff.ts"
      provides: "computeIncrementalDiff function returning IncrementalDiffResult"
      exports: ["computeIncrementalDiff", "IncrementalDiffResult"]
    - path: "src/lib/finding-dedup.ts"
      provides: "buildPriorFindingContext function returning PriorFindingContext"
      exports: ["buildPriorFindingContext", "PriorFindingContext"]
    - path: "src/lib/incremental-diff.test.ts"
      provides: "Unit tests for incremental diff computation"
      min_lines: 30
    - path: "src/lib/finding-dedup.test.ts"
      provides: "Unit tests for finding dedup logic"
      min_lines: 30
  key_links:
    - from: "src/lib/incremental-diff.ts"
      to: "src/knowledge/types.ts"
      via: "KnowledgeStore type for getLastReviewedHeadSha"
      pattern: "KnowledgeStore"
    - from: "src/lib/finding-dedup.ts"
      to: "src/knowledge/types.ts"
      via: "PriorFinding type"
      pattern: "PriorFinding"
---

<objective>
Create the incremental diff computation and finding deduplication utility modules.

Purpose: These are pure logic modules that determine (1) which files changed since the last reviewed head SHA and (2) which prior findings to suppress vs keep as context. They are stateless utilities consumed by the review handler in Plan 03.

Output: Two tested modules with clear type contracts.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-incremental-re-review-with-retrieval-context/31-RESEARCH.md
@src/knowledge/types.ts
@src/handlers/review.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create incremental diff computation module</name>
  <files>src/lib/incremental-diff.ts, src/lib/incremental-diff.test.ts</files>
  <action>
Create `src/lib/incremental-diff.ts`:

1. Define and export `IncrementalDiffResult`:
```typescript
export type IncrementalDiffResult = {
  mode: "incremental" | "full";
  changedFilesSinceLastReview: string[];
  lastReviewedHeadSha: string | null;
  reason: string;
};
```

2. Export `async function computeIncrementalDiff(params)` with parameters:
- `workspaceDir: string`
- `repo: string`
- `prNumber: number`
- `getLastReviewedHeadSha: (params: { repo: string; prNumber: number }) => string | null` -- pass the function directly rather than full KnowledgeStore to keep the module loosely coupled
- `logger: Logger`

3. Implementation flow (all with fail-open semantics):
   a. Call `getLastReviewedHeadSha({ repo, prNumber })`. If null, return `{ mode: "full", changedFilesSinceLastReview: [], lastReviewedHeadSha: null, reason: "no-prior-review" }`.
   b. Check if the old head SHA is reachable: `git -C ${workspaceDir} cat-file -t ${lastHeadSha}`. Use `$` from bun with `.quiet().nothrow()`. If unreachable (exitCode !== 0), attempt `git -C ${workspaceDir} fetch --deepen=100`. Re-check reachability. If still unreachable, return `{ mode: "full", ..., reason: "prior-sha-unreachable" }`.
   c. Compute diff: `git -C ${workspaceDir} diff ${lastHeadSha}...HEAD --name-only`. If fails, return `{ mode: "full", ..., reason: "diff-computation-failed" }`.
   d. Parse output: split by newline, filter empty. Return `{ mode: "incremental", changedFilesSinceLastReview: changedFiles, lastReviewedHeadSha: lastHeadSha, reason: "incremental-from-<sha7>" }`.
   e. Wrap the entire function body in try/catch. On ANY unexpected error, log warning and return mode: "full" with reason "unexpected-error". This ensures fail-open.

Create `src/lib/incremental-diff.test.ts`:

Test the function with a mock `getLastReviewedHeadSha`. Since git operations require a real workspace, focus on:
- "returns mode=full when getLastReviewedHeadSha returns null"
- "returns IncrementalDiffResult with correct type shape"

For the git-dependent paths, add a comment noting these are integration-tested in the review handler tests. The unit tests focus on the null/missing-SHA early-return paths which don't need git.
  </action>
  <verify>Run `bun test src/lib/incremental-diff.test.ts` -- all tests pass.</verify>
  <done>Module exports `computeIncrementalDiff` that returns `IncrementalDiffResult` with mode "incremental" (changed files list) or "full" (with reason). Fail-open: any error degrades to full review.</done>
</task>

<task type="auto">
  <name>Task 2: Create finding deduplication module</name>
  <files>src/lib/finding-dedup.ts, src/lib/finding-dedup.test.ts</files>
  <action>
Create `src/lib/finding-dedup.ts`:

1. Import `PriorFinding` from `../knowledge/types.ts` (Plan 01 adds this type).

2. Define and export `PriorFindingContext`:
```typescript
export type PriorFindingContext = {
  unresolvedOnUnchangedCode: PriorFinding[];
  suppressionFingerprints: Set<string>;
};
```

3. Export `function buildPriorFindingContext(params)`:
- `priorFindings: PriorFinding[]`
- `changedFilesSinceLastReview: string[]`

Implementation:
- Create `changedFilesSet = new Set(changedFilesSinceLastReview)`
- Iterate over priorFindings:
  - If `changedFilesSet.has(finding.filePath)` -- the file changed, skip (don't suppress, let reviewer re-evaluate)
  - Otherwise, the file is unchanged: add to `unresolvedOnUnchangedCode` array, add `${finding.filePath}:${finding.titleFingerprint}` to `suppressionFingerprints` Set
- Return `{ unresolvedOnUnchangedCode, suppressionFingerprints }`

4. Export `function shouldSuppressFinding(params)`:
- `filePath: string`
- `titleFingerprint: string`
- `suppressionFingerprints: Set<string>`
Returns `boolean`: true if `${filePath}:${titleFingerprint}` is in the set.

This is the function the review handler will use to check new findings against prior ones.

Create `src/lib/finding-dedup.test.ts`:

Add 5 tests:
- "returns empty context when no prior findings"
- "findings on unchanged files are added to unresolvedOnUnchangedCode"
- "findings on changed files are excluded from context"
- "suppressionFingerprints contains filePath:titleFingerprint for unchanged-file findings"
- "shouldSuppressFinding returns true for matching fingerprint, false for non-matching"

Use inline PriorFinding objects with mock data. No external dependencies needed.
  </action>
  <verify>Run `bun test src/lib/finding-dedup.test.ts` -- all 5 tests pass. Run `bun test` for full suite.</verify>
  <done>Module exports `buildPriorFindingContext` and `shouldSuppressFinding`. Prior findings on unchanged files become suppression fingerprints; findings on changed files are excluded (reviewer re-evaluates). All tests green.</done>
</task>

</tasks>

<verification>
- `bun test src/lib/incremental-diff.test.ts` passes
- `bun test src/lib/finding-dedup.test.ts` passes
- `bun test` full suite passes
- Types compile cleanly: `bun build src/index.ts --target=bun`
</verification>

<success_criteria>
- computeIncrementalDiff handles: no prior review (full), unreachable SHA (full with deepen attempt), successful diff (incremental), any error (full, fail-open)
- buildPriorFindingContext correctly partitions findings by whether their file changed
- shouldSuppressFinding provides a simple lookup against the fingerprint set
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/31-incremental-re-review-with-retrieval-context/31-02-SUMMARY.md`
</output>
