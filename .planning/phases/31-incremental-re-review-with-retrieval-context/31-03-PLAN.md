---
phase: 31-incremental-re-review-with-retrieval-context
plan: 03
type: execute
wave: 2
depends_on: ["31-01", "31-02"]
files_modified:
  - src/handlers/review.ts
  - src/execution/review-prompt.ts
autonomous: true

must_haves:
  truths:
    - "pull_request.synchronize events trigger review when onSynchronize is enabled"
    - "Synchronize events compute incremental diff and only review changed files"
    - "Prior findings on unchanged code are injected as context in the review prompt"
    - "New findings matching prior finding fingerprints on unchanged files are suppressed"
    - "Retrieval context from learning memory is injected into the review prompt"
    - "If incremental diff fails, review proceeds as full review (fail-open)"
    - "If retrieval fails, review proceeds without retrieval context (fail-open)"
    - "review_requested events also attempt incremental mode if prior completed review exists"
  artifacts:
    - path: "src/handlers/review.ts"
      provides: "Synchronize event registration, incremental diff wiring, dedup suppression, retrieval context"
      contains: "pull_request.synchronize"
    - path: "src/execution/review-prompt.ts"
      provides: "buildIncrementalReviewSection and buildRetrievalContextSection functions"
      exports: ["buildIncrementalReviewSection", "buildRetrievalContextSection"]
  key_links:
    - from: "src/handlers/review.ts"
      to: "src/lib/incremental-diff.ts"
      via: "computeIncrementalDiff call"
      pattern: "computeIncrementalDiff"
    - from: "src/handlers/review.ts"
      to: "src/lib/finding-dedup.ts"
      via: "buildPriorFindingContext and shouldSuppressFinding calls"
      pattern: "buildPriorFindingContext|shouldSuppressFinding"
    - from: "src/handlers/review.ts"
      to: "src/learning/isolation.ts"
      via: "IsolationLayer.retrieveWithIsolation for retrieval context"
      pattern: "retrieveWithIsolation"
    - from: "src/execution/review-prompt.ts"
      to: "buildReviewPrompt"
      via: "New optional parameters for incremental and retrieval sections"
      pattern: "incrementalContext|retrievalContext"
---

<objective>
Wire incremental diff, finding deduplication, and retrieval context into the review handler and prompt builder.

Purpose: This is the integration plan that connects all Phase 31 infrastructure (config, KnowledgeStore queries, incremental diff, finding dedup, retrieval) into the live review pipeline. After this plan, synchronize events trigger incremental re-reviews, prior findings inform dedup, and learning memory enriches prompts.

Output: Working incremental re-review with retrieval context, all fail-open.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-incremental-re-review-with-retrieval-context/31-RESEARCH.md
@.planning/phases/31-incremental-re-review-with-retrieval-context/31-01-SUMMARY.md
@.planning/phases/31-incremental-re-review-with-retrieval-context/31-02-SUMMARY.md
@src/handlers/review.ts
@src/execution/review-prompt.ts
@src/execution/config.ts
@src/knowledge/types.ts
@src/learning/types.ts
@src/learning/isolation.ts
@src/lib/incremental-diff.ts
@src/lib/finding-dedup.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add incremental review and retrieval context sections to the review prompt builder</name>
  <files>src/execution/review-prompt.ts</files>
  <action>
In `src/execution/review-prompt.ts`:

1. Import `PriorFinding` from `../knowledge/types.ts`.

2. Add and export `buildIncrementalReviewSection(params)`:
```typescript
export function buildIncrementalReviewSection(params: {
  lastReviewedHeadSha: string;
  changedFilesSinceLastReview: string[];
  unresolvedPriorFindings: PriorFinding[];
}): string
```
Implementation (following research pattern):
- Header: "## Incremental Review Mode"
- Body: "This is an incremental re-review. The last review covered commit {sha7}. Focus ONLY on changes in these {N} files:"
- List changed files (cap at 50)
- If unresolved prior findings exist, add subsection "### Unresolved Prior Findings (Context Only)" with note: "These findings from the prior review are on unchanged code and remain relevant. Do NOT re-comment on them. They are shown for context only."
- List up to 10 unresolved findings as "- [{severity}] {title} ({filePath})"

3. Add and export `buildRetrievalContextSection(params)`:
```typescript
export function buildRetrievalContextSection(params: {
  findings: Array<{
    findingText: string;
    severity: string;
    category: string;
    filePath: string;
    outcome: string;
    distance: number;
    sourceRepo: string;
  }>;
  maxChars?: number;
}): string
```
Implementation (following research pattern):
- Return "" if findings empty
- Header: "## Similar Prior Findings (Learning Context)"
- Preamble: "The following are similar findings from prior reviews. Use them as context to inform your analysis, but evaluate each issue independently on current code. Do NOT copy prior findings -- only reference them if the same pattern exists in current changes."
- List findings as "- [{severity}/{category}] {findingText} (file: {filePath}, outcome: {outcome})"
- Enforce `maxChars` budget (default 2000): stop adding entries when budget exceeded

4. Extend `buildReviewPrompt` context parameter to accept two new optional fields:
```typescript
incrementalContext?: {
  lastReviewedHeadSha: string;
  changedFilesSinceLastReview: string[];
  unresolvedPriorFindings: PriorFinding[];
} | null;
retrievalContext?: {
  findings: Array<{
    findingText: string;
    severity: string;
    category: string;
    filePath: string;
    outcome: string;
    distance: number;
    sourceRepo: string;
  }>;
} | null;
```

5. In `buildReviewPrompt`, after the diff analysis section and before "Reading the code", inject:
- If `incrementalContext` is not null: `buildIncrementalReviewSection(incrementalContext)`
- If `retrievalContext` is not null and has findings: `buildRetrievalContextSection(retrievalContext)`
  </action>
  <verify>Run `bun test src/execution/` -- existing review-prompt tests still pass. The new functions are pure string builders with no side effects.</verify>
  <done>buildReviewPrompt accepts optional incrementalContext and retrievalContext parameters. When provided, incremental and retrieval sections are injected into the prompt. When null/omitted, prompt is unchanged (backward compatible).</done>
</task>

<task type="auto">
  <name>Task 2: Wire synchronize event, incremental diff, dedup, and retrieval into review handler</name>
  <files>src/handlers/review.ts, src/index.ts</files>
  <action>
This is the core integration task. Modify `src/handlers/review.ts` carefully:

**A. Imports and type union update:**

1. Add `PullRequestSynchronizeEvent` to the `@octokit/webhooks-types` import.
2. Import `computeIncrementalDiff` from `../lib/incremental-diff.ts`.
3. Import `buildPriorFindingContext, shouldSuppressFinding` from `../lib/finding-dedup.ts`.
4. Import `IsolationLayer` type from `../learning/isolation.ts`.
5. Import `PriorFinding` from `../knowledge/types.ts`.

**B. Update createReviewHandler deps:**

Add `isolationLayer?: IsolationLayer` to the deps parameter type (alongside existing learningMemoryStore and embeddingProvider). Destructure it.

**C. Update handleReview payload union:**

Add `PullRequestSynchronizeEvent` to the type assertion union.

**D. Update isReviewTriggerEnabled:**

Add: `if (action === "synchronize") return triggers.onSynchronize ?? false;`

Note: The triggers type needs to accept the new field. Since config.ts (Plan 01) adds `onSynchronize`, access it as `triggers.onSynchronize`. The function parameter type should accept `onSynchronize?: boolean`.

**E. Add incremental diff computation AFTER workspace setup and config loading, BEFORE the diff collection step (around line 997):**

```typescript
// Incremental diff computation (REV-01)
// Determine if this is an incremental re-review based on prior completed reviews.
// Works for both synchronize and review_requested events (state-driven, not event-driven).
let incrementalResult: IncrementalDiffResult | null = null;
if (knowledgeStore) {
  try {
    incrementalResult = await computeIncrementalDiff({
      workspaceDir: workspace.dir,
      repo: `${apiOwner}/${apiRepo}`,
      prNumber: pr.number,
      getLastReviewedHeadSha: (p) => knowledgeStore.getLastReviewedHeadSha(p),
      logger,
    });
    logger.info(
      { ...baseLog, gate: "incremental-diff", mode: incrementalResult.mode, reason: incrementalResult.reason },
      "Incremental diff computation complete",
    );
  } catch (err) {
    logger.warn({ ...baseLog, err }, "Incremental diff computation failed (fail-open, full review)");
  }
}
```

**F. Filter changedFiles for incremental mode:**

After the existing `changedFiles` filter (skipPaths), add:

```typescript
// In incremental mode, further filter to only files that changed since last review
let reviewFiles = changedFiles;
if (incrementalResult?.mode === "incremental" && incrementalResult.changedFilesSinceLastReview.length > 0) {
  const incrementalSet = new Set(incrementalResult.changedFilesSinceLastReview);
  reviewFiles = changedFiles.filter(f => incrementalSet.has(f));
  logger.info(
    { ...baseLog, gate: "incremental-filter", fullCount: changedFiles.length, incrementalCount: reviewFiles.length },
    "Filtered to incremental changed files",
  );
}
```

Then replace all downstream references to `changedFiles` in the review prompt building with `reviewFiles` (but keep `changedFiles` / `allChangedFiles` for diff analysis and Review Details metrics -- those should still reflect the full PR).

**G. Query prior findings and build dedup context:**

After incremental diff result is available, before prompt building:

```typescript
// Prior finding dedup context (REV-02)
let priorFindingCtx: PriorFindingContext | null = null;
if (knowledgeStore && incrementalResult?.mode === "incremental") {
  try {
    const priorFindings = knowledgeStore.getPriorReviewFindings({
      repo: `${apiOwner}/${apiRepo}`,
      prNumber: pr.number,
    });
    if (priorFindings.length > 0) {
      priorFindingCtx = buildPriorFindingContext({
        priorFindings,
        changedFilesSinceLastReview: incrementalResult.changedFilesSinceLastReview,
      });
    }
  } catch (err) {
    logger.warn({ ...baseLog, err }, "Prior finding context failed (fail-open, no dedup)");
  }
}
```

**H. Build retrieval context (LEARN-07):**

Before prompt building, after prior finding context:

```typescript
// Retrieval context (LEARN-07)
let retrievalCtx: RetrievalContextForPrompt | null = null;
if (isolationLayer && embeddingProvider && config.knowledge.retrieval.enabled) {
  try {
    const queryText = `${pr.title}\n${reviewFiles.slice(0, 20).join("\n")}`;
    const embedResult = await embeddingProvider.generate(queryText, "query");
    if (embedResult) {
      const retrieval = isolationLayer.retrieveWithIsolation({
        queryEmbedding: embedResult.embedding,
        repo: `${apiOwner}/${apiRepo}`,
        owner: apiOwner,
        sharingEnabled: config.knowledge.sharing.enabled,
        topK: config.knowledge.retrieval.topK,
        distanceThreshold: config.knowledge.retrieval.distanceThreshold,
        logger,
      });
      if (retrieval.results.length > 0) {
        retrievalCtx = {
          findings: retrieval.results.map(r => ({
            findingText: r.record.findingText,
            severity: r.record.severity,
            category: r.record.category,
            filePath: r.record.filePath,
            outcome: r.record.outcome,
            distance: r.distance,
            sourceRepo: r.sourceRepo,
          })),
        };
      }
    }
  } catch (err) {
    logger.warn({ ...baseLog, err }, "Retrieval context generation failed (fail-open, proceeding without retrieval)");
  }
}
```

Define `RetrievalContextForPrompt` as a local type in review.ts:
```typescript
type RetrievalContextForPrompt = {
  findings: Array<{
    findingText: string;
    severity: string;
    category: string;
    filePath: string;
    outcome: string;
    distance: number;
    sourceRepo: string;
  }>;
};
```

**I. Pass incremental and retrieval context to buildReviewPrompt:**

Update the `buildReviewPrompt` call to include:
```typescript
incrementalContext: incrementalResult?.mode === "incremental" ? {
  lastReviewedHeadSha: incrementalResult.lastReviewedHeadSha!,
  changedFilesSinceLastReview: incrementalResult.changedFilesSinceLastReview,
  unresolvedPriorFindings: priorFindingCtx?.unresolvedOnUnchangedCode ?? [],
} : null,
retrievalContext: retrievalCtx,
```

Also update `changedFiles` in the prompt call to use `reviewFiles`.

**J. Apply finding dedup suppression AFTER finding extraction:**

In the `processedFindings` mapping section (around line 1143), add dedup-based suppression. After the existing `matchesSuppression` check, add:

```typescript
// Incremental dedup suppression (REV-02)
const dedupSuppressed = priorFindingCtx
  ? shouldSuppressFinding({
      filePath: finding.filePath,
      titleFingerprint: fingerprintFindingTitle(finding.title),
      suppressionFingerprints: priorFindingCtx.suppressionFingerprints,
    })
  : false;
const suppressed = Boolean(matchedSuppression) || dedupSuppressed;
```

Replace the existing `const suppressed = Boolean(matchedSuppression);` with this combined check.

**K. Register synchronize event:**

At the bottom of `createReviewHandler`, add:
```typescript
eventRouter.register("pull_request.synchronize", handleReview);
```

**L. Update src/index.ts:**

Import `createIsolationLayer` from `./learning/isolation.ts`. After learning memory store initialization, create isolation layer:

```typescript
let isolationLayer: IsolationLayer | undefined;
if (learningMemoryStore) {
  isolationLayer = createIsolationLayer({ memoryStore: learningMemoryStore, logger });
}
```

Pass `isolationLayer` to `createReviewHandler` deps.

**CRITICAL: Fail-open verification:**
Every new code path (incremental diff, prior findings, retrieval) is wrapped in try/catch that logs a warning and continues. The review ALWAYS publishes regardless of any failure in these new paths.
  </action>
  <verify>
Run `bun test` -- all tests pass.
Run `bun build src/index.ts --target=bun` -- compiles without errors.
Verify the synchronize event is registered by searching for "pull_request.synchronize" in review.ts.
  </verify>
  <done>
Review handler:
1. Registers for `pull_request.synchronize` events (gated by `onSynchronize` config)
2. Computes incremental diff for both synchronize and review_requested events
3. Filters review scope to only changed files in incremental mode
4. Queries prior findings and builds dedup context for suppression
5. Generates retrieval context via isolation layer + embedding provider
6. Passes incremental + retrieval context to the review prompt
7. Suppresses duplicate findings on unchanged code via fingerprint matching
8. All new paths are fail-open: errors degrade to full review, not blocked publication
  </done>
</task>

</tasks>

<verification>
- `bun test` passes (full suite)
- `bun build src/index.ts --target=bun` compiles without type errors
- `pull_request.synchronize` is registered as an event handler
- Config `onSynchronize: true` enables synchronize event processing
- Fail-open: every new try/catch path logs warning and proceeds
- Incremental mode only triggers when a prior completed review exists in run_state
- Retrieval context is bounded by topK and distanceThreshold from config
</verification>

<success_criteria>
- REV-01: Synchronize events compute incremental diff and only review changed files since last review
- REV-02: Prior findings on unchanged code generate suppression fingerprints; matching new findings are suppressed; unresolved findings appear as prompt context
- LEARN-07: Retrieval context from learning memory is injected into the review prompt with bounded top-K and score thresholds
- REL-02: Every failure (diff computation, prior finding query, retrieval, embedding) degrades gracefully without blocking review publication
</success_criteria>

<output>
After completion, create `.planning/phases/31-incremental-re-review-with-retrieval-context/31-03-SUMMARY.md`
</output>
