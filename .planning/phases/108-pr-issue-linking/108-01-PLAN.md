---
phase: 108-pr-issue-linking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/issue-reference-parser.ts
  - src/lib/issue-reference-parser.test.ts
  - src/knowledge/issue-linker.ts
  - src/knowledge/issue-linker.test.ts
autonomous: true
requirements:
  - PRLINK-01
  - PRLINK-02

must_haves:
  truths:
    - "PR body and commit messages are parsed for explicit issue references using fixes, closes, resolves, and relates-to keywords (case-insensitive)"
    - "Cross-repo references within the same org (org/repo#N) are recognized alongside same-repo (#N) patterns"
    - "References inside markdown code blocks (triple-backtick sections) are excluded to prevent false positives"
    - "When explicit references are found, semantic search is skipped entirely (trust the author's references)"
    - "When no explicit references exist, semantic search queries IssueStore with PR title + body + diff summary as the query"
    - "Semantic matches are filtered by 0.80 similarity threshold (0.20 max cosine distance) and capped at 3 results"
    - "If embedding generation or vector search fails, the linker returns empty semantic matches (fail-open)"
    - "Issues that don't exist in the corpus (getByNumber returns null) are silently skipped with a log warning"
  artifacts:
    - path: "src/lib/issue-reference-parser.ts"
      provides: "parseIssueReferences pure function and IssueReference type"
      exports: ["parseIssueReferences", "IssueReference"]
    - path: "src/knowledge/issue-linker.ts"
      provides: "linkPRToIssues orchestrator, LinkedIssue type, and LinkResult type"
      exports: ["linkPRToIssues", "LinkedIssue", "LinkResult"]
  key_links:
    - from: "src/knowledge/issue-linker.ts"
      to: "src/knowledge/issue-store.ts"
      via: "IssueStore.getByNumber() and searchByEmbedding()"
      pattern: "issueStore"
    - from: "src/knowledge/issue-linker.ts"
      to: "src/knowledge/embeddings.ts"
      via: "EmbeddingProvider.generate()"
      pattern: "embeddingProvider.generate"
    - from: "src/knowledge/issue-linker.ts"
      to: "src/lib/issue-reference-parser.ts"
      via: "parseIssueReferences()"
      pattern: "parseIssueReferences"
---

<objective>
Create the two core modules for PR-issue linking: a pure regex-based reference parser and an orchestrator that resolves parsed references to issue records with semantic search fallback.

Purpose: Provide fully tested, isolated building blocks that Plan 02 will wire into the review handler. By keeping the parser pure (zero I/O) and the linker as a thin orchestrator, both are independently testable.

Output: Tested issue-reference-parser module, tested issue-linker module.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/108-pr-issue-linking/108-RESEARCH.md
@.planning/phases/108-pr-issue-linking/108-CONTEXT.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/knowledge/issue-types.ts:
```typescript
export type IssueRecord = {
  id: number; createdAt: string; repo: string; owner: string;
  issueNumber: number; title: string; body: string | null; state: string;
  authorLogin: string; authorAssociation: string | null;
  labelNames: string[]; templateSlug: string | null; commentCount: number;
  assignees: Array<{ id: number; login: string }>; milestone: string | null;
  reactionCount: number; isPullRequest: boolean; locked: boolean;
  embedding: unknown; embeddingModel: string | null;
  githubCreatedAt: string; githubUpdatedAt: string | null; closedAt: string | null;
};

export type IssueSearchResult = {
  record: IssueRecord;
  distance: number;
};

export type IssueStore = {
  getByNumber(repo: string, issueNumber: number): Promise<IssueRecord | null>;
  searchByEmbedding(params: {
    queryEmbedding: Float32Array; repo: string; topK: number;
  }): Promise<IssueSearchResult[]>;
  // ... other methods
};
```

From src/knowledge/types.ts:
```typescript
export type EmbeddingProvider = {
  generate(text: string, inputType: "document" | "query"): Promise<EmbeddingResult>;
  readonly model: string;
  readonly dimensions: number;
};
```

From src/lib/pr-intent-parser.ts (pattern reference for pure parser):
```typescript
// Pure extraction function, fully unit-testable, no I/O
export function parsePRIntent(title: string, body: string | null, commits: ...): ParsedPRIntent;
```

From src/handlers/review.ts:
```typescript
async function fetchCommitMessages(
  octokit: ..., owner: string, repo: string, prNumber: number, commitCount: number
): Promise<Array<{ sha: string; message: string }>>;
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement issue reference parser with tests</name>
  <files>src/lib/issue-reference-parser.ts, src/lib/issue-reference-parser.test.ts</files>
  <action>
**Parser module** (`src/lib/issue-reference-parser.ts`):

Follow the pure-parser pattern established by `src/lib/pr-intent-parser.ts` -- zero I/O, pure regex extraction, fully unit-testable.

Export a type and a function:

```typescript
export type IssueReference = {
  issueNumber: number;
  keyword: string; // normalized lowercase: "fixes", "closes", "resolves", "relates-to"
  isClosing: boolean; // true for fixes/closes/resolves, false for relates-to
  crossRepo: string | null; // "org/repo" for cross-repo refs, null for same-repo
  source: "body" | "commit";
};

export function parseIssueReferences(params: {
  prBody: string;
  commitMessages: string[];
}): IssueReference[];
```

**Implementation details:**

1. **Strip code blocks first:** Before regex matching, strip all triple-backtick code blocks from the input text. Use a regex like `/```[\s\S]*?```/g` to remove them. This prevents false positives from code examples containing `#N` patterns (Pitfall 3 from RESEARCH.md).

2. **Regex pattern:** Match GitHub standard closing keywords plus `relates-to`:
   ```
   /(?:^|\s|[([])(?:fix(?:e[sd])?|close[sd]?|resolve[sd]?|relates?[- ]to)\s+(?:([a-z0-9_.-]+\/[a-z0-9_.-]+)#(\d+)|#(\d+))/gi
   ```
   This handles: `fixes #42`, `Closes org/repo#123`, `relates-to #7`, `Fix #1`, `resolved #99`, etc.

3. **Normalize keywords:** Map all variants to canonical forms:
   - `fix`, `fixes`, `fixed` -> `"fixes"`
   - `close`, `closes`, `closed` -> `"closes"`
   - `resolve`, `resolves`, `resolved` -> `"resolves"`
   - `relate to`, `relates to`, `relates-to`, `relate-to` -> `"relates-to"`

4. **Determine isClosing:** `true` for fixes/closes/resolves variants, `false` for relates-to variants.

5. **Deduplicate:** Track seen references by `${crossRepo ?? ""}#${issueNumber}` key. First occurrence wins.

6. **Process PR body first** (with `source: "body"`), then each commit message (with `source: "commit"`). Dedup across both sources.

7. **Edge cases:**
   - Issue number 0 is invalid -- skip
   - Empty PR body or empty commit messages -- handle gracefully (return [])

**Tests** (`src/lib/issue-reference-parser.test.ts`):

Use `describe`/`test` with these test cases:

1. **Basic closing keywords**: `"fixes #42"` -> reference with issueNumber=42, keyword="fixes", isClosing=true
2. **Case insensitivity**: `"CLOSES #7"`, `"Resolves #99"` -> correct references
3. **Relates-to**: `"relates-to #15"` -> isClosing=false, keyword="relates-to"
4. **Cross-repo**: `"fixes org/repo#123"` -> crossRepo="org/repo", issueNumber=123
5. **Multiple references**: `"fixes #1, closes #2, relates-to #3"` -> 3 references
6. **Deduplication**: `"fixes #42 and also fixes #42"` -> 1 reference
7. **Code block exclusion**: body containing `` ```\nfixes #99\n``` `` -> no references from code block
8. **Commit messages**: commitMessages with `"fixes #10"` -> source="commit"
9. **Cross-source dedup**: same #N in body and commits -> only first (body) is kept
10. **Empty inputs**: empty body + empty commits -> []
11. **Keyword variants**: `"fix #1"`, `"fixed #2"`, `"closed #3"`, `"resolved #4"` -> correct canonical keywords
12. **Reference at start of line**: `"Fixes #42 is the main change"` -> matches
13. **Reference after parenthesis**: `"(fixes #42)"` -> matches
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && bun test src/lib/issue-reference-parser.test.ts --timeout 30000</automated>
  </verify>
  <done>parseIssueReferences correctly extracts issue references from PR body and commit messages. Handles all GitHub closing keywords plus relates-to. Cross-repo references recognized. Code blocks stripped before matching. Deduplication across body and commits. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Implement issue linker orchestrator with tests</name>
  <files>src/knowledge/issue-linker.ts, src/knowledge/issue-linker.test.ts</files>
  <action>
**Linker module** (`src/knowledge/issue-linker.ts`):

This orchestrates: parse references -> fetch issues from corpus -> (if no refs) semantic search fallback.

Export types and function:

```typescript
export type LinkedIssue = {
  issueNumber: number;
  repo: string;
  title: string;
  state: string;
  descriptionSummary: string;
  linkType: "referenced" | "semantic";
  keyword?: string; // only for referenced type
  similarity?: number; // only for semantic type (0-1 scale)
};

export type LinkResult = {
  referencedIssues: LinkedIssue[];
  semanticMatches: LinkedIssue[];
};

export async function linkPRToIssues(params: {
  prBody: string;
  prTitle: string;
  commitMessages: string[];
  diffSummary: string;
  repo: string; // "owner/repo" format
  issueStore: IssueStore;
  embeddingProvider: EmbeddingProvider;
  logger: Logger;
  semanticThreshold?: number; // default 0.80
  maxSemanticResults?: number; // default 3
}): Promise<LinkResult>;
```

**Implementation flow:**

1. **Parse references:** Call `parseIssueReferences({ prBody, commitMessages })`. Import from `../lib/issue-reference-parser.ts`.

2. **Fetch referenced issues:** For each parsed reference:
   - If `crossRepo` is not null, skip it with a debug log ("cross-repo references not in local corpus, skipping"). The IssueStore is scoped to the local repo's corpus.
   - Call `issueStore.getByNumber(repo, ref.issueNumber)`.
   - If result is null, log warning ("referenced issue #N not found in corpus") and skip.
   - Build `LinkedIssue` with `linkType: "referenced"`, `keyword: ref.keyword`.
   - `descriptionSummary`: Truncate issue body to first 500 chars. If body is null, use empty string. Strip markdown to plain text for brevity (simple strip: remove `#` headers, `**` bold, links `[text](url)` -> `text`).

3. **Check semantic search gate:** If `referencedIssues.length > 0`, return early with empty `semanticMatches` (CONTEXT.md locked decision: skip semantic when explicit refs found).

4. **Semantic search fallback (only when no explicit refs):**
   - Build search query: concatenate `prTitle + "\n" + prBody.slice(0, 500) + "\n" + diffSummary`. Trim to avoid empty queries. If query is empty after trim, return empty result.
   - Call `embeddingProvider.generate(query, "query")`. If result is null or embedding is null, log warning and return empty result (fail-open).
   - Call `issueStore.searchByEmbedding({ queryEmbedding: embedding, repo, topK: maxSemanticResults * 2 })`. Fetch extra to allow threshold filtering.
   - Convert cosine distance to similarity: `similarity = 1 - distance`.
   - Filter by threshold: keep only results where `similarity >= semanticThreshold` (default 0.80).
   - Slice to `maxSemanticResults` (default 3).
   - Build `LinkedIssue` for each with `linkType: "semantic"`, `similarity` value.
   - `descriptionSummary`: Same truncation logic as referenced issues.

5. **Error handling:** Wrap entire function in try/catch. On any unhandled error, log error and return empty `LinkResult` (fail-open per project philosophy).

**Helper function** (private, same file):

```typescript
function truncateDescription(body: string | null, maxChars: number = 500): string
```
- If body is null, return "".
- Strip simple markdown: remove `#` at start of lines, `**` bold markers, `[text](url)` -> `text`, `\r\n` -> `\n`.
- Truncate to maxChars. If truncated, append "...".

**Tests** (`src/knowledge/issue-linker.test.ts`):

Use `describe`/`test` with mock dependencies:
- Mock `issueStore` with `getByNumber` and `searchByEmbedding` methods
- Mock `embeddingProvider` with `generate` method
- Mock `logger` (no-op or spy)

Test cases:

1. **Explicit refs found**: PR body has `"fixes #42"`, issueStore.getByNumber returns record -> referencedIssues has 1 entry, semanticMatches is empty
2. **Explicit refs skip semantic**: Body has refs -> embeddingProvider.generate is never called
3. **Issue not in corpus**: getByNumber returns null -> issue skipped, warning logged
4. **Cross-repo refs skipped**: `"fixes org/other#5"` -> skipped with debug log
5. **Semantic fallback**: No explicit refs, embeddingProvider returns embedding, searchByEmbedding returns results below threshold -> filtered out
6. **Semantic threshold filtering**: Results with distance 0.15 (sim 0.85) pass, distance 0.25 (sim 0.75) filtered
7. **Semantic max results**: 5 results returned from search, maxSemanticResults=3 -> only 3 returned
8. **Embedding failure (fail-open)**: embeddingProvider.generate returns null -> empty semanticMatches
9. **Search failure (fail-open)**: searchByEmbedding throws -> empty semanticMatches
10. **Description truncation**: Long body truncated to 500 chars with "..."
11. **Empty PR body + commits**: returns empty LinkResult
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && bun test src/knowledge/issue-linker.test.ts --timeout 30000</automated>
  </verify>
  <done>linkPRToIssues orchestrates reference parsing, issue corpus lookup, and semantic search fallback. Explicit refs skip semantic search. Cross-repo refs gracefully skipped. Fail-open on embedding/search failures. Description summaries truncated to 500 chars. All tests pass.</done>
</task>

</tasks>

<verification>
1. `parseIssueReferences` extracts all GitHub closing keywords + relates-to from PR body and commit messages
2. Code blocks in PR body are stripped before matching (no false positives)
3. Cross-repo references (org/repo#N) are parsed correctly by the parser
4. `linkPRToIssues` fetches referenced issues from IssueStore by number
5. Semantic search is skipped when explicit refs exist (CONTEXT.md locked decision)
6. Semantic search threshold filters at 0.80 similarity (0.20 max distance)
7. Semantic search capped at 3 results (CONTEXT.md locked decision)
8. Both modules fail-open on any error (embedding, search, getByNumber failures)
9. All unit tests pass: `bun test src/lib/issue-reference-parser.test.ts src/knowledge/issue-linker.test.ts --timeout 30000`
</verification>

<success_criteria>
- [ ] `parseIssueReferences` handles fixes, closes, resolves, relates-to (PRLINK-01)
- [ ] Cross-repo org/repo#N patterns parsed correctly (PRLINK-01)
- [ ] Code blocks excluded from parsing (Pitfall 3 prevention)
- [ ] `linkPRToIssues` fetches issues from corpus and falls back to semantic search (PRLINK-02)
- [ ] Semantic search skipped when explicit refs found (locked decision)
- [ ] 0.80 similarity threshold and 3 max results enforced (locked decisions)
- [ ] Fail-open on all error paths
- [ ] All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/108-pr-issue-linking/108-01-SUMMARY.md`
</output>
