---
phase: 108-pr-issue-linking
plan: 02
type: execute
wave: 2
depends_on:
  - "108-01"
files_modified:
  - src/execution/review-prompt.ts
  - src/handlers/review.ts
  - src/index.ts
autonomous: true
requirements:
  - PRLINK-03

must_haves:
  truths:
    - "buildReviewPrompt accepts a new optional linkedIssues parameter with referenced and semantic match arrays"
    - "When linkedIssues has referenced issues, a 'Referenced Issues' section is included in the review prompt framed as 'this PR addresses these issues'"
    - "When linkedIssues has semantic matches, a 'Possibly Related Issues' section is included framed as secondary context"
    - "Each issue is displayed as: #N (state) -- 'title' with description summary"
    - "Semantic matches include similarity percentage"
    - "The prompt instructs the reviewer to assess coverage: whether linked issues appear addressed, partially addressed, or unrelated"
    - "If no linked issues exist (both arrays empty), no section is added to the prompt (zero noise)"
    - "The review handler calls linkPRToIssues before buildReviewPrompt and passes the result"
    - "IssueStore and EmbeddingProvider are wired into the review handler via dependency injection from index.ts"
    - "Issue linking failure does not block the review (fail-open)"
  artifacts:
    - path: "src/execution/review-prompt.ts"
      provides: "buildLinkedIssuesSection function and linkedIssues parameter on buildReviewPrompt"
      exports: ["buildLinkedIssuesSection"]
    - path: "src/handlers/review.ts"
      provides: "Issue linking call in review pipeline with fail-open error handling"
      contains: "linkPRToIssues"
    - path: "src/index.ts"
      provides: "issueStore and embeddingProvider passed to createReviewHandler"
      contains: "issueStore"
  key_links:
    - from: "src/handlers/review.ts"
      to: "src/knowledge/issue-linker.ts"
      via: "linkPRToIssues()"
      pattern: "linkPRToIssues"
    - from: "src/execution/review-prompt.ts"
      to: "src/knowledge/issue-linker.ts"
      via: "LinkResult type for linkedIssues parameter"
      pattern: "LinkedIssue"
    - from: "src/index.ts"
      to: "src/handlers/review.ts"
      via: "issueStore dep injection to createReviewHandler"
      pattern: "issueStore"
---

<objective>
Wire PR-issue linking into the review pipeline: extend buildReviewPrompt with a linked issues section, call linkPRToIssues in review.ts, and inject issueStore into the review handler's dependencies.

Purpose: This connects the building blocks from Plan 01 into the live review flow so that every PR review prompt is enriched with linked issue context when available.

Output: Extended review prompt builder, wired review handler, updated index.ts dependency injection.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/108-pr-issue-linking/108-RESEARCH.md
@.planning/phases/108-pr-issue-linking/108-CONTEXT.md
@.planning/phases/108-pr-issue-linking/108-01-SUMMARY.md

<interfaces>
<!-- Contracts from Plan 01 that this plan consumes -->

From src/knowledge/issue-linker.ts (created in Plan 01):
```typescript
export type LinkedIssue = {
  issueNumber: number;
  repo: string;
  title: string;
  state: string;
  descriptionSummary: string;
  linkType: "referenced" | "semantic";
  keyword?: string;
  similarity?: number;
};

export type LinkResult = {
  referencedIssues: LinkedIssue[];
  semanticMatches: LinkedIssue[];
};

export async function linkPRToIssues(params: {
  prBody: string;
  prTitle: string;
  commitMessages: string[];
  diffSummary: string;
  repo: string;
  issueStore: IssueStore;
  embeddingProvider: EmbeddingProvider;
  logger: Logger;
  semanticThreshold?: number;
  maxSemanticResults?: number;
}): Promise<LinkResult>;
```

From src/execution/review-prompt.ts (current buildReviewPrompt signature, partial):
```typescript
export function buildReviewPrompt(context: {
  owner: string;
  repo: string;
  prNumber: number;
  prTitle: string;
  prBody: string;
  // ... many existing optional fields ...
  unifiedResults?: UnifiedRetrievalChunk[];
  clusterPatterns?: ClusterPatternMatch[];
}): string;
```

From src/handlers/review.ts (current createReviewHandler deps):
```typescript
export function createReviewHandler(deps: {
  eventRouter: EventRouter;
  jobQueue: JobQueue;
  workspaceManager: WorkspaceManager;
  githubApp: GitHubApp;
  executor: ReturnType<typeof createExecutor>;
  telemetryStore: TelemetryStore;
  knowledgeStore?: KnowledgeStore;
  learningMemoryStore?: LearningMemoryStore;
  embeddingProvider?: EmbeddingProvider;
  retriever?: ReturnType<typeof createRetriever>;
  codeSnippetStore?: CodeSnippetStore;
  contributorProfileStore?: ContributorProfileStore;
  slackBotToken?: string;
  clusterMatcher?: (...) => Promise<ClusterPatternMatch[]>;
  logger: Logger;
}): void;
```

From src/handlers/review.ts (fetchCommitMessages is a private function at line ~279):
```typescript
async function fetchCommitMessages(
  octokit, owner, repo, prNumber, commitCount
): Promise<Array<{ sha: string; message: string }>>;
```

From src/index.ts:
```typescript
// issueStore is already created at line 204:
const issueStore = createIssueStore({ sql, logger });
// embeddingProvider is already available
// createReviewHandler is called at line 411
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add linked issues section to buildReviewPrompt</name>
  <files>src/execution/review-prompt.ts</files>
  <action>
**Add buildLinkedIssuesSection function** to `src/execution/review-prompt.ts`:

Import the `LinkResult` and `LinkedIssue` types from `../knowledge/issue-linker.ts`.

Add a new exported function:

```typescript
export function buildLinkedIssuesSection(linkedIssues: LinkResult): string {
  const lines: string[] = [];

  if (linkedIssues.referencedIssues.length > 0) {
    lines.push("## Referenced Issues");
    lines.push("This PR addresses these issues:");
    lines.push("");
    for (const issue of linkedIssues.referencedIssues) {
      lines.push(`- #${issue.issueNumber} (${issue.state}) -- "${issue.title}"`);
      if (issue.descriptionSummary) {
        lines.push(`  Summary: ${issue.descriptionSummary}`);
      }
    }
  }

  if (linkedIssues.semanticMatches.length > 0) {
    if (lines.length > 0) lines.push("");
    lines.push("## Possibly Related Issues");
    lines.push("");
    for (const issue of linkedIssues.semanticMatches) {
      const pct = issue.similarity != null ? `${Math.round(issue.similarity * 100)}% match` : "semantic match";
      lines.push(`- #${issue.issueNumber} (${issue.state}) -- "${issue.title}" (${pct})`);
      if (issue.descriptionSummary) {
        lines.push(`  Summary: ${issue.descriptionSummary}`);
      }
    }
  }

  if (lines.length > 0) {
    lines.push("");
    lines.push("Assess whether the PR changes adequately address the referenced issues. Note any issues that appear only partially addressed or unrelated to the actual changes.");
  }

  return lines.join("\n");
}
```

**Extend buildReviewPrompt context parameter:**

Add a new optional field to the `context` parameter of `buildReviewPrompt`:

```typescript
linkedIssues?: LinkResult;
```

Add it alongside the other optional context fields (near `clusterPatterns`, `unifiedResults`, etc.).

**Render the section in buildReviewPrompt:**

Inside the `buildReviewPrompt` function body, add the linked issues section AFTER the existing retrieval context sections (after `unifiedResults` rendering, before the final output format instructions). The placement should be near the other context-enrichment sections:

```typescript
// Linked issue context (PRLINK-03)
if (context.linkedIssues) {
  const linkedSection = buildLinkedIssuesSection(context.linkedIssues);
  if (linkedSection) {
    lines.push("");
    lines.push(linkedSection);
  }
}
```

Do NOT modify any existing sections. Just add this new block.
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && grep -q "buildLinkedIssuesSection" src/execution/review-prompt.ts && grep -q "linkedIssues" src/execution/review-prompt.ts && echo "review prompt extended"</automated>
  </verify>
  <done>buildReviewPrompt accepts optional linkedIssues parameter. buildLinkedIssuesSection renders referenced and semantic match sections with coverage assessment instruction. Empty linked issues produce no section (zero noise).</done>
</task>

<task type="auto">
  <name>Task 2: Wire issue linking into review handler and inject dependencies</name>
  <files>src/handlers/review.ts, src/index.ts</files>
  <action>
**Extend review handler dependencies** (`src/handlers/review.ts`):

1. Add import at the top of the file:
   ```typescript
   import { linkPRToIssues, type LinkResult } from "../knowledge/issue-linker.ts";
   ```

2. Add `issueStore` to the `createReviewHandler` deps type:
   ```typescript
   export function createReviewHandler(deps: {
     // ... existing deps ...
     /** Optional issue store for PR-issue linking (Phase 108: PRLINK). */
     issueStore?: IssueStore;
     logger: Logger;
   }): void {
   ```

   Import `IssueStore` type from `../knowledge/issue-types.ts` (add to existing imports if not already present).

3. Destructure in the existing const block:
   ```typescript
   const {
     // ... existing destructuring ...
     issueStore,
     logger,
   } = deps;
   ```

**Add issue linking call in the review pipeline:**

Inside the review execution flow, AFTER the existing `fetchCommitMessages` + `parsePRIntent` block (around line 1785) and BEFORE the `buildReviewPrompt` call (around line 2729), add the issue linking block:

```typescript
// PR-issue linking (PRLINK-01, PRLINK-02, PRLINK-03)
let linkedIssueResult: LinkResult | undefined;
if (issueStore && embeddingProvider) {
  try {
    // Fetch commit messages for reference parsing
    // (re-use if already fetched above, or fetch here)
    let commitMsgsForLinking: string[] = [];
    try {
      const commits = await fetchCommitMessages(
        idempotencyOctokit,
        apiOwner,
        apiRepo,
        pr.number,
        pr.commits,
      );
      commitMsgsForLinking = commits.map(c => c.message);
    } catch (err) {
      logger.warn({ ...baseLog, err }, "Failed to fetch commits for issue linking (fail-open)");
    }

    // Build diff summary from diffAnalysis if available
    const diffSummaryParts: string[] = [];
    if (diffAnalysis) {
      if (diffAnalysis.changedFiles) {
        diffSummaryParts.push(diffAnalysis.changedFiles.map((f: { path: string }) => f.path).join(", "));
      }
    }

    linkedIssueResult = await linkPRToIssues({
      prBody: pr.body ?? "",
      prTitle: pr.title,
      commitMessages: commitMsgsForLinking,
      diffSummary: diffSummaryParts.join("\n"),
      repo: `${apiOwner}/${apiRepo}`,
      issueStore,
      embeddingProvider,
      logger,
    });

    if (linkedIssueResult.referencedIssues.length > 0 || linkedIssueResult.semanticMatches.length > 0) {
      logger.info(
        {
          ...baseLog,
          referencedCount: linkedIssueResult.referencedIssues.length,
          semanticCount: linkedIssueResult.semanticMatches.length,
        },
        "PR-issue linking completed",
      );
    }
  } catch (err) {
    logger.warn({ ...baseLog, err }, "PR-issue linking failed (fail-open)");
  }
}
```

**IMPORTANT placement note:** The `commitMessages` fetched earlier at line ~1758 is scoped inside a try/catch block and may not be accessible. The linking code should fetch commits independently (or re-fetch) since the review handler's existing fetchCommitMessages result is scoped to the parsePRIntent try/catch. This is a small cost (one additional API call) but avoids refactoring the existing scoping.

**ALTERNATIVE (preferred if feasible):** If the executor determines that `commitMessages` from the earlier fetch CAN be hoisted to a wider scope (by moving the `const commitMessages` declaration outside the try block), prefer that approach. Declare `let commitMsgsForLinking: string[] = []` at the same level as `parsedIntent`, then populate it from the existing fetch. This avoids a redundant API call.

**Pass to buildReviewPrompt:**

Add `linkedIssues: linkedIssueResult,` to the `buildReviewPrompt({...})` call around line 2729. Place it alongside the other optional context fields:

```typescript
const reviewPrompt = buildReviewPrompt({
  // ... existing fields ...
  clusterPatterns: clusterPatternsForPrompt,
  // PR-issue linking (PRLINK-03)
  linkedIssues: linkedIssueResult,
});
```

Also add it to the retry prompt (`retryPrompt`) call around line 3753 if it exists -- pass the same `linkedIssueResult` there too.

**Update index.ts:**

Add `issueStore` to the `createReviewHandler` call in `src/index.ts`:

```typescript
createReviewHandler({
  eventRouter,
  jobQueue,
  workspaceManager,
  githubApp,
  executor,
  telemetryStore,
  knowledgeStore,
  learningMemoryStore,
  embeddingProvider,
  retriever,
  codeSnippetStore,
  contributorProfileStore,
  slackBotToken: config.slackBotToken,
  issueStore,  // <-- ADD THIS LINE (Phase 108: PRLINK)
  clusterMatcher: async (opts) => {
    // ... existing ...
  },
  logger,
});
```

The `issueStore` variable is already created at line 204 of `src/index.ts` and is in scope at the `createReviewHandler` call site.
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && grep -q "linkPRToIssues" src/handlers/review.ts && grep -q "issueStore" src/handlers/review.ts && grep -q "linkedIssues" src/handlers/review.ts && grep "createReviewHandler" src/index.ts | grep -q "issueStore" && echo "wiring complete"</automated>
  </verify>
  <done>Review handler calls linkPRToIssues before buildReviewPrompt. IssueStore injected via createReviewHandler deps from index.ts. Linked issue results passed to prompt builder. Fail-open on all error paths. Both standard and retry review paths include linked issues.</done>
</task>

</tasks>

<verification>
1. `buildReviewPrompt` accepts `linkedIssues?: LinkResult` parameter
2. `buildLinkedIssuesSection` renders "Referenced Issues" and "Possibly Related Issues" sections correctly
3. Empty linked issues produce no section in the prompt (zero noise)
4. Review handler calls `linkPRToIssues` before `buildReviewPrompt`
5. `issueStore` is an optional dep on `createReviewHandler` (backwards compatible)
6. `issueStore` is passed in `src/index.ts`
7. Issue linking failure does not block review execution (fail-open)
8. Existing review handler tests still pass: `bun test src/handlers/review.test.ts --timeout 60000`
</verification>

<success_criteria>
- [ ] `buildReviewPrompt` has `linkedIssues` parameter (PRLINK-03)
- [ ] Referenced issues shown as "This PR addresses these issues" with #N (state) -- "title" format
- [ ] Semantic matches shown as "Possibly Related Issues" with similarity percentage
- [ ] Coverage assessment instruction included in prompt
- [ ] Zero noise when no linked issues found
- [ ] `issueStore` wired into review handler from index.ts
- [ ] Fail-open: linking errors logged but never block review
- [ ] Existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/108-pr-issue-linking/108-02-SUMMARY.md`
</output>
