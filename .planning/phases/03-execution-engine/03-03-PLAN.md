---
phase: 03-execution-engine
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - src/execution/executor.ts
  - src/execution/prompt.ts
autonomous: true

must_haves:
  truths:
    - "The executor invokes Claude Code CLI via query() with prompt, MCP servers, cwd, model, and auth"
    - "The executor streams messages from query() and returns a structured ExecutionResult"
    - "The prompt builder constructs a context-rich prompt from the execution context"
    - "CLAUDE_CODE_OAUTH_TOKEN is passed via options.env, not process.env (Pitfall 3)"
    - "permissionMode is set to bypassPermissions for headless execution (Pitfall 7)"
    - "settingSources includes 'project' so repo CLAUDE.md is loaded (Pitfall 2)"
  artifacts:
    - path: "src/execution/executor.ts"
      provides: "createExecutor factory function with execute method"
      exports: ["createExecutor"]
    - path: "src/execution/prompt.ts"
      provides: "buildPrompt function constructing Claude's input"
      exports: ["buildPrompt"]
  key_links:
    - from: "src/execution/executor.ts"
      to: "@anthropic-ai/claude-agent-sdk"
      via: "query() invocation"
      pattern: "import.*query.*claude-agent-sdk"
    - from: "src/execution/executor.ts"
      to: "src/execution/config.ts"
      via: "loadRepoConfig for model/maxTurns"
      pattern: "loadRepoConfig"
    - from: "src/execution/executor.ts"
      to: "src/execution/mcp/index.ts"
      via: "buildMcpServers and buildAllowedMcpTools"
      pattern: "buildMcpServers|buildAllowedMcpTools"
    - from: "src/execution/executor.ts"
      to: "src/auth/github-app.ts"
      via: "getInstallationOctokit for MCP server auth"
      pattern: "getInstallationOctokit"
---

<objective>
Create the executor that ties together config, MCP servers, and Claude Code CLI invocation via the Agent SDK.

Purpose: This is the core of Phase 3 -- the `createExecutor()` factory produces an `execute()` method that loads repo config, assembles MCP servers, builds a prompt, and invokes `query()` to run Claude Code against the workspace. It returns a structured `ExecutionResult` that downstream handlers (Phase 4, 5) will use.

Output: `src/execution/executor.ts` and `src/execution/prompt.ts`
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-execution-engine/03-RESEARCH.md
@.planning/phases/03-execution-engine/03-01-SUMMARY.md
@.planning/phases/03-execution-engine/03-02-SUMMARY.md
@src/auth/github-app.ts
@src/execution/types.ts
@src/execution/config.ts
@src/execution/mcp/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create prompt builder</name>
  <files>src/execution/prompt.ts</files>
  <action>
Create `src/execution/prompt.ts` exporting `buildPrompt(context: ExecutionContext): string`.

The prompt builder constructs the text prompt passed to `query()`. This is a simple version for Phase 3 -- Phase 4 (PR review) and Phase 5 (mention handling) will extend the prompt with richer context (diff, conversation history, etc.).

**For Phase 3, the prompt includes:**
1. A header identifying the event: `"You are reviewing a GitHub repository. Event: {context.eventType}"`
2. Repository info: `"Repository: {context.owner}/{context.repo}"`
3. If prNumber is set: `"Pull Request: #{context.prNumber}"`
4. The trigger body: `"User message:\n\n{context.triggerBody}"`
5. Instructions: `"Analyze the code and provide feedback. Use the available MCP tools to post your findings as GitHub comments."`

Return the assembled string. Use template literals for readability.

Import `ExecutionContext` from `./types.ts`.

This function is intentionally simple -- it's the scaffold that Phase 4 and 5 will replace with feature-specific prompt construction. The key architectural decision is that prompt building is a separate concern from execution.
  </action>
  <verify>Run `bunx tsc --noEmit` -- no type errors.</verify>
  <done>buildPrompt returns a formatted string containing event type, repo info, PR number (if applicable), and trigger body.</done>
</task>

<task type="auto">
  <name>Task 2: Create executor with Agent SDK query() invocation</name>
  <files>src/execution/executor.ts</files>
  <action>
Create `src/execution/executor.ts` implementing the `createExecutor` factory.

**Factory signature:**
```typescript
import type { GitHubApp } from "../auth/github-app.ts";
import type { Logger } from "pino";

export function createExecutor(deps: {
  githubApp: GitHubApp;
  logger: Logger;
})
```

**Returns an object with:**
```typescript
{
  execute(context: ExecutionContext): Promise<ExecutionResult>
}
```

**execute() implementation:**

1. **Load repo config:**
   ```typescript
   const config = await loadRepoConfig(context.workspace.dir);
   logger.info({ model: config.model, maxTurns: config.maxTurns }, "Loaded repo config");
   ```

2. **Build MCP servers:**
   ```typescript
   const getOctokit = () => deps.githubApp.getInstallationOctokit(context.installationId);
   const mcpServers = buildMcpServers({
     getOctokit,
     owner: context.owner,
     repo: context.repo,
     prNumber: context.prNumber,
     commentId: context.commentId,
   });
   ```

3. **Build allowed tools list:**
   ```typescript
   const baseTools = [
     "Read", "Grep", "Glob",
     "Bash(git diff:*)", "Bash(git log:*)", "Bash(git show:*)", "Bash(git status:*)",
   ];
   const mcpTools = buildAllowedMcpTools(Object.keys(mcpServers));
   const allowedTools = [...baseTools, ...mcpTools];
   ```
   Note: Do NOT include Edit, Write, or WebSearch/WebFetch -- review-only for now. Phase 5 (mentions) will add write tools for code modification.

4. **Build prompt:**
   ```typescript
   const prompt = buildPrompt(context);
   ```

5. **Invoke query():**
   ```typescript
   import { query } from "@anthropic-ai/claude-agent-sdk";
   import type { SDKResultMessage } from "@anthropic-ai/claude-agent-sdk";

   const startTime = Date.now();

   const sdkQuery = query({
     prompt,
     options: {
       cwd: context.workspace.dir,
       model: config.model,
       maxTurns: config.maxTurns,
       systemPrompt: {
         type: "preset" as const,
         preset: "claude_code" as const,
         ...(config.systemPromptAppend && { append: config.systemPromptAppend }),
       },
       mcpServers,
       allowedTools,
       disallowedTools: ["WebSearch", "WebFetch"],
       settingSources: ["project"],
       permissionMode: "bypassPermissions",
       env: {
         ...process.env,
         CLAUDE_CODE_ENTRYPOINT: "kodiai-github-app",
       },
     },
   });
   ```

   **IMPORTANT per research:** `CLAUDE_CODE_OAUTH_TOKEN` should already be in `process.env` (set in the server's environment). The `env: { ...process.env }` spread passes it through. Do NOT hardcode or read it separately -- it's an environment secret managed at the deployment level.

6. **Stream messages:**
   ```typescript
   let resultMessage: SDKResultMessage | undefined;

   for await (const message of sdkQuery) {
     if (message.type === "system" && (message as any).subtype === "init") {
       logger.info({ sessionId: (message as any).session_id }, "Claude Code session started");
     }
     if (message.type === "result") {
       resultMessage = message as SDKResultMessage;
     }
     // Log assistant messages at debug level for observability
     if (message.type === "assistant") {
       logger.debug({ messageType: "assistant" }, "Claude Code assistant message");
     }
   }
   ```

7. **Build result:**
   ```typescript
   const durationMs = Date.now() - startTime;

   if (!resultMessage) {
     return {
       conclusion: "error" as const,
       durationMs,
       errorMessage: "No result message received from Claude Code CLI",
     };
   }

   return {
     conclusion: resultMessage.subtype === "success" ? "success" as const : "failure" as const,
     costUsd: resultMessage.total_cost_usd,
     numTurns: resultMessage.num_turns,
     durationMs: resultMessage.duration_ms ?? durationMs,
     sessionId: resultMessage.session_id,
   };
   ```

8. **Wrap everything in try/catch:**
   On error, log at error level and return `{ conclusion: "error", durationMs, errorMessage: err.message }`. Do NOT re-throw -- the executor should always return a result, never crash the server.

**Type casting notes:** The Agent SDK types may not be perfectly typed for all message fields. Use `as any` for accessing `subtype`, `session_id`, `total_cost_usd`, `num_turns`, `duration_ms` on messages if needed. The research confirms these fields exist on SDKResultMessage.
  </action>
  <verify>Run `bunx tsc --noEmit` -- no type errors. Verify the module exports createExecutor.</verify>
  <done>createExecutor factory produces an execute method that loads config, builds MCP servers, constructs prompt, invokes query(), streams messages, and returns structured ExecutionResult. All pitfalls from research are addressed: bypassPermissions, settingSources project, env passthrough, getOctokit per-call.</done>
</task>

</tasks>

<verification>
- `bunx tsc --noEmit` passes with no errors
- `src/execution/executor.ts` exports createExecutor
- `src/execution/prompt.ts` exports buildPrompt
- createExecutor accepts { githubApp, logger } dependencies (factory pattern)
- execute() returns ExecutionResult with conclusion, costUsd, numTurns, durationMs, sessionId
- query() call includes: permissionMode "bypassPermissions", settingSources ["project"], disallowedTools ["WebSearch", "WebFetch"]
- MCP servers use getOctokit function (not cached instance)
- allowedTools includes both base tools and mcp__*__* patterns
</verification>

<success_criteria>
- Claude Code CLI is invoked via Agent SDK query() with prompt, MCP server config, and workspace cwd (EXEC-04)
- MCP servers are passed to query() and their tools are included in allowedTools (EXEC-03)
- Config is loaded from workspace with defaults when .kodiai.yml is absent (OPS-03)
- Executor never throws -- always returns ExecutionResult with conclusion
- All research pitfalls addressed (permission mode, settings sources, env passthrough, token freshness)
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/03-execution-engine/03-03-SUMMARY.md`
</output>
