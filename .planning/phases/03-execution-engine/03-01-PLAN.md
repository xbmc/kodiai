---
phase: 03-execution-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/execution/types.ts
  - src/execution/config.ts
autonomous: true

must_haves:
  truths:
    - "loadRepoConfig returns validated config with sensible defaults when .kodiai.yml does not exist"
    - "loadRepoConfig reads and validates .kodiai.yml when it exists in the workspace"
    - "Invalid .kodiai.yml values are rejected with clear Zod validation errors"
    - "ExecutionContext and ExecutionResult types are defined for use by executor and MCP servers"
  artifacts:
    - path: "src/execution/types.ts"
      provides: "ExecutionContext, ExecutionResult, RepoConfig type exports"
      exports: ["ExecutionContext", "ExecutionResult", "RepoConfig"]
    - path: "src/execution/config.ts"
      provides: "loadRepoConfig factory function with Zod schema and YAML parsing"
      exports: ["loadRepoConfig"]
  key_links:
    - from: "src/execution/config.ts"
      to: "Bun.file"
      via: "File existence check and text reading"
      pattern: "Bun\\.file.*exists|Bun\\.file.*text"
    - from: "src/execution/config.ts"
      to: "zod"
      via: "Schema validation with defaults"
      pattern: "repoConfigSchema\\.parse"
---

<objective>
Define the execution type system and config loader for Phase 3.

Purpose: Establish the shared types (ExecutionContext, ExecutionResult, RepoConfig) used by the executor and MCP servers, and implement the config loader that reads `.kodiai.yml` from cloned repos with full defaults for zero-config operation.

Output: `src/execution/types.ts` and `src/execution/config.ts`
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-execution-engine/03-RESEARCH.md
@src/config.ts
@src/jobs/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create execution types</name>
  <files>src/execution/types.ts</files>
  <action>
Create `src/execution/types.ts` with the following type definitions:

**ExecutionContext** -- everything needed to invoke Claude against a workspace:
- `workspace`: `{ dir: string; cleanup: () => Promise<void> }` -- the ephemeral workspace
- `installationId`: `number`
- `owner`: `string`
- `repo`: `string`
- `prNumber`: `number | undefined` -- set for PR events, undefined for issue-only events
- `commentId`: `number | undefined` -- tracking comment ID for progress updates (set by handler, undefined initially)
- `eventType`: `string` -- the webhook event type (e.g., "pull_request.opened", "issue_comment.created")
- `triggerBody`: `string` -- the comment/PR body that triggered this execution

**ExecutionResult** -- the outcome of a Claude execution:
- `conclusion`: `"success" | "failure" | "error"`
- `costUsd`: `number | undefined`
- `numTurns`: `number | undefined`
- `durationMs`: `number | undefined`
- `sessionId`: `string | undefined`
- `errorMessage`: `string | undefined` -- populated when conclusion is "error"

**RepoConfig** -- re-export from config.ts (will be defined in Task 2). Use `export type { RepoConfig } from "./config.ts"`.

Follow the existing codebase pattern: use `export type` for interfaces (verbatimModuleSyntax is enabled in tsconfig).
  </action>
  <verify>Run `bunx tsc --noEmit` -- no type errors.</verify>
  <done>ExecutionContext and ExecutionResult types are exported from src/execution/types.ts and usable by other modules.</done>
</task>

<task type="auto">
  <name>Task 2: Create config loader with defaults and Zod validation</name>
  <files>src/execution/config.ts</files>
  <action>
Create `src/execution/config.ts` implementing `loadRepoConfig(workspaceDir: string): Promise<RepoConfig>`.

**Zod Schema (repoConfigSchema):**
- `model`: `z.string().default("claude-sonnet-4-5-20250929")` -- the Claude model to use
- `maxTurns`: `z.number().min(1).max(100).default(25)` -- max conversation turns
- `systemPromptAppend`: `z.string().optional()` -- additional system prompt text appended to the preset
- `review`: `z.object({ enabled: z.boolean().default(true), autoApprove: z.boolean().default(false) }).default({})` -- PR review settings
- `mention`: `z.object({ enabled: z.boolean().default(true) }).default({})` -- mention handling settings

Export the inferred type as `export type RepoConfig = z.infer<typeof repoConfigSchema>`.

**loadRepoConfig implementation:**
1. Build config path: `${workspaceDir}/.kodiai.yml`
2. Check existence: `const file = Bun.file(configPath); if (!(await file.exists())) return repoConfigSchema.parse({});`
3. If file exists, read text: `const raw = await file.text();`
4. Parse YAML using `js-yaml` (install via `bun install js-yaml && bun install -D @types/js-yaml`). Import as `import yaml from "js-yaml"`. Call `yaml.load(raw)`.
5. Validate with Zod: `return repoConfigSchema.parse(parsed);`
6. Wrap the YAML parse + Zod validate in try/catch. On YAML parse error, throw with message "Invalid .kodiai.yml: YAML parse error: {message}". On Zod validation error, throw with "Invalid .kodiai.yml: {formatted zod issues}".

**Factory function pattern:** This module exports a standalone async function (not a factory with deps), consistent with the existing `loadConfig()` in `src/config.ts`. No logger dependency needed -- callers handle errors.

**Important:** Use `import yaml from "js-yaml"` with the default import. The `js-yaml` package uses CommonJS exports which Bun handles correctly with default import.
  </action>
  <verify>Run `bunx tsc --noEmit` -- no type errors. Run `bun test src/execution/config.test.ts` after creating a quick inline test: create a temp dir, call loadRepoConfig on empty dir (should return defaults), verify model is "claude-sonnet-4-5-20250929" and maxTurns is 25.</verify>
  <done>loadRepoConfig returns full defaults when no .kodiai.yml exists, and validates+merges when it does. RepoConfig type is exported.</done>
</task>

</tasks>

<verification>
- `bunx tsc --noEmit` passes with no errors
- `bun test src/execution/` passes (config loader tests)
- Importing `{ ExecutionContext, ExecutionResult }` from `src/execution/types.ts` works
- Importing `{ loadRepoConfig, RepoConfig }` from `src/execution/config.ts` works
- `loadRepoConfig("/nonexistent/dir")` returns defaults without throwing
</verification>

<success_criteria>
- ExecutionContext type captures all fields needed for Claude invocation (workspace, owner, repo, PR number, event type)
- ExecutionResult type captures all fields returned from query() (conclusion, cost, turns, duration, session ID)
- RepoConfig schema has sensible defaults: model=claude-sonnet-4-5-20250929, maxTurns=25, review.enabled=true, mention.enabled=true
- loadRepoConfig returns defaults when no .kodiai.yml exists (zero-config requirement OPS-03)
- loadRepoConfig validates and parses .kodiai.yml when present
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/03-execution-engine/03-01-SUMMARY.md`
</output>
