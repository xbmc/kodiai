---
phase: 03-execution-engine
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/execution/mcp/comment-server.ts
  - src/execution/mcp/inline-review-server.ts
  - src/execution/mcp/ci-status-server.ts
  - src/execution/mcp/index.ts
autonomous: true

must_haves:
  truths:
    - "Comment server provides update_comment tool that updates a GitHub issue/PR comment via Octokit"
    - "Inline review server provides create_inline_comment tool that posts line-anchored PR review comments"
    - "CI status server provides get_ci_status and get_workflow_run_details tools for reading CI state"
    - "buildMcpServers assembles the correct set of MCP servers based on execution context"
  artifacts:
    - path: "src/execution/mcp/comment-server.ts"
      provides: "createCommentServer factory returning in-process MCP server"
      exports: ["createCommentServer"]
    - path: "src/execution/mcp/inline-review-server.ts"
      provides: "createInlineReviewServer factory returning in-process MCP server"
      exports: ["createInlineReviewServer"]
    - path: "src/execution/mcp/ci-status-server.ts"
      provides: "createCIStatusServer factory returning in-process MCP server"
      exports: ["createCIStatusServer"]
    - path: "src/execution/mcp/index.ts"
      provides: "buildMcpServers assembler function"
      exports: ["buildMcpServers"]
  key_links:
    - from: "src/execution/mcp/comment-server.ts"
      to: "@anthropic-ai/claude-agent-sdk"
      via: "createSdkMcpServer and tool imports"
      pattern: "createSdkMcpServer|tool"
    - from: "src/execution/mcp/inline-review-server.ts"
      to: "octokit.rest.pulls.createReviewComment"
      via: "GitHub API call for inline comments"
      pattern: "createReviewComment"
    - from: "src/execution/mcp/ci-status-server.ts"
      to: "octokit.rest.actions"
      via: "GitHub Actions API for workflow runs"
      pattern: "listWorkflowRunsForRepo|listJobsForWorkflowRun"
    - from: "src/execution/mcp/index.ts"
      to: "src/execution/mcp/*-server.ts"
      via: "Imports and assembles all three servers"
      pattern: "createCommentServer|createInlineReviewServer|createCIStatusServer"
---

<objective>
Create three in-process MCP servers that provide GitHub interaction tools to Claude during execution.

Purpose: Claude Code CLI needs tools to post comments, create inline review comments, and read CI status. These are implemented as in-process MCP servers using the Agent SDK's `createSdkMcpServer()` + `tool()` pattern, avoiding the overhead of stdio child processes. Each server receives an Octokit client via closure (not env vars), following the dependency injection pattern established in Phases 1-2.

Output: `src/execution/mcp/comment-server.ts`, `src/execution/mcp/inline-review-server.ts`, `src/execution/mcp/ci-status-server.ts`, `src/execution/mcp/index.ts`
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-execution-engine/03-RESEARCH.md
@src/auth/github-app.ts
@src/jobs/types.ts
@tmp/claude-code-action/src/mcp/github-comment-server.ts
@tmp/claude-code-action/src/mcp/github-inline-comment-server.ts
@tmp/claude-code-action/src/mcp/github-actions-server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Agent SDK and create MCP servers</name>
  <files>
    src/execution/mcp/comment-server.ts
    src/execution/mcp/inline-review-server.ts
    src/execution/mcp/ci-status-server.ts
  </files>
  <action>
**First, install dependencies:**
```bash
bun install @anthropic-ai/claude-agent-sdk @modelcontextprotocol/sdk
```

Then create the three MCP servers. All use the same pattern: factory function that receives an Octokit instance (from `getInstallationOctokit`) and context params, returns an in-process MCP server via `createSdkMcpServer()`.

**CRITICAL per research Pitfall 6:** Do NOT capture an Octokit instance at server creation time and reuse it for all calls. Instead, each server factory receives a `getOctokit` function `() => Promise<Octokit>` that creates a fresh Octokit per API call. This prevents stale tokens during long-running executions. The `getOctokit` function should be `() => githubApp.getInstallationOctokit(installationId)` which handles token refresh via auth-app caching.

**Import pattern:**
```typescript
import { tool, createSdkMcpServer } from "@anthropic-ai/claude-agent-sdk";
import { z } from "zod";
import type { Octokit } from "@octokit/rest";
```

**1. comment-server.ts -- `createCommentServer(getOctokit, owner, repo)`**

Tools:
- `update_comment`: Updates a GitHub comment (issue or PR comment). Params: `commentId: z.number()`, `body: z.string()`. Calls `octokit.rest.issues.updateComment({ owner, repo, comment_id: commentId, body })`. Returns `{ success: true, comment_id }`.

Wrap the tool handler in try/catch. On error, return `{ content: [{ type: "text", text: "Error: {message}" }], isError: true }`.

**2. inline-review-server.ts -- `createInlineReviewServer(getOctokit, owner, repo, prNumber)`**

Port from reference implementation `tmp/claude-code-action/src/mcp/github-inline-comment-server.ts`, adapting for in-process pattern.

Tools:
- `create_inline_comment`: Creates an inline comment on a PR diff line. Params:
  - `path: z.string()` -- file path
  - `body: z.string()` -- comment text (supports markdown + suggestion blocks). Use the same detailed description from the reference code explaining suggestion block format.
  - `line: z.number().nonnegative().optional()` -- line number for single-line or end line for multi-line
  - `startLine: z.number().nonnegative().optional()` -- start line for multi-line
  - `side: z.enum(["LEFT", "RIGHT"]).optional().default("RIGHT")`

Implementation (same logic as reference):
  1. Validate that at least `line` or `startLine` is provided, throw if neither.
  2. Get PR head SHA: `const pr = await octokit.rest.pulls.get({ owner, repo, pull_number: prNumber })`
  3. Build params object with `commit_id: pr.data.head.sha`
  4. If `startLine` is set, use multi-line params (`start_line`, `start_side`, `line`). Otherwise single-line (`line` only).
  5. Call `octokit.rest.pulls.createReviewComment(params)`
  6. Return `{ success: true, comment_id, html_url, path, line }`.

Include helpful error messages for "Validation Failed" (line not in diff) and "Not Found" (wrong PR/path) as the reference does.

**3. ci-status-server.ts -- `createCIStatusServer(getOctokit, owner, repo, prNumber)`**

Port from reference `tmp/claude-code-action/src/mcp/github-actions-server.ts`, adapting for in-process.

Tools:
- `get_ci_status`: Gets CI status summary for a PR. Params: `status: z.enum([...all GitHub run statuses]).optional()`.
  1. Get PR head SHA via `octokit.rest.pulls.get()`
  2. Call `octokit.rest.actions.listWorkflowRunsForRepo({ owner, repo, head_sha, ...(status && { status }) })`
  3. Summarize: total, failed, passed, pending counts + run details (id, name, status, conclusion, url).

- `get_workflow_run_details`: Get job/step details for a specific workflow run. Params: `run_id: z.number()`.
  1. Call `octokit.rest.actions.listJobsForWorkflowRun({ owner, repo, run_id })`
  2. Return jobs with failed steps highlighted.

Do NOT port the `download_job_log` tool -- it writes to RUNNER_TEMP which is GitHub Actions specific. Claude can read logs via the URL instead.

All servers use version "0.1.0" in their `createSdkMcpServer` config.
  </action>
  <verify>Run `bunx tsc --noEmit` -- no type errors. Verify each file exports its factory function.</verify>
  <done>Three MCP server factory functions exist, each returning an in-process MCP server created via createSdkMcpServer with proper tool definitions and Octokit-based handlers.</done>
</task>

<task type="auto">
  <name>Task 2: Create MCP server assembler</name>
  <files>src/execution/mcp/index.ts</files>
  <action>
Create `src/execution/mcp/index.ts` that exports `buildMcpServers()` -- a function that assembles the right MCP servers for a given execution context.

**Signature:**
```typescript
export function buildMcpServers(deps: {
  getOctokit: () => Promise<Octokit>;
  owner: string;
  repo: string;
  prNumber?: number;
  commentId?: number;
}): Record<string, ReturnType<typeof createSdkMcpServer>>
```

**Logic:**
1. Always include `github_comment` server (comments work on both issues and PRs):
   `github_comment: createCommentServer(deps.getOctokit, deps.owner, deps.repo)`

2. Only include `github_inline_comment` if `prNumber` is defined (inline review comments only work on PRs):
   `github_inline_comment: createInlineReviewServer(deps.getOctokit, deps.owner, deps.repo, deps.prNumber)`

3. Only include `github_ci` if `prNumber` is defined (CI status is relevant for PRs):
   `github_ci: createCIStatusServer(deps.getOctokit, deps.owner, deps.repo, deps.prNumber)`

Return the assembled record. The keys must match the names used in `allowedTools` patterns (e.g., `mcp__github_comment__*`).

Also export a helper function `buildAllowedMcpTools(serverNames: string[]): string[]` that generates the allowedTools patterns:
```typescript
export function buildAllowedMcpTools(serverNames: string[]): string[] {
  return serverNames.map(name => `mcp__${name}__*`);
}
```

Re-export the individual server factories for direct use if needed.
  </action>
  <verify>Run `bunx tsc --noEmit` -- no type errors. Verify the module exports buildMcpServers and buildAllowedMcpTools.</verify>
  <done>buildMcpServers assembles context-appropriate MCP servers (all 3 for PRs, comment-only for issues). buildAllowedMcpTools generates the allowedTools patterns.</done>
</task>

</tasks>

<verification>
- `bunx tsc --noEmit` passes with no errors
- `@anthropic-ai/claude-agent-sdk` and `@modelcontextprotocol/sdk` are in package.json dependencies
- Each MCP server file exports a factory function
- buildMcpServers returns 3 servers when prNumber is provided, 1 server when not
- Tool names match expected patterns: update_comment, create_inline_comment, get_ci_status, get_workflow_run_details
</verification>

<success_criteria>
- Three in-process MCP servers exist using createSdkMcpServer + tool pattern (EXEC-03)
- Comment server provides update_comment tool
- Inline review server provides create_inline_comment tool with single-line and multi-line support
- CI status server provides get_ci_status and get_workflow_run_details tools
- All servers use getOctokit() function for fresh clients per call (Pitfall 6 prevention)
- buildMcpServers conditionally includes servers based on context (PR vs issue)
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/03-execution-engine/03-02-SUMMARY.md`
</output>
