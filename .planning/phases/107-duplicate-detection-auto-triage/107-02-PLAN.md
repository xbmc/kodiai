---
phase: 107-duplicate-detection-auto-triage
plan: 02
type: execute
wave: 2
depends_on:
  - "107-01"
files_modified:
  - src/handlers/issue-opened.ts
  - src/handlers/issue-opened.test.ts
  - src/index.ts
autonomous: true
requirements:
  - TRIAGE-01
  - TRIAGE-02
  - TRIAGE-03
  - TRIAGE-04

must_haves:
  truths:
    - "When issues.opened webhook fires and autoTriageOnOpen is enabled, the handler embeds the issue, searches for duplicates, and posts a triage comment"
    - "If autoTriageOnOpen is false (default), the handler exits early without processing"
    - "Duplicate triage comments include top candidates from Plan 01's duplicate detector"
    - "If the issue was already triaged (DB flag set), the handler exits without posting a duplicate comment"
    - "If concurrent webhooks race on the same issue, only one succeeds via atomic DB INSERT ... ON CONFLICT DO NOTHING"
    - "The handler applies the configured duplicate label when candidates are found; if the label API fails, it logs a warning and continues"
    - "If no candidates meet the threshold, no comment is posted (zero noise)"
  artifacts:
    - path: "src/handlers/issue-opened.ts"
      provides: "createIssueOpenedHandler factory registered on issues.opened"
      exports: ["createIssueOpenedHandler"]
    - path: "src/handlers/issue-opened.test.ts"
      provides: "Unit tests for handler with mocked deps"
    - path: "src/index.ts"
      provides: "Handler registration alongside existing handlers"
      contains: "createIssueOpenedHandler"
  key_links:
    - from: "src/handlers/issue-opened.ts"
      to: "src/triage/duplicate-detector.ts"
      via: "findDuplicateCandidates()"
      pattern: "findDuplicateCandidates"
    - from: "src/handlers/issue-opened.ts"
      to: "src/triage/triage-comment.ts"
      via: "formatTriageComment() and buildTriageMarker()"
      pattern: "formatTriageComment"
    - from: "src/handlers/issue-opened.ts"
      to: "src/execution/config.ts"
      via: "loadRepoConfig() for autoTriageOnOpen check"
      pattern: "autoTriageOnOpen"
    - from: "src/index.ts"
      to: "src/handlers/issue-opened.ts"
      via: "createIssueOpenedHandler() registration"
      pattern: "createIssueOpenedHandler"
---

<objective>
Wire the issue-opened handler that triggers auto-triage with duplicate detection on `issues.opened` webhook events. Implements three-layer idempotency, config gating, and registers the handler in the application bootstrap.

Purpose: This is the runtime entry point that connects all Phase 107 building blocks -- the handler listens for `issues.opened`, checks config, claims the issue atomically in the DB, runs duplicate detection, posts a comment, and applies a label.

Output: Tested handler factory, updated index.ts with handler registration.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/107-duplicate-detection-auto-triage/107-RESEARCH.md
@.planning/phases/107-duplicate-detection-auto-triage/107-01-SUMMARY.md

<interfaces>
<!-- Contracts from Plan 01 that this plan consumes -->

From src/triage/duplicate-detector.ts (created in Plan 01):
```typescript
export type DuplicateCandidate = {
  issueNumber: number;
  title: string;
  state: string;
  similarityPct: number;
};

export function findDuplicateCandidates(params: {
  issueStore: IssueStore;
  embeddingProvider: EmbeddingProvider;
  title: string;
  body: string | null;
  repo: string;
  excludeIssueNumber: number;
  threshold: number;
  maxCandidates: number;
  logger: Logger;
}): Promise<DuplicateCandidate[]>;
```

From src/triage/triage-comment.ts (created in Plan 01):
```typescript
export const TRIAGE_MARKER_PREFIX: string;
export function buildTriageMarker(repo: string, issueNumber: number): string;
export function formatTriageComment(candidates: DuplicateCandidate[], marker: string): string;
```

From src/webhook/types.ts:
```typescript
export interface WebhookEvent {
  id: string;       // X-GitHub-Delivery header
  name: string;     // X-GitHub-Event header
  payload: Record<string, unknown>;
  installationId: number;
}
export type EventHandler = (event: WebhookEvent) => Promise<void>;
export interface EventRouter {
  register(eventKey: string, handler: EventHandler): void;
  dispatch(event: WebhookEvent): Promise<void>;
}
```

From src/execution/config.ts (extended in Plan 01):
```typescript
// triageSchema now includes:
// autoTriageOnOpen: boolean (default false)
// duplicateThreshold: number (default 75)
// maxDuplicateCandidates: number (default 3)
// duplicateLabel: string (default "possible-duplicate")
// cooldownMinutes: number (default 30)
```

Handler factory pattern (from src/handlers/review.ts, mention.ts, etc.):
```typescript
export function createXxxHandler(deps: {
  eventRouter: EventRouter;
  // ... other deps
}): void {
  async function handleXxx(event: WebhookEvent): Promise<void> { ... }
  eventRouter.register("event.action", handleXxx);
}
```

Handler registration in src/index.ts:
```typescript
// Existing pattern: conditional registration with dep guards
if (issueStore && embeddingProvider) {
  createIssueOpenedHandler({ ... });
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement issue-opened handler with idempotency and tests</name>
  <files>src/handlers/issue-opened.ts, src/handlers/issue-opened.test.ts</files>
  <action>
**Handler factory** (`src/handlers/issue-opened.ts`):

Create `createIssueOpenedHandler` following the established handler factory pattern. This MUST be a separate file -- do NOT add to the mention handler (STATE.md constraint: "issue-opened.ts must be a separate handler").

Dependencies accepted:
- `eventRouter: EventRouter`
- `githubApp: GitHubApp` (for getting Octokit instances)
- `issueStore: IssueStore`
- `embeddingProvider: EmbeddingProvider`
- `sql: Sql` (postgres tagged template, for triage state queries)
- `logger: Logger`

Register on `"issues.opened"` event key.

**Handler flow (`handleIssueOpened`):**

1. **Extract issue from payload**: `event.payload.issue` as `{ number, title, body, user: { login }, repository: { full_name, owner: { login } } }`. Also extract `event.payload.repository` for `full_name` (repo) and `owner.login` (owner).

2. **Load repo config**: Use `loadRepoConfig()` from `src/execution/config.ts`. Check `config.triage.autoTriageOnOpen` -- if false, log debug and return early (TRIAGE-02).

3. **Also check `config.triage.enabled`** -- if triage is completely disabled, return early.

4. **Atomic DB claim (Layer 2 idempotency)**: Call `claimIssueTriage(sql, repo, issueNumber, event.id)`. This function (defined in the same file as a helper) does:
   ```sql
   INSERT INTO issue_triage_state (repo, issue_number, delivery_id)
   VALUES ($repo, $issueNumber, $deliveryId)
   ON CONFLICT (repo, issue_number) DO NOTHING
   RETURNING id
   ```
   If no row returned (already claimed), log info and return early (TRIAGE-04).

5. **Run duplicate detection**: Call `findDuplicateCandidates()` from Plan 01's module with config values (`threshold: config.triage.duplicateThreshold`, `maxCandidates: config.triage.maxDuplicateCandidates`). Pass `excludeIssueNumber: issueNumber`.

6. **Check results**: If candidates array is empty, log info ("no duplicates found, skipping comment") and return. No comment posted = zero noise (per locked decision).

7. **Format comment**: Call `formatTriageComment(candidates, buildTriageMarker(repo, issueNumber))`.

8. **Post comment**: Get Octokit via `githubApp.getInstallationOctokit(event.installationId)`. Call `octokit.rest.issues.createComment({ owner, repo: repoName, issue_number: issueNumber, body: commentBody })`.

9. **Apply label** (if candidates found): Wrap in try/catch. Call `octokit.rest.issues.addLabels({ owner, repo: repoName, issue_number: issueNumber, labels: [config.triage.duplicateLabel] })`. On error, log warning and continue (per locked decision: "if label doesn't exist, log warning and skip labeling"). Do NOT throw.

10. **Update triage state**: Update the `issue_triage_state` row with `duplicate_count`:
    ```sql
    UPDATE issue_triage_state SET duplicate_count = $count WHERE repo = $repo AND issue_number = $issueNumber
    ```

11. **Log completion**: Log info with repo, issueNumber, candidateCount, deliveryId.

**Comment marker fallback (Layer 3 idempotency)**: Before step 4, add an OPTIONAL comment scan fallback. Check if any existing comment on the issue contains the triage marker. Use `octokit.rest.issues.listComments()` with `per_page: 10` (recent only). If a comment contains `TRIAGE_MARKER_PREFIX`, log info and return early. This is the belt to the DB-claim suspenders. Wrap in try/catch -- if the API call fails, log warning and continue to the DB claim (fail-open).

**Error handling**: Wrap the entire handler body in try/catch. On any unhandled error, log error with full context and return (never throw to avoid breaking Promise.allSettled in router).

**Tests** (`src/handlers/issue-opened.test.ts`):

Use `describe`/`test` with mock dependencies:
- Mock `eventRouter.register` to capture the handler
- Mock `githubApp.getInstallationOctokit` to return mock Octokit
- Mock `issueStore`, `embeddingProvider`, `sql`

Test cases:
1. **Config gate**: autoTriageOnOpen=false -> handler returns without processing, no comment posted
2. **Triage disabled**: triage.enabled=false -> handler returns without processing
3. **Already triaged (DB claim fails)**: sql INSERT returns empty array -> handler returns without posting comment
4. **No duplicates found**: findDuplicateCandidates returns [] -> no comment posted
5. **Duplicates found**: findDuplicateCandidates returns candidates -> comment posted with correct body, label applied
6. **Label API failure**: addLabels throws -> warning logged, handler completes successfully (no throw)
7. **Comment marker fallback**: existing comment with triage marker -> handler returns early
8. **Fail-open on comment scan error**: listComments throws -> handler continues to DB claim

For the `loadRepoConfig` mock, create a test helper that returns a config object with the triage section populated. Use `vi.mock` or dependency injection pattern consistent with the project's test style (check existing handler tests for pattern).
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && bun test src/handlers/issue-opened.test.ts --timeout 30000</automated>
  </verify>
  <done>Handler factory creates and registers an `issues.opened` handler. Config gate checks autoTriageOnOpen and triage.enabled. Atomic DB claim prevents duplicate processing. Duplicate detection runs fail-open. Comment posted only when candidates found. Label applied with try/catch fallback. Three-layer idempotency operational. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Register handler in application bootstrap</name>
  <files>src/index.ts</files>
  <action>
**Wire the handler** in `src/index.ts`:

1. Add import at top alongside existing handler imports:
   ```typescript
   import { createIssueOpenedHandler } from "./handlers/issue-opened.ts";
   ```

2. Add handler registration AFTER the existing handler registrations (after `createReviewCommentSyncHandler` and similar blocks). Follow the conditional guard pattern:
   ```typescript
   if (issueStore && embeddingProvider) {
     createIssueOpenedHandler({
       eventRouter,
       githubApp,
       issueStore,
       embeddingProvider,
       sql,
       logger,
     });
   }
   ```

   The `sql` and `logger` variables are already available in scope in `src/index.ts`. The `issueStore` and `embeddingProvider` guards ensure the handler is only registered when the knowledge stack is available.

3. Do NOT modify any other handler registration. Do NOT add conditional logic beyond what's shown. The `autoTriageOnOpen` check happens inside the handler itself (not at registration time), so the handler is always registered when deps are available.
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && grep -q "createIssueOpenedHandler" src/index.ts && grep -q "issue-opened" src/index.ts && echo "handler registered"</automated>
  </verify>
  <done>createIssueOpenedHandler is imported and registered in src/index.ts with issueStore and embeddingProvider guards. Handler receives all required deps (eventRouter, githubApp, issueStore, embeddingProvider, sql, logger).</done>
</task>

</tasks>

<verification>
1. Handler is registered on `"issues.opened"` event key in the EventRouter
2. autoTriageOnOpen=false causes early return with no API calls
3. DB atomic claim prevents concurrent duplicate processing
4. Comment marker fallback catches edge cases missed by DB claim
5. No duplicate comment is posted when issue already triaged
6. Label application failure does not block handler completion
7. Empty candidate list produces no comment (zero noise)
8. Handler is registered in src/index.ts with proper dep guards
9. All tests pass: `bun test src/handlers/issue-opened.test.ts --timeout 30000`
</verification>

<success_criteria>
- [ ] `createIssueOpenedHandler` registered on `issues.opened` in EventRouter
- [ ] Config-gated: autoTriageOnOpen=false skips processing (TRIAGE-02)
- [ ] Three-layer idempotency operational: delivery-ID dedup (Layer 1, handled by existing webhook route), DB claim (Layer 2), comment marker scan (Layer 3) (TRIAGE-04)
- [ ] Triage comment includes duplicate candidates from findDuplicateCandidates (TRIAGE-03)
- [ ] Label applied with try/catch, failure logged not thrown
- [ ] Handler registered in src/index.ts with issueStore + embeddingProvider guard
- [ ] All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/107-duplicate-detection-auto-triage/107-02-SUMMARY.md`
</output>
