---
phase: 100-review-pattern-clustering
plan: 05
type: execute
wave: 3
depends_on: [03, 04]
files_modified:
  - src/knowledge/cluster-scheduler.ts
  - src/execution/review-prompt.ts
  - src/execution/review-prompt.test.ts
  - src/index.ts
autonomous: true
requirements: [CLST-03, CLST-04]

must_haves:
  truths:
    - Weekly scheduled job runs cluster pipeline automatically
    - On-demand triggering available via Slack command
    - Pattern footnotes appear in PR review prompts as subtle inline annotations
    - Max 3 pattern footnotes per review
    - Patterns surface proactively even without reviewer flagging
  artifacts:
    - src/knowledge/cluster-scheduler.ts
    - src/execution/review-prompt.ts (modified)
    - src/index.ts (modified)
  key_links:
    - cluster-scheduler.ts creates weekly setInterval scheduler
    - review-prompt.ts formatClusterPatterns() injects footnotes
    - index.ts wires scheduler startup and Slack on-demand trigger
---

<objective>
Wire cluster scheduler, pattern injection into reviews, and index.ts integration.

Purpose: Complete the end-to-end flow — clusters discovered on schedule, patterns surfaced in reviews, on-demand trigger available.
Output: Scheduler, review prompt injection, full application wiring.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/100-review-pattern-clustering/100-RESEARCH.md
@.planning/phases/100-review-pattern-clustering/100-03-SUMMARY.md
@.planning/phases/100-review-pattern-clustering/100-04-SUMMARY.md

<interfaces>
From src/knowledge/cluster-types.ts (plan 01):
```typescript
export type ClusterScheduler = { start(): void; stop(): void; runNow(): Promise<void>; };
export type ClusterPipelineOptions = { sql: Sql; taskRouter: TaskRouter; logger: Logger; };
export type ClusterPatternMatch = {
  clusterId: number; slug: string; label: string; memberCount: number;
  similarityScore: number; filePathOverlap: number; combinedScore: number;
  representativeSample: string;
};
```

From src/knowledge/cluster-pipeline.ts (plan 03):
```typescript
export async function runClusterPipeline(opts: {
  sql: Sql; store: ClusterStore; taskRouter: TaskRouter;
  logger: Logger; repo: string; minClusterSize?: number;
}): Promise<ClusterRunState>;
```

From src/knowledge/cluster-matcher.ts (plan 04):
```typescript
export async function matchClusterPatterns(
  input: { prEmbedding: Float32Array | null; prFilePaths: string[]; repo: string },
  store: ClusterStore, sql: Sql, logger: Logger,
): Promise<ClusterPatternMatch[]>;
```

From src/knowledge/cluster-store.ts (plan 02):
```typescript
export function createClusterStore(opts: { sql: Sql; logger: Logger }): ClusterStore;
```

From src/execution/review-prompt.ts (existing):
```typescript
export function formatReviewPrecedents(matches: ReviewCommentMatch[]): string;
// Returns formatted section or empty string
export function buildReviewPrompt(context: { /* large context object */ }): string;
```

From src/knowledge/wiki-staleness-detector.ts (scheduler pattern):
```typescript
// Uses setInterval with startup delay, run-state persistence, stop lifecycle
const DEFAULT_INTERVAL_MS = 7 * 24 * 60 * 60 * 1000;
const DEFAULT_STARTUP_DELAY_MS = 90_000;
```

From src/index.ts (existing wiring patterns):
```typescript
// Wiki staleness detector wiring (lines 468-499)
const wikiStalenessDetector = config.someFlag ? createDetector({...}) : null;
if (wikiStalenessDetector) { wikiStalenessDetector.start(); }
// Slack on-demand trigger (lines 512-522)
if (/wiki[-\s]?check/i.test(payload.text) && wikiStalenessDetector) { ... }
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cluster scheduler</name>
  <files>src/knowledge/cluster-scheduler.ts</files>
  <action>
Create `cluster-scheduler.ts` following the wiki-staleness-detector.ts scheduler pattern exactly.

```typescript
import type { Logger } from "pino";
import type { Sql } from "../db/client.ts";
import type { TaskRouter } from "../llm/task-router.ts";
import type { ClusterScheduler } from "./cluster-types.ts";
import { createClusterStore } from "./cluster-store.ts";
import { runClusterPipeline } from "./cluster-pipeline.ts";

const DEFAULT_INTERVAL_MS = 7 * 24 * 60 * 60 * 1000; // 7 days
const DEFAULT_STARTUP_DELAY_MS = 120_000; // 2 minutes (stagger after wiki staleness at 90s)

export type ClusterSchedulerOptions = {
  sql: Sql;
  taskRouter: TaskRouter;
  logger: Logger;
  /** Repos to cluster. Initially supports single repo; can expand to multi-repo. */
  repos: string[];
};

export function createClusterScheduler(opts: ClusterSchedulerOptions): ClusterScheduler {
  const { sql, taskRouter, logger, repos } = opts;
  const store = createClusterStore({ sql, logger });
  let startupTimer: ReturnType<typeof setTimeout> | null = null;
  let intervalTimer: ReturnType<typeof setInterval> | null = null;

  async function runAll(): Promise<void> {
    for (const repo of repos) {
      try {
        logger.info({ repo }, "Starting cluster pipeline for repo");
        await runClusterPipeline({ sql, store, taskRouter, logger, repo });
        logger.info({ repo }, "Cluster pipeline completed for repo");
      } catch (err) {
        // Fail-open: log and continue to next repo
        logger.error({ err, repo }, "Cluster pipeline failed for repo (fail-open)");
      }
    }
  }

  return {
    start() {
      startupTimer = setTimeout(async () => {
        await runAll();
        intervalTimer = setInterval(() => {
          runAll().catch((err) => {
            logger.error({ err }, "Cluster scheduler interval run failed");
          });
        }, DEFAULT_INTERVAL_MS);
      }, DEFAULT_STARTUP_DELAY_MS);
      logger.info(
        { intervalDays: 7, startupDelayMs: DEFAULT_STARTUP_DELAY_MS, repos },
        "Cluster scheduler started",
      );
    },
    stop() {
      if (startupTimer) clearTimeout(startupTimer);
      if (intervalTimer) clearInterval(intervalTimer);
      startupTimer = null;
      intervalTimer = null;
      logger.debug("Cluster scheduler stopped");
    },
    async runNow() {
      await runAll();
    },
  };
}
```

Key design decisions:
- Startup delay of 120s (staggered 30s after wiki staleness detector at 90s)
- Iterates over configured repos (initially just one repo)
- Fail-open: individual repo failure doesn't block other repos
- Same start/stop/runNow interface as wiki staleness detector
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && bun build src/knowledge/cluster-scheduler.ts --no-bundle 2>&1 | head -5</automated>
  </verify>
  <done>Cluster scheduler compiles, follows wiki-staleness-detector pattern, supports multi-repo iteration with fail-open.</done>
</task>

<task type="auto">
  <name>Task 2: Add pattern footnote injection to review prompt</name>
  <files>src/execution/review-prompt.ts, src/execution/review-prompt.test.ts</files>
  <action>
Add `formatClusterPatterns()` function to `review-prompt.ts` and integrate it into `buildReviewPrompt()`.

**Add the formatter function** (near `formatReviewPrecedents` around line 960):

```typescript
const MAX_CLUSTER_PATTERNS = 3;

/**
 * Format cluster pattern matches as subtle footnote-style annotations for review comments.
 * Returns empty string when no matches exist (no section noise).
 *
 * Per user decision: patterns appear as inline footnote annotations, not a standalone section.
 * The LLM is instructed to append these as footnotes to relevant review comments.
 */
export function formatClusterPatterns(patterns: ClusterPatternMatch[]): string {
  if (patterns.length === 0) return "";

  const capped = patterns.slice(0, MAX_CLUSTER_PATTERNS);

  const bullets: string[] = [];
  for (const p of capped) {
    const sample = truncateAtWordBoundary(
      p.representativeSample.replace(/\n/g, " ").trim(),
      150,
    );
    bullets.push(
      `- **${p.slug}**: ${p.label} (${p.memberCount} occurrences in last 60 days)\n  Example: "${sample}"`,
    );
  }

  return [
    "## Recurring Review Patterns",
    "",
    "The following patterns have been identified from historical code reviews on this codebase.",
    "When your review findings align with one of these patterns, append a subtle footnote:",
    '`*(Recurring pattern: [slug] — seen N times in last 60 days)*`',
    "",
    "Add the footnote at the END of your review comment, not as a separate comment.",
    "Only add footnotes when there is a strong match. Max 3 pattern footnotes per review.",
    "Proactively flag code areas matching these patterns even if you would not otherwise comment.",
    "",
    "---",
    ...bullets,
    "---",
  ].join("\n");
}
```

**Import the type** at top of file:
```typescript
import type { ClusterPatternMatch } from "../knowledge/cluster-types.ts";
```

**Integrate into buildReviewPrompt()**:
Add `clusterPatterns?: ClusterPatternMatch[]` to the context parameter type of `buildReviewPrompt`.

In the prompt assembly section (where formatReviewPrecedents and formatWikiKnowledge are called), add:
```typescript
const clusterPatternsSection = formatClusterPatterns(context.clusterPatterns ?? []);
```

Include `clusterPatternsSection` in the assembled prompt sections (after the review precedents section).

**Add tests** to `review-prompt.test.ts`:
1. `formatClusterPatterns` returns empty string for empty array
2. `formatClusterPatterns` formats up to 3 patterns with slug, label, count, and sample
3. `formatClusterPatterns` truncates long representative samples
4. `formatClusterPatterns` caps at MAX_CLUSTER_PATTERNS=3 even with more input
5. `buildReviewPrompt` includes cluster patterns section when provided
6. `buildReviewPrompt` omits cluster patterns section when empty/undefined
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && bun test src/execution/review-prompt.test.ts 2>&1 | tail -30</automated>
  </verify>
  <done>formatClusterPatterns correctly formats footnote-style pattern annotations. buildReviewPrompt includes cluster patterns in output when provided. All existing and new review-prompt tests pass.</done>
</task>

<task type="auto">
  <name>Task 3: Wire cluster scheduler and matcher into index.ts</name>
  <files>src/index.ts</files>
  <action>
Wire the cluster scheduler into `index.ts` following the exact pattern used for the wiki staleness detector (lines 468-499).

**Add imports** (near existing knowledge imports):
```typescript
import { createClusterScheduler } from "./knowledge/cluster-scheduler.ts";
import { createClusterStore } from "./knowledge/cluster-store.ts";
```

**Add mutable reference** (near the wiki staleness detector ref around line 94-102):
```typescript
let _clusterSchedulerRef: ClusterScheduler | null = null;
```

**Add shutdown cleanup** (in the shutdown handler near the wiki staleness stop):
```typescript
_clusterSchedulerRef?.stop();
```

**Create and start scheduler** (after the wiki staleness detector block, around line 499):
```typescript
// Review pattern clustering (Phase 100: weekly scheduled clustering + on-demand)
const clusterTaskRouter = createTaskRouter({ models: {} }, logger);
const clusterScheduler = createClusterScheduler({
  sql,
  taskRouter: clusterTaskRouter,
  logger,
  repos: [config.wikiGithubRepo].filter(Boolean) as string[],
});
clusterScheduler.start();
_clusterSchedulerRef = clusterScheduler;
logger.info(
  { intervalDays: 7, startupDelayMs: 120_000 },
  "Cluster scheduler started (7-day interval, 120s startup delay)",
);
```

**Add on-demand Slack trigger** (in the onAllowedBootstrap handler, after the wiki-check trigger around line 522):
```typescript
// On-demand cluster refresh trigger: @kodiai cluster-refresh
if (/cluster[-\s]?refresh/i.test(payload.text) && _clusterSchedulerRef) {
  const untrackJob = requestTracker?.trackJob();
  Promise.resolve()
    .then(async () => {
      logger.info({ channel: payload.channel, user: payload.user }, "On-demand cluster-refresh triggered");
      await _clusterSchedulerRef!.runNow();
    })
    .catch((err) => {
      logger.error({ err }, "On-demand cluster-refresh failed");
    })
    .finally(() => untrackJob?.());
  return;
}
```

**Wire cluster matcher into review execution** (in the section where review context is built — find where `formatReviewPrecedents` result is used):
- Import `matchClusterPatterns` and `createClusterStore`
- Before building the review prompt, call `matchClusterPatterns` with the PR's diff embedding and file paths
- Pass results as `clusterPatterns` to `buildReviewPrompt`

Look for where `buildReviewPrompt` is called (likely in executor.ts or a handler). The `clusterPatterns` field was added as optional, so existing call sites continue working. Find the primary call site and add the cluster matching call there.

If the call site is in `executor.ts`, add:
```typescript
// Match cluster patterns (fail-open)
let clusterPatterns: ClusterPatternMatch[] = [];
try {
  const clusterStore = createClusterStore({ sql, logger });
  clusterPatterns = await matchClusterPatterns(
    { prEmbedding: diffEmbedding, prFilePaths: changedFiles, repo },
    clusterStore, sql, logger,
  );
} catch (err) {
  logger.warn({ err }, "Cluster pattern matching failed (fail-open)");
}
```

Pass `clusterPatterns` to the `buildReviewPrompt` context object.

**Important considerations:**
- Use the same `sql` instance already available in the execution context
- Fail-open: wrap matcher call in try/catch, log warning, continue with empty patterns
- The repos list uses `config.wikiGithubRepo` as the repo identifier (same repo as wiki/review corpus)
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && bun build src/index.ts --no-bundle 2>&1 | head -10</automated>
  </verify>
  <done>Cluster scheduler starts on app boot with 120s delay. On-demand Slack trigger works via "cluster-refresh" command. Pattern matching wired into review execution pipeline. index.ts compiles cleanly.</done>
</task>

</tasks>

<verification>
- [ ] Cluster scheduler starts on boot with 7-day interval and 120s startup delay
- [ ] Scheduler stops cleanly on shutdown
- [ ] On-demand Slack trigger via "cluster-refresh" command
- [ ] formatClusterPatterns returns footnote-style annotations
- [ ] buildReviewPrompt includes cluster patterns section
- [ ] Cluster matcher wired into review execution with fail-open error handling
- [ ] All existing tests continue to pass (no regressions)
- [ ] index.ts compiles cleanly
</verification>

<success_criteria>
- Full end-to-end wiring: scheduler -> pipeline -> store -> matcher -> review prompt
- Weekly clustering runs automatically
- On-demand trigger available via Slack
- Pattern footnotes appear in PR reviews when relevant clusters match
- All changes are fail-open — clustering failures never block reviews
</success_criteria>

<output>
After completion, create `.planning/phases/100-review-pattern-clustering/100-05-SUMMARY.md`
</output>
