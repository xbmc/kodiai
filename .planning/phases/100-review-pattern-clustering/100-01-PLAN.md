---
phase: 100-review-pattern-clustering
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/knowledge/cluster-types.ts
  - src/knowledge/hdbscan.ts
  - src/knowledge/hdbscan.test.ts
autonomous: true
requirements: [CLST-01, CLST-05]

must_haves:
  truths:
    - HDBSCAN algorithm correctly discovers density-based clusters from pre-computed distance matrices
    - UMAP reduces 1024-dim embeddings to lower dimensions before clustering
    - Noise points (label -1) are correctly separated from cluster members
  artifacts:
    - src/knowledge/cluster-types.ts
    - src/knowledge/hdbscan.ts
    - src/knowledge/hdbscan.test.ts
  key_links:
    - hdbscan.ts exports hdbscan() function consuming distance matrices
    - cluster-types.ts exports all shared types used by subsequent plans
---

<objective>
Implement core HDBSCAN algorithm and define cluster type contracts for the entire phase.

Purpose: Provide the clustering engine and type foundation that all other plans build upon.
Output: Pure HDBSCAN implementation with comprehensive tests, shared type definitions.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/references/tdd.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/100-review-pattern-clustering/100-RESEARCH.md

<interfaces>
<!-- Key types from existing codebase that this plan needs -->

From src/knowledge/review-comment-types.ts:
```typescript
export type ReviewCommentRecord = {
  id: number;
  repo: string;
  filePath: string | null;
  chunkText: string;
  embedding: unknown;
  githubCreatedAt: string;
  // ... other fields
};
```

From src/knowledge/embeddings.ts:
```typescript
export function createEmbeddingProvider(opts: {
  apiKey: string; model: string; dimensions: number; logger: Logger;
}): EmbeddingProvider;
// Returns { generate(text, inputType): Promise<EmbeddingResult> }
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define cluster type contracts</name>
  <files>src/knowledge/cluster-types.ts</files>
  <action>
Create `src/knowledge/cluster-types.ts` with all shared types for Phase 100:

```typescript
/** HDBSCAN algorithm result */
export type HdbscanResult = {
  labels: number[];        // -1 = noise, 0+ = cluster ID
  probabilities: number[]; // Membership strength 0..1
  clusterCount: number;
};

/** HDBSCAN configuration */
export type HdbscanOptions = {
  minClusterSize: number;  // Minimum members to form a cluster (recommend: 3)
  minSamples?: number;     // Core distance samples (defaults to minClusterSize)
};

/** A discovered review pattern cluster */
export type ReviewCluster = {
  id: number;
  repo: string;
  slug: string;                    // Short technical slug (e.g., "null-check-missing")
  label: string;                   // Natural language description
  centroid: Float32Array;          // Mean embedding of cluster members
  memberCount: number;             // Current member count
  memberCountAtLabel: number;      // Member count when label was generated
  filePaths: string[];             // Unique file paths across cluster members
  createdAt: Date;
  updatedAt: Date;
  labelUpdatedAt: Date;
  pinned: boolean;                 // Manual label override (never auto-regenerate)
  retired: boolean;                // Below threshold, not surfaced
};

/** Assignment of a review comment to a cluster */
export type ClusterAssignment = {
  id: number;
  clusterId: number;
  reviewCommentId: number;         // FK to review_comments.id
  probability: number;             // HDBSCAN membership probability
  assignedAt: Date;
};

/** Match result when checking PR against active clusters */
export type ClusterPatternMatch = {
  clusterId: number;
  slug: string;
  label: string;
  memberCount: number;
  similarityScore: number;         // Cosine similarity to cluster centroid
  filePathOverlap: number;         // Fraction of cluster file paths matching PR
  combinedScore: number;           // Weighted combination
  representativeSample: string;    // One example comment for context
};

/** Run state for cluster refresh pipeline */
export type ClusterRunState = {
  id?: number;
  lastRunAt: Date | null;
  clustersDiscovered: number;
  commentsProcessed: number;
  labelsGenerated: number;
  status: "pending" | "running" | "completed" | "failed";
  errorMessage: string | null;
  updatedAt?: string;
};

/** Options for creating the cluster pipeline */
export type ClusterPipelineOptions = {
  sql: import("../db/client.ts").Sql;
  taskRouter: import("../llm/task-router.ts").TaskRouter;
  logger: import("pino").Logger;
};

/** Cluster store interface */
export type ClusterStore = {
  upsertCluster(cluster: Omit<ReviewCluster, "id" | "createdAt" | "updatedAt">): Promise<ReviewCluster>;
  getActiveClusters(repo: string): Promise<ReviewCluster[]>;
  retireCluster(clusterId: number): Promise<void>;
  updateClusterLabel(clusterId: number, slug: string, label: string, memberCount: number): Promise<void>;
  pinClusterLabel(clusterId: number, slug: string, label: string): Promise<void>;
  writeAssignments(assignments: Omit<ClusterAssignment, "id" | "assignedAt">[]): Promise<void>;
  clearAssignments(clusterId: number): Promise<void>;
  getAssignmentsByCluster(clusterId: number): Promise<ClusterAssignment[]>;
  getRunState(): Promise<ClusterRunState>;
  saveRunState(state: ClusterRunState): Promise<void>;
};

/** Cluster scheduler interface */
export type ClusterScheduler = {
  start(): void;
  stop(): void;
  runNow(): Promise<void>;
};
```

Export all types. This is the single source of truth for all cluster-related types in the phase.
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && bun build src/knowledge/cluster-types.ts --no-bundle 2>&1 | head -5</automated>
  </verify>
  <done>cluster-types.ts exists, exports all types, type-checks cleanly</done>
</task>

<task type="auto">
  <name>Task 2: Implement and test HDBSCAN algorithm (TDD)</name>
  <files>src/knowledge/hdbscan.ts, src/knowledge/hdbscan.test.ts</files>
  <action>
Implement HDBSCAN clustering algorithm in pure TypeScript following TDD (RED-GREEN-REFACTOR).

**Write tests first** in `hdbscan.test.ts`:

1. **Basic clustering**: 3 tight clusters of 5 points each in 2D, minClusterSize=3 -> discovers 3 clusters
2. **Noise detection**: Scatter 5 random outlier points among 2 clusters -> outliers get label -1
3. **Single cluster**: All points within tight radius -> 1 cluster
4. **All noise**: Points spread far apart with minClusterSize=5 -> 0 clusters, all noise
5. **Probabilities**: Points near cluster center have probability > 0.8, edge points < 0.5
6. **minClusterSize respect**: 2 groups of 2 points with minClusterSize=3 -> both groups are noise
7. **Empty input**: Empty array -> 0 clusters

**Then implement** `hdbscan.ts`:

The algorithm follows Campello et al. 2013:

1. **Compute core distances**: For each point, the distance to its `minSamples`-th nearest neighbor
2. **Compute mutual reachability distances**: `max(core_dist(a), core_dist(b), dist(a,b))` for all pairs
3. **Build minimum spanning tree**: Prim's algorithm on the mutual reachability graph
4. **Build cluster hierarchy**: Sort MST edges by weight, build dendrogram via single-linkage
5. **Extract flat clusters**: Excess of Mass (EOM) method — walk the dendrogram, compute stability of each cluster, select the set of non-overlapping clusters maximizing total stability

Function signature:
```typescript
export function hdbscan(
  data: number[][],     // N points, each D-dimensional
  opts: HdbscanOptions,
): HdbscanResult;
```

Use `Float64Array` internally for distance matrices. Accept `number[][]` as input (will receive UMAP output which is low-dimensional).

For distance computation, use Euclidean distance (standard for UMAP output in embedding space).

Do NOT use external libraries — implement from scratch. The algorithm is well-documented and data volumes are small (hundreds to low thousands of points).

Performance target: <2 seconds for 5000 points in 15 dimensions on commodity hardware.
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && bun test src/knowledge/hdbscan.test.ts 2>&1 | tail -20</automated>
  </verify>
  <done>All 7+ HDBSCAN test cases pass. Algorithm correctly discovers clusters, handles noise, respects minClusterSize, and returns valid probabilities.</done>
</task>

</tasks>

<verification>
- [ ] `cluster-types.ts` exports all types needed by plans 02-04
- [ ] `hdbscan()` function takes number[][] + options, returns HdbscanResult
- [ ] Tests cover: basic clustering, noise detection, single cluster, all noise, probabilities, minClusterSize, empty input
- [ ] No external HDBSCAN library dependency
- [ ] Type-checks cleanly with existing codebase
</verification>

<success_criteria>
- HDBSCAN algorithm implementation passes all test cases
- Type contracts defined for clusters, assignments, matches, run state, store, scheduler
- Zero external dependencies added (HDBSCAN is pure TypeScript)
</success_criteria>

<output>
After completion, create `.planning/phases/100-review-pattern-clustering/100-01-SUMMARY.md`
</output>
