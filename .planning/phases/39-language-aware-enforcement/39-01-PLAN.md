---
phase: 39-language-aware-enforcement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/enforcement/types.ts
  - src/enforcement/tooling-detection.ts
  - src/enforcement/tooling-detection.test.ts
  - src/execution/config.ts
  - src/execution/config.test.ts
autonomous: true

must_haves:
  truths:
    - "Enforcement types define SeverityPattern, DetectedTooling, and EnforcedFinding structures"
    - "detectRepoTooling scans workspace for formatter/linter config files and returns per-language results"
    - "Go formatting is treated as always-on when go.mod exists (gofmt built-in)"
    - "languageRules section in .kodiai.yml validates with Zod and falls back to defaults on error"
    - "Tooling detection is fail-open -- filesystem errors never block the review"
  artifacts:
    - path: "src/enforcement/types.ts"
      provides: "SeverityPattern, DetectedTooling, EnforcedFinding, LanguageRulesConfig types"
      exports: ["SeverityPattern", "DetectedTooling", "EnforcedFinding", "LanguageRulesConfig"]
    - path: "src/enforcement/tooling-detection.ts"
      provides: "detectRepoTooling function and config file constants"
      exports: ["detectRepoTooling", "FORMATTER_CONFIGS", "LINTER_CONFIGS"]
    - path: "src/enforcement/tooling-detection.test.ts"
      provides: "Tests for tooling detection"
    - path: "src/execution/config.ts"
      provides: "languageRules Zod schema added to repoConfigSchema"
      contains: "languageRulesSchema"
    - path: "src/execution/config.test.ts"
      provides: "Tests for languageRules config parsing and fallback"
  key_links:
    - from: "src/enforcement/types.ts"
      to: "src/knowledge/types.ts"
      via: "imports FindingSeverity, FindingCategory"
      pattern: "import.*FindingSeverity.*from.*knowledge/types"
    - from: "src/enforcement/tooling-detection.ts"
      to: "src/enforcement/types.ts"
      via: "imports DetectedTooling type"
      pattern: "import.*DetectedTooling.*from.*types"
    - from: "src/execution/config.ts"
      to: "src/enforcement/types.ts"
      via: "LanguageRulesConfig type used in schema inference"
      pattern: "languageRules"
---

<objective>
Create the foundation types, tooling detection module, and config schema extension for the language-aware enforcement system.

Purpose: Establish the type contracts and detection infrastructure that severity floor enforcement (Plan 02) and tooling suppression (Plan 03) build upon. The config schema extension enables user overrides via `.kodiai.yml`.

Output: `src/enforcement/types.ts`, `src/enforcement/tooling-detection.ts` with tests, updated `src/execution/config.ts` with `languageRules` schema section.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/39-language-aware-enforcement/39-CONTEXT.md
@.planning/phases/39-language-aware-enforcement/39-RESEARCH.md
@src/knowledge/types.ts
@src/execution/config.ts
@src/execution/config.test.ts
@src/execution/diff-analysis.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create enforcement types and tooling detection module</name>
  <files>
    src/enforcement/types.ts
    src/enforcement/tooling-detection.ts
    src/enforcement/tooling-detection.test.ts
  </files>
  <action>
Create `src/enforcement/types.ts` with these type definitions:

1. **SeverityPattern** -- defines a pattern for severity floor enforcement:
   - `id: string` (e.g., "cpp-null-deref")
   - `language: string` (e.g., "C++")
   - `keywords: string[][]` (OR-of-AND groups: `[["null", "dereference"], ["null", "pointer"]]`)
   - `minSeverity: FindingSeverity` (floor to enforce)
   - `category?: FindingCategory` (optional category filter for precision)
   - `contextRelaxation?: { testFiles: boolean; relaxedSeverity?: FindingSeverity }` (per user decision: context-aware enforcement)
   - `description: string` (human-readable explanation)

2. **DetectedTooling** -- result of workspace scanning:
   - `formatters: Map<string, string[]>` (language -> config files found)
   - `linters: Map<string, string[]>` (language -> config files found)

3. **EnforcedFinding** -- extends ExtractedFinding concept with enforcement metadata:
   - Import `FindingSeverity` and `FindingCategory` from `../knowledge/types.ts`
   - `originalSeverity: FindingSeverity` (pre-enforcement severity)
   - `severity: FindingSeverity` (post-enforcement -- may be elevated)
   - `severityElevated: boolean`
   - `enforcementPatternId?: string` (which pattern matched)
   - `toolingSuppressed: boolean` (whether tooling detection suppressed this)

4. **LanguageRulesConfig** -- user-facing config type (matches what Zod schema produces):
   - `severityFloors: Array<{ pattern: string; language?: string; minSeverity: FindingSeverity; skipTestFiles: boolean }>`
   - `toolingOverrides: Array<{ language: string; suppressFormatting: boolean; suppressImportOrder: boolean; configFiles?: string[] }>`
   - `disableBuiltinFloors: boolean`

Create `src/enforcement/tooling-detection.ts`:

1. Export `FORMATTER_CONFIGS: Record<string, string[]>` mapping languages to formatter config file names. Include at minimum: JavaScript/TypeScript (prettier variants), Python (.black.toml, pyproject.toml), C++ (.clang-format), C (.clang-format), Go (special-cased), Rust (rustfmt.toml), Java (.editorconfig, google-java-format.xml). Also include `.editorconfig` for all languages.

2. Export `LINTER_CONFIGS: Record<string, string[]>` mapping languages to linter config file names. Include: JavaScript/TypeScript (eslintrc variants + flat config eslint.config.*), Python (setup.cfg, tox.ini, .flake8, .pylintrc, pyproject.toml), Go (.golangci.yml/.yaml/.json), Rust (clippy.toml).

3. Export `async function detectRepoTooling(workspaceDir: string): Promise<DetectedTooling>`:
   - Iterate FORMATTER_CONFIGS, check each file with `Bun.file(join(workspaceDir, configFile)).exists()`
   - Special case: If `join(workspaceDir, "go.mod")` exists, set formatters for Go to `["go.mod (gofmt built-in)"]` (Go always has gofmt -- per research pitfall 4)
   - Similarly iterate LINTER_CONFIGS
   - Wrap in try/catch: on any error, log a warning and return empty maps (fail-open per research anti-pattern guidance)
   - Use `node:path` `join()` for path construction

Create `src/enforcement/tooling-detection.test.ts`:
- Test detection of various formatter configs (.prettierrc, .clang-format, .black.toml)
- Test detection of linter configs (.eslintrc.json, eslint.config.js, .golangci.yml)
- Test Go special case (go.mod -> formatter detected)
- Test empty workspace returns empty maps
- Test fail-open behavior (mock filesystem error returns empty maps)
- Use `bun:test`, create temp directories with `mkdtemp` for real filesystem tests
  </action>
  <verify>
`cd /home/keith/src/kodiai && bun test src/enforcement/tooling-detection.test.ts` passes all tests.
TypeScript compilation: `bunx tsc --noEmit src/enforcement/types.ts src/enforcement/tooling-detection.ts` has no errors.
  </verify>
  <done>
Types exported from types.ts. detectRepoTooling correctly detects formatter/linter configs across all listed languages. Go gofmt special case works. Fail-open on filesystem errors. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add languageRules schema to config and update section fallback parsing</name>
  <files>
    src/execution/config.ts
    src/execution/config.test.ts
  </files>
  <action>
In `src/execution/config.ts`:

1. Add a `languageRulesSchema` Zod schema (above `repoConfigSchema`):
   ```
   const severityFloorOverrideSchema = z.object({
     pattern: z.string().min(1),
     language: z.string().optional(),
     minSeverity: z.enum(["critical", "major", "medium", "minor"]),
     skipTestFiles: z.boolean().default(true),
   });

   const toolingOverrideSchema = z.object({
     language: z.string(),
     suppressFormatting: z.boolean().default(true),
     suppressImportOrder: z.boolean().default(true),
     configFiles: z.array(z.string()).optional(),
   });

   const languageRulesSchema = z.object({
     severityFloors: z.array(severityFloorOverrideSchema).default([]),
     toolingOverrides: z.array(toolingOverrideSchema).default([]),
     disableBuiltinFloors: z.boolean().default(false),
   }).default({
     severityFloors: [],
     toolingOverrides: [],
     disableBuiltinFloors: false,
   });
   ```

2. Add `languageRules: languageRulesSchema` to `repoConfigSchema` (alongside review, write, mention, telemetry, knowledge).

3. Add the `languageRules` default to `repoConfigSchema`'s `.default({})` block:
   `languageRules: { severityFloors: [], toolingOverrides: [], disableBuiltinFloors: false }`

4. In the section-fallback parsing in `loadRepoConfig()`, add a `languageRules` section fallback block following the same pattern as `knowledge`, `telemetry`, etc.:
   ```
   const languageRulesResult = languageRulesSchema.safeParse(obj.languageRules);
   let languageRules: z.infer<typeof languageRulesSchema>;
   if (languageRulesResult.success) {
     languageRules = languageRulesResult.data;
   } else {
     languageRules = languageRulesSchema.parse({});
     warnings.push({ section: "languageRules", issues: ... });
   }
   ```

5. Add `languageRules` to the assembled `config` object at the bottom of the fallback path.

In `src/execution/config.test.ts`, add tests:
- Default config has `languageRules` with empty severityFloors, empty toolingOverrides, disableBuiltinFloors=false
- Valid languageRules with custom severityFloors parses correctly
- Valid languageRules with toolingOverrides parses correctly
- Invalid languageRules falls back to defaults with warning (section fallback)
- languageRules.disableBuiltinFloors=true parses correctly
- Unknown languages in toolingOverrides parse without error (free-form string)
  </action>
  <verify>
`cd /home/keith/src/kodiai && bun test src/execution/config.test.ts` passes all tests (existing + new).
  </verify>
  <done>
languageRules schema added to repoConfigSchema. Section fallback parsing handles malformed languageRules gracefully. Default config includes empty languageRules. All config tests pass including new languageRules tests.
  </done>
</task>

</tasks>

<verification>
1. `bun test src/enforcement/tooling-detection.test.ts` -- all tooling detection tests pass
2. `bun test src/execution/config.test.ts` -- all config tests pass (existing + new)
3. `bunx tsc --noEmit` -- no TypeScript compilation errors
4. Types in `src/enforcement/types.ts` are importable by other modules
</verification>

<success_criteria>
- DetectedTooling type and detectRepoTooling function exist and are tested
- SeverityPattern, EnforcedFinding, LanguageRulesConfig types are exported
- .kodiai.yml can include a languageRules section that validates or falls back gracefully
- Go gofmt special case is handled (go.mod -> formatter detected)
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/39-language-aware-enforcement/39-01-SUMMARY.md`
</output>
