---
phase: 39-language-aware-enforcement
plan: 04
type: execute
wave: 3
depends_on: ["39-01", "39-02", "39-03"]
files_modified:
  - src/enforcement/index.ts
  - src/handlers/review.ts
  - src/handlers/review.test.ts
autonomous: true

must_haves:
  truths:
    - "Enforcement pipeline runs between finding extraction and existing suppression matching in review.ts"
    - "Tooling suppression marks findings as toolingSuppressed, which are then treated as suppressed in the existing pipeline"
    - "Severity floor elevation modifies finding.severity before suppression matching and confidence computation"
    - "Enforcement operates fail-open: any error in enforcement logs a warning and returns findings unchanged"
    - "Existing review pipeline behavior is preserved -- enforcement is additive, not replacement"
    - "Enforcement metadata (originalSeverity, enforcementPatternId, toolingSuppressed) flows to knowledge store"
  artifacts:
    - path: "src/enforcement/index.ts"
      provides: "Public API barrel export for enforcement module"
      exports: ["applyEnforcement", "detectRepoTooling", "enforceSeverityFloors", "suppressToolingFindings"]
    - path: "src/handlers/review.ts"
      provides: "Updated review pipeline with enforcement integration"
      contains: "applyEnforcement"
    - path: "src/handlers/review.test.ts"
      provides: "Updated tests verifying enforcement integration"
  key_links:
    - from: "src/enforcement/index.ts"
      to: "src/enforcement/tooling-detection.ts"
      via: "re-exports detectRepoTooling"
      pattern: "export.*from.*tooling-detection"
    - from: "src/enforcement/index.ts"
      to: "src/enforcement/severity-floors.ts"
      via: "re-exports enforceSeverityFloors"
      pattern: "export.*from.*severity-floors"
    - from: "src/enforcement/index.ts"
      to: "src/enforcement/tooling-suppression.ts"
      via: "re-exports suppressToolingFindings"
      pattern: "export.*from.*tooling-suppression"
    - from: "src/handlers/review.ts"
      to: "src/enforcement/index.ts"
      via: "imports and calls applyEnforcement in review pipeline"
      pattern: "import.*applyEnforcement.*from.*enforcement"
---

<objective>
Wire the enforcement module into the review pipeline and create the barrel export, completing the language-aware enforcement feature.

Purpose: Connect all enforcement components (tooling detection, tooling suppression, severity floors) into the live review handler so that published reviews actually enforce language-specific rules. This is the final integration that makes the phase success criteria observable.

Output: `src/enforcement/index.ts` barrel export, updated `src/handlers/review.ts` with enforcement pipeline integration.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/39-language-aware-enforcement/39-CONTEXT.md
@.planning/phases/39-language-aware-enforcement/39-RESEARCH.md
@.planning/phases/39-language-aware-enforcement/39-01-SUMMARY.md
@.planning/phases/39-language-aware-enforcement/39-02-SUMMARY.md
@.planning/phases/39-language-aware-enforcement/39-03-SUMMARY.md
@src/enforcement/types.ts
@src/enforcement/tooling-detection.ts
@src/enforcement/severity-floors.ts
@src/enforcement/tooling-suppression.ts
@src/handlers/review.ts
@src/handlers/review.test.ts
@src/execution/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create enforcement barrel export with convenience wrapper</name>
  <files>src/enforcement/index.ts</files>
  <action>
Create `src/enforcement/index.ts` as the public API for the enforcement module:

1. Re-export all types from `./types.ts`
2. Re-export `detectRepoTooling`, `FORMATTER_CONFIGS`, `LINTER_CONFIGS` from `./tooling-detection.ts`
3. Re-export `enforceSeverityFloors`, `BUILTIN_SEVERITY_PATTERNS`, `matchesPattern`, `severityRank` from `./severity-floors.ts`
4. Re-export `suppressToolingFindings`, `FORMATTING_KEYWORDS`, `IMPORT_ORDER_KEYWORDS` from `./tooling-suppression.ts`

5. Create a convenience function `applyEnforcement` that orchestrates the full pipeline:
   ```typescript
   export async function applyEnforcement(params: {
     findings: ExtractedFinding[];   // use the shape from review.ts extractFindingsFromReviewComments
     workspaceDir: string;
     filesByCategory: Record<string, string[]>;
     filesByLanguage: Record<string, string[]>;
     languageRules?: LanguageRulesConfig;
     logger?: { warn: (obj: unknown, msg: string) => void };
   }): Promise<EnforcedFinding[]> {
     try {
       // Step 1: Detect repo tooling (filesystem scan)
       const detectedTooling = await detectRepoTooling(params.workspaceDir);

       // Step 2: Suppress tooling-covered findings
       const afterTooling = suppressToolingFindings({
         findings: params.findings,
         detectedTooling,
         languageRules: params.languageRules,
       });

       // Step 3: Enforce severity floors
       const enforced = enforceSeverityFloors({
         findings: afterTooling,
         filesByCategory: params.filesByCategory,
         filesByLanguage: params.filesByLanguage,
         languageRules: params.languageRules,
       });

       return enforced;
     } catch (err) {
       // Fail-open: log warning, return findings unchanged with default metadata
       params.logger?.warn(
         { err },
         "Enforcement pipeline failed (fail-open, returning findings unchanged)",
       );
       return params.findings.map(f => ({
         ...f,
         originalSeverity: f.severity,
         severityElevated: false,
         toolingSuppressed: false,
       }));
     }
   }
   ```

The function type signatures should accept a generic finding type that has at minimum `filePath`, `title`, `severity`, `category` fields -- the same shape as ExtractedFinding from review.ts. Use a type parameter or intersection to stay compatible with the existing finding types without creating a hard dependency on review.ts types.
  </action>
  <verify>
`bunx tsc --noEmit src/enforcement/index.ts` has no TypeScript errors.
Imports resolve correctly.
  </verify>
  <done>
index.ts exports all enforcement functions. applyEnforcement convenience function orchestrates detect -> suppress -> enforce in correct order. Fail-open error handling wraps entire pipeline.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate enforcement pipeline into review handler</name>
  <files>
    src/handlers/review.ts
    src/handlers/review.test.ts
  </files>
  <action>
In `src/handlers/review.ts`:

1. Add import: `import { applyEnforcement } from "../enforcement/index.ts";`

2. Find the section after `extractFindingsFromReviewComments` call (around line 1271-1281) and before the `processedFindings` mapping (around line 1284). Insert the enforcement pipeline call:

   ```typescript
   // Language-aware enforcement (LANG-01 through LANG-10)
   // Runs between finding extraction and existing suppression matching.
   // Fail-open: errors log warning and return findings unchanged.
   const enforcedFindings = await applyEnforcement({
     findings: extractedFindings,
     workspaceDir: workspace.dir,
     filesByCategory: diffAnalysis?.filesByCategory ?? {},
     filesByLanguage: diffAnalysis?.filesByLanguage ?? {},
     languageRules: config.languageRules,
     logger,
   });
   ```

3. Update the `processedFindings` mapping to use `enforcedFindings` instead of `extractedFindings`:
   - Change `extractedFindings.map((finding) => {` to `enforcedFindings.map((finding) => {`
   - In the `suppressed` calculation, add `finding.toolingSuppressed` to the OR chain:
     `const suppressed = finding.toolingSuppressed || Boolean(matchedSuppression) || dedupSuppressed;`
   - The severity field on each finding is already potentially elevated by enforcement, so the existing confidence computation and severity-based filtering will use the enforced severity automatically.

4. Add enforcement metadata to the finding records that flow to the knowledge store. In the `recordFindings` call (search for where FindingRecord[] is built), ensure `originalSeverity` is included if it differs from `severity`. This may require adding an optional `originalSeverity` field to the FindingRecord type in knowledge/types.ts -- but only if the knowledge store schema supports it. If the schema is rigid, skip this and just let the elevated severity flow through (the knowledge store records the final severity, which is the correct behavior per research recommendation).

5. Add a log line after enforcement to capture enforcement stats:
   ```typescript
   const toolingSuppressedCount = enforcedFindings.filter(f => f.toolingSuppressed).length;
   const severityElevatedCount = enforcedFindings.filter(f => f.severityElevated).length;
   if (toolingSuppressedCount > 0 || severityElevatedCount > 0) {
     logger.info(
       { ...baseLog, toolingSuppressedCount, severityElevatedCount },
       "Language enforcement applied",
     );
   }
   ```

In `src/handlers/review.test.ts`:

Add integration tests verifying:
- The review handler calls applyEnforcement when findings are extracted
- toolingSuppressed findings are treated as suppressed (filtered out of visible findings)
- Severity-elevated findings have their enforced severity in the final output
- Enforcement errors do not crash the review handler (fail-open)
- When no findings exist (conclusion !== "success"), enforcement is skipped

Note: The review handler tests use mocking extensively. Mock `applyEnforcement` or the individual enforcement functions as needed to verify integration without testing the enforcement logic itself (that's covered in Plans 02 and 03).
  </action>
  <verify>
`cd /home/keith/src/kodiai && bun test src/handlers/review.test.ts` passes all tests (existing + new).
`cd /home/keith/src/kodiai && bun test` passes ALL project tests.
  </verify>
  <done>
Enforcement pipeline integrated into review.ts between finding extraction and suppression matching. toolingSuppressed findings are filtered from visible output. Severity-elevated findings use enforced severity. Fail-open error handling prevents enforcement failures from blocking reviews. All existing tests continue to pass. Full test suite green.
  </done>
</task>

</tasks>

<verification>
1. `bun test` -- full test suite passes (all ~460+ tests)
2. `bun test src/enforcement/` -- all enforcement module tests pass
3. `bun test src/handlers/review.test.ts` -- review handler tests pass with enforcement integration
4. `bun test src/execution/config.test.ts` -- config tests pass with languageRules
5. `bunx tsc --noEmit` -- no TypeScript compilation errors
6. Pipeline ordering verified: extract -> enforce (detect tooling -> suppress -> floor) -> existing suppression -> confidence -> filter
</verification>

<success_criteria>
- Enforcement runs in the correct position in the review pipeline (after extraction, before suppression)
- toolingSuppressed findings are excluded from visible review output
- Severity-elevated findings appear at their enforced severity in published reviews
- Enforcement is fail-open (errors logged, review continues)
- Full test suite remains green
- No changes to existing behavior for repos without tooling config or matching patterns
</success_criteria>

<output>
After completion, create `.planning/phases/39-language-aware-enforcement/39-04-SUMMARY.md`
</output>
