---
phase: 39-language-aware-enforcement
plan: 02
type: tdd
wave: 2
depends_on: ["39-01"]
files_modified:
  - src/enforcement/severity-floors.ts
  - src/enforcement/severity-floors.test.ts
autonomous: true

must_haves:
  truths:
    - "C++ null dereference findings are elevated to CRITICAL in production files"
    - "C++ uninitialized member findings are elevated to CRITICAL in production files"
    - "Go unchecked error findings are elevated to MAJOR in production files"
    - "Python bare except findings are elevated to MAJOR in production files"
    - "Severity floors are relaxed in test files per context-aware enforcement decision"
    - "Findings already at or above the floor severity are not modified"
    - "User-defined severity floor patterns from .kodiai.yml are applied"
    - "disableBuiltinFloors=true uses only user-defined patterns"
    - "Pattern matching uses keyword-set approach (OR of AND groups) for robustness against LLM output variation"
  artifacts:
    - path: "src/enforcement/severity-floors.ts"
      provides: "enforceSeverityFloors function and BUILTIN_SEVERITY_PATTERNS catalog"
      exports: ["enforceSeverityFloors", "BUILTIN_SEVERITY_PATTERNS", "matchesPattern", "severityRank"]
    - path: "src/enforcement/severity-floors.test.ts"
      provides: "Comprehensive tests for severity floor enforcement"
  key_links:
    - from: "src/enforcement/severity-floors.ts"
      to: "src/enforcement/types.ts"
      via: "imports SeverityPattern, EnforcedFinding, LanguageRulesConfig"
      pattern: "import.*SeverityPattern.*from.*types"
    - from: "src/enforcement/severity-floors.ts"
      to: "src/execution/diff-analysis.ts"
      via: "imports classifyFileLanguage for per-file language detection"
      pattern: "import.*classifyFileLanguage.*from.*diff-analysis"
---

<objective>
Implement severity floor enforcement with a built-in pattern catalog seeded from requirements and kodiai PR history analysis.

Purpose: Guarantee that safety-critical findings (C++ null deref, Go unchecked errors, Python bare excepts, etc.) appear at appropriate severity regardless of LLM judgment. Context-aware enforcement relaxes floors in test files per user decision.

Output: `src/enforcement/severity-floors.ts` with `enforceSeverityFloors()` pure function and `BUILTIN_SEVERITY_PATTERNS` catalog, fully tested via TDD.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/39-language-aware-enforcement/39-CONTEXT.md
@.planning/phases/39-language-aware-enforcement/39-RESEARCH.md
@.planning/phases/39-language-aware-enforcement/39-01-SUMMARY.md
@src/enforcement/types.ts
@src/knowledge/types.ts
@src/execution/diff-analysis.ts
@src/knowledge/confidence.ts
</context>

<feature>
  <name>Severity Floor Enforcement</name>
  <files>src/enforcement/severity-floors.ts, src/enforcement/severity-floors.test.ts</files>
  <behavior>
Pure function: `enforceSeverityFloors(params) -> EnforcedFinding[]`

Params:
- `findings`: Array of finding objects with `{ filePath, title, severity, category, ... }`
- `filesByCategory`: Record with `test` key containing array of test file paths
- `filesByLanguage`: Record mapping language names to file paths
- `languageRules?`: Optional LanguageRulesConfig from .kodiai.yml

Behavior cases:

1. **C++ null deref finding with MINOR severity in production file**
   Input: `{ filePath: "src/parser.cpp", title: "Potential null pointer dereference", severity: "minor", category: "correctness" }`
   Expected: `{ ...finding, severity: "critical", originalSeverity: "minor", severityElevated: true, enforcementPatternId: "cpp-null-deref" }`

2. **C++ null deref finding in test file**
   Input: `{ filePath: "tests/parser.test.cpp", title: "Potential null pointer dereference", severity: "minor" }`, filesByCategory.test includes the file
   Expected: `{ ...finding, severity: "minor", severityElevated: false }` (relaxed in test)

3. **Go unchecked error finding in production file**
   Input: `{ filePath: "handlers/auth.go", title: "Error return value ignored", severity: "minor" }`
   Expected: `{ ...finding, severity: "major", originalSeverity: "minor", severityElevated: true, enforcementPatternId: "go-unchecked-error" }`

4. **Python bare except finding**
   Input: `{ filePath: "utils/parser.py", title: "Bare except clause catches all exceptions", severity: "medium" }`
   Expected: `{ ...finding, severity: "major", originalSeverity: "medium", severityElevated: true, enforcementPatternId: "python-bare-except" }`

5. **Finding already at CRITICAL (above floor)**
   Input: `{ filePath: "src/main.cpp", title: "Null pointer access", severity: "critical" }`
   Expected: `{ ...finding, severity: "critical", severityElevated: false }` (no change)

6. **User-defined pattern from config**
   Input with languageRules.severityFloors including `{ pattern: "unvalidated input", language: "TypeScript", minSeverity: "major" }`
   Finding: `{ filePath: "src/api.ts", title: "Unvalidated input passed to database query", severity: "minor" }`
   Expected: severity elevated to "major"

7. **disableBuiltinFloors=true**
   Input with languageRules.disableBuiltinFloors=true
   Finding matching a built-in pattern should NOT be elevated (only user-defined patterns apply)

8. **Unmatched finding passes through unchanged**
   Input: `{ filePath: "src/app.ts", title: "Consider using const instead of let", severity: "minor" }`
   Expected: `{ ...finding, severityElevated: false, toolingSuppressed: false }` (no pattern match)

9. **Keyword matching variations (LLM output robustness)**
   All of these should match the cpp-null-deref pattern:
   - "Potential null dereference in handler"
   - "NPE when user is null"
   - "Null pointer access before check"
   - "Missing nullptr check"

  Built-in pattern catalog (from research PR history analysis):
  - cpp-null-deref: C++, keywords [["null","dereference"],["null","pointer"],["nullptr"],["npe"]], CRITICAL
  - cpp-uninitialized: C++, keywords [["uninitialized","member"],["uninitialized","variable"],["uninitialized","field"]], CRITICAL
  - go-unchecked-error: Go, keywords [["unchecked","error"],["error","ignored"],["error","discarded"],["error","not checked"]], MAJOR
  - python-bare-except: Python, keywords [["bare","except"],["bare","exception"],["catch-all","exception"],["except:",""]], MAJOR
  - c-null-deref: C, keywords [["null","dereference"],["null","pointer"]], CRITICAL
  - c-buffer-overflow: C, keywords [["buffer","overflow"],["buffer","overrun"],["strcpy"],["sprintf"]], CRITICAL
  - rust-unwrap: Rust, keywords [["unwrap","panic"],["unwrap","crash"],["unwrap()","error"]], MAJOR
  - java-unclosed-resource: Java, keywords [["unclosed","resource"],["resource","leak"],["missing","close"]], MAJOR
  - sql-injection: (any language), keywords [["sql","injection"],["sql","concatenation"]], CRITICAL
  - ts-unhandled-promise: TypeScript, keywords [["unhandled","promise"],["floating","promise"],["missing","await"]], MAJOR
  </behavior>
  <implementation>
1. Export `matchesPattern(findingTitle: string, keywords: string[][]): boolean` -- normalize to lowercase, check OR-of-AND keyword groups.

2. Export `severityRank(severity: FindingSeverity): number` -- minor=0, medium=1, major=2, critical=3.

3. Export `BUILTIN_SEVERITY_PATTERNS: SeverityPattern[]` -- the 10 patterns listed above. All have `contextRelaxation: { testFiles: true }` except sql-injection which should enforce even in test files (`testFiles: false`).

4. Export `enforceSeverityFloors(params): EnforcedFinding[]`:
   - Build test file set from `filesByCategory.test ?? []`
   - Merge patterns: if `languageRules?.disableBuiltinFloors` then use only user patterns, else concat built-in + user patterns
   - For each finding:
     a. Detect language via `classifyFileLanguage(finding.filePath)` from diff-analysis.ts
     b. Find first matching pattern (language filter + keyword match + optional category filter)
     c. If no match: return finding with `severityElevated: false, originalSeverity: finding.severity, toolingSuppressed: false`
     d. If match and test file and pattern.contextRelaxation.testFiles: skip enforcement (or apply relaxedSeverity if set)
     e. If match and current severity >= floor: return unchanged (already meets floor)
     f. If match and current severity < floor: elevate to floor severity, set metadata fields
  </implementation>
</feature>

<verification>
1. `bun test src/enforcement/severity-floors.test.ts` -- all tests pass
2. RED phase: tests written first, must fail before implementation
3. GREEN phase: minimal implementation makes all tests pass
4. Pattern catalog includes all 10 built-in patterns from research
5. Context-aware enforcement: test files get relaxed floors per user decision
</verification>

<success_criteria>
- All 10 built-in severity patterns defined and tested
- enforceSeverityFloors correctly elevates findings below floor in production files
- Test files get context relaxation (no elevation or reduced elevation)
- User-defined patterns from languageRules config are applied
- disableBuiltinFloors=true disables only built-in patterns
- Keyword matching handles LLM output variation (multiple phrasings for same issue)
- Pure function with no side effects, fully testable
</success_criteria>

<output>
After completion, create `.planning/phases/39-language-aware-enforcement/39-02-SUMMARY.md`
</output>
