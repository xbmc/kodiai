---
phase: 86-postgresql-pgvector-on-azure
plan: 02
type: execute
wave: 2
depends_on:
  - 86-01
files_modified:
  - src/knowledge/store.ts
  - src/knowledge/store.test.ts
  - src/knowledge/db-path.ts
  - src/knowledge/db-path.test.ts
  - src/telemetry/store.ts
  - src/telemetry/store.test.ts
autonomous: true
requirements:
  - DB-04
  - DB-05

must_haves:
  truths:
    - "KnowledgeStore uses postgres.js for all queries instead of bun:sqlite"
    - "TelemetryStore uses postgres.js for all queries instead of bun:sqlite"
    - "All KnowledgeStore methods return identical types/shapes as the SQLite version"
    - "All TelemetryStore methods return identical types/shapes as the SQLite version"
    - "No bun:sqlite or sqlite-vec imports remain in knowledge/ or telemetry/ directories"
    - "db-path module is replaced with DATABASE_URL-based connection"
    - "Existing tests pass against Docker Compose PostgreSQL"
  artifacts:
    - path: "src/knowledge/store.ts"
      provides: "PostgreSQL-backed KnowledgeStore"
      exports: ["createKnowledgeStore"]
    - path: "src/telemetry/store.ts"
      provides: "PostgreSQL-backed TelemetryStore"
      exports: ["createTelemetryStore"]
  key_links:
    - from: "src/knowledge/store.ts"
      to: "src/db/client.ts"
      via: "accepts sql instance from client module"
      pattern: "import.*sql.*from.*db/client"
    - from: "src/telemetry/store.ts"
      to: "src/db/client.ts"
      via: "accepts sql instance from client module"
      pattern: "import.*sql.*from.*db/client"
---

<objective>
Port the KnowledgeStore and TelemetryStore from bun:sqlite to postgres.js. Both stores keep their existing interface (KnowledgeStore type, TelemetryStore type) but use PostgreSQL queries internally.

Purpose: Replace the two largest SQLite consumers with PostgreSQL. The stores accept a postgres.js `sql` instance via dependency injection, replacing the `Database` parameter.

Output: Rewritten store.ts files for knowledge/ and telemetry/, updated tests, removed db-path module.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/86-postgresql-pgvector-on-azure/86-01-SUMMARY.md
@src/knowledge/types.ts
@src/knowledge/store.ts
@src/telemetry/types.ts
@src/telemetry/store.ts
@src/db/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite KnowledgeStore to use postgres.js</name>
  <files>
    src/knowledge/store.ts
    src/knowledge/store.test.ts
    src/knowledge/db-path.ts
    src/knowledge/db-path.test.ts
  </files>
  <action>
1. **Rewrite `src/knowledge/store.ts`**:
   - Change the factory signature: `createKnowledgeStore(opts: { sql: Sql; logger: Logger }): KnowledgeStore` where `Sql` is the postgres.js type from `src/db/client.ts`
   - Remove ALL `import { Database } from "bun:sqlite"` and `import { mkdirSync }` / `import { dirname }` references
   - Remove ALL table creation DDL (schema now lives in migrations)
   - Remove `ensureTableColumn`, `hasTableColumn` helpers (no longer needed -- schema is migration-managed)
   - Remove `PRAGMA` calls (connection config is in client.ts)

   **Query translation patterns** (apply systematically to every query):
   - SQLite `$paramName` binding -> postgres.js tagged template `${value}` interpolation
   - `db.query(sql).get(params)` -> `const [row] = await sql\`SELECT ... WHERE col = ${value}\``
   - `db.query(sql).all(params)` -> `const rows = await sql\`SELECT ... WHERE col = ${value}\``
   - `db.run(sql)` -> `await sql\`...\``
   - `RETURNING id` works the same in PostgreSQL
   - `datetime('now')` -> `now()`
   - `datetime('now', '-X days')` -> `now() - interval '${days} days'` (use `sql.unsafe` or parameterize the interval)
   - `strftime('%Y-%m-%d', created_at)` -> `date_trunc('day', created_at)::date::text` or `to_char(created_at, 'YYYY-MM-DD')`
   - `INSERT OR IGNORE` -> `INSERT ... ON CONFLICT DO NOTHING`
   - `INTEGER` booleans (0/1) -> native `BOOLEAN` (true/false)
   - Prepared statements (`.query()`, `.prepare()`) are replaced by postgres.js tagged templates which are automatically prepared

   **Transaction translation:**
   - `db.transaction((params) => { ... })` -> `await sql.begin(async (tx) => { ... })`
   - The `checkAndClaimRunTxn` must become an `async` function using `sql.begin()`
   - The `insertFindingsTxn`, `insertSuppressionTxn`, `insertFeedbackReactionTxn` batch inserts should use `sql.begin()` with loops inside

   **All store methods must become `async`** since postgres.js is async. Update the `KnowledgeStore` type in `src/knowledge/types.ts` to make all methods return `Promise<...>` instead of synchronous values. Methods that currently return `void` become `Promise<void>`, methods returning `number` become `Promise<number>`, etc.

   **Important:** The `checkpoint()` method should become a no-op (PostgreSQL has no WAL checkpoint equivalent needed). The `close()` method should be a no-op (connection lifecycle managed by client.ts).

2. **Update `src/knowledge/db-path.ts`**:
   - Simplify to just export `getConnectionString(): string` that reads `DATABASE_URL` from env
   - Remove all SQLite file path logic
   - Or delete entirely if the client.ts module handles this (prefer deletion, update imports in index.ts)

3. **Update `src/knowledge/store.test.ts`**:
   - Tests must connect to Docker Compose PostgreSQL (use `DATABASE_URL=postgresql://kodiai:kodiai@localhost:5432/kodiai`)
   - Run migrations before tests via `runMigrations(sql)`
   - Use `sql.begin()` for test isolation (wrap each test in a transaction that rolls back)
   - Or use a `TRUNCATE` approach between tests
   - All assertions remain the same -- the store interface is unchanged

4. **Update or delete `src/knowledge/db-path.test.ts`** accordingly.

**Critical:** Do NOT change `src/knowledge/types.ts` beyond making methods async. The return types (RepoStats, TrendData, RunStateCheck, etc.) must remain identical.
  </action>
  <verify>
`docker compose up -d && DATABASE_URL=postgresql://kodiai:kodiai@localhost:5432/kodiai bun test src/knowledge/` passes. `bunx tsc --noEmit` passes. `grep -r "bun:sqlite" src/knowledge/` returns no matches.
  </verify>
  <done>
KnowledgeStore uses postgres.js for all operations. All existing store methods work with identical return types. Tests pass against Docker Compose PostgreSQL. No SQLite imports in src/knowledge/.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite TelemetryStore to use postgres.js</name>
  <files>
    src/telemetry/store.ts
    src/telemetry/store.test.ts
  </files>
  <action>
1. **Rewrite `src/telemetry/store.ts`**:
   - Change factory signature: `createTelemetryStore(opts: { sql: Sql; logger: Logger; rateLimitFailureInjectionIdentities?: string[] }): TelemetryStore`
   - Remove `import { Database } from "bun:sqlite"` and all SQLite-specific code
   - Remove ALL table creation DDL (schema now in migrations)
   - Remove `PRAGMA` calls and `hasTableColumn` helper

   Apply the same query translation patterns as Task 1:
   - All prepared statements -> postgres.js tagged templates
   - `datetime('now', '-X days')` -> `now() - interval '...'`
   - `INSERT OR IGNORE` -> `ON CONFLICT DO NOTHING`
   - Positional `?1`, `?2` bindings -> `${value}` interpolation

   **Make all methods async.** Update `TelemetryStore` type in `src/telemetry/types.ts` to use `Promise<...>` return types.

   **The telemetry store's `checkpoint()` method** becomes a no-op. `close()` becomes a no-op.

   **The `purgeOlderThan(days)` method:** translate `DELETE FROM ... WHERE created_at < datetime('now', ?)` to `DELETE FROM ... WHERE created_at < now() - interval '${days} days'`.

2. **Update `src/telemetry/store.test.ts`**:
   - Same pattern as knowledge store tests: connect to Docker Compose PostgreSQL
   - Run migrations before tests
   - Test isolation via TRUNCATE or transaction rollback
   - All assertions remain the same

**Critical:** Preserve the rate-limit failure injection logic exactly as-is (just translated to async postgres.js calls). The `rateLimitFailureInjectionIdentities` Set behavior must not change.
  </action>
  <verify>
`DATABASE_URL=postgresql://kodiai:kodiai@localhost:5432/kodiai bun test src/telemetry/` passes. `bunx tsc --noEmit` passes. `grep -r "bun:sqlite" src/telemetry/` returns no matches.
  </verify>
  <done>
TelemetryStore uses postgres.js for all operations. Rate-limit injection logic preserved. Tests pass against Docker Compose PostgreSQL. No SQLite imports in src/telemetry/.
  </done>
</task>

</tasks>

<verification>
1. `grep -r "bun:sqlite" src/knowledge/ src/telemetry/` returns zero matches
2. `DATABASE_URL=postgresql://kodiai:kodiai@localhost:5432/kodiai bun test src/knowledge/ src/telemetry/` all pass
3. `bunx tsc --noEmit` passes
4. KnowledgeStore and TelemetryStore interfaces unchanged (methods now async but return same types)
</verification>

<success_criteria>
- KnowledgeStore fully ported to postgres.js with all 20+ methods working
- TelemetryStore fully ported to postgres.js with all methods working
- No bun:sqlite imports in knowledge/ or telemetry/ directories
- All existing tests pass against PostgreSQL
- Type interfaces preserved (only async wrapper added)
</success_criteria>

<output>
After completion, create `.planning/phases/86-postgresql-pgvector-on-azure/86-02-SUMMARY.md`
</output>
