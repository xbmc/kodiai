---
title: "99-01: DB Migration, App Config Extension, Slack standalone message"
phase: 99
plan: 1
wave: 1
depends_on: []
files_modified:
  - src/db/migrations/012-wiki-staleness-run-state.sql
  - src/config.ts
  - src/slack/client.ts
  - src/slack/client.test.ts
autonomous: true
requirements:
  - WIKI-01
  - WIKI-03
  - WIKI-04
---

# Plan 99-01: Foundation — DB Migration, Config, Slack Extension

## Goal

Lay the infrastructure foundation for wiki staleness detection:
1. Add `wiki_staleness_run_state` DB table to track scan windows and prevent duplicate scans
2. Extend app-level `config.ts` with wiki-related env vars (`SLACK_WIKI_CHANNEL_ID`, `WIKI_STALENESS_THRESHOLD_DAYS`, `WIKI_GITHUB_OWNER`, `WIKI_GITHUB_REPO`)
3. Add `postStandaloneMessage()` to `SlackClient` — required for posting the top-level summary message to `#ai-wiki` that thread replies attach to

## Context

- Migration 011 (`011-contributor-profiles.sql`) is the current latest. Next migration is 012.
- App config lives in `src/config.ts` with a flat zod schema; wiki config goes here (not in `.kodiai.yml`) because staleness is global, not per-repo. See RESEARCH.md Pitfall 1.
- `SlackClient` in `src/slack/client.ts` has `postThreadMessage()` which posts with `thread_ts`; we need `postStandaloneMessage()` that posts without `thread_ts` and returns `{ ts: string }` for threading. See RESEARCH.md Pitfall 4.

## Tasks

<task id="99-01-A" wave="1">
### Create DB migration 012: wiki_staleness_run_state table

**File:** `src/db/migrations/012-wiki-staleness-run-state.sql`

Create this file with the following SQL exactly:

```sql
-- Migration 012: Wiki staleness run state tracking
-- Tracks scan window anchor and run status to prevent duplicate scans and enable gap-free scanning.

CREATE TABLE wiki_staleness_run_state (
  id              SERIAL PRIMARY KEY,
  last_run_at     TIMESTAMPTZ,
  last_commit_sha TEXT,
  pages_flagged   INTEGER NOT NULL DEFAULT 0,
  pages_evaluated INTEGER NOT NULL DEFAULT 0,
  status          TEXT NOT NULL DEFAULT 'pending',
  error_message   TEXT,
  updated_at      TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Single-row table: always upsert into id=1.
-- status values: 'success' | 'failed' | 'pending'
```

No indexes needed — single-row table.
</task>

<task id="99-01-B" wave="1">
### Extend src/config.ts with wiki env vars

**File:** `src/config.ts`

Add four new optional fields to the `configSchema` zod object (after `botAllowList`):

```typescript
slackWikiChannelId: z.string().default(""),
wikiStalenessThresholdDays: z.coerce.number().min(1).max(365).default(30),
wikiGithubOwner: z.string().default("xbmc"),
wikiGithubRepo: z.string().default("xbmc"),
```

And add four corresponding entries in the `configSchema.safeParse({...})` call in `loadConfig()`:

```typescript
slackWikiChannelId: process.env.SLACK_WIKI_CHANNEL_ID,
wikiStalenessThresholdDays: process.env.WIKI_STALENESS_THRESHOLD_DAYS,
wikiGithubOwner: process.env.WIKI_GITHUB_OWNER,
wikiGithubRepo: process.env.WIKI_GITHUB_REPO,
```

`AppConfig` type is automatically updated via `z.infer<typeof configSchema>` — no manual type update needed.

**Validation:** All four fields have defaults so they are never required at startup; no `process.exit(1)` calls needed.
</task>

<task id="99-01-C" wave="1">
### Add postStandaloneMessage to SlackClient

**Files:** `src/slack/client.ts`, `src/slack/client.test.ts`

#### src/slack/client.ts changes:

1. Add `SlackStandaloneMessageInput` interface after `SlackThreadPublishInput`:

```typescript
export interface SlackStandaloneMessageInput {
  channel: string;
  text: string;
}
```

2. Add `postStandaloneMessage` to the `SlackClient` interface:

```typescript
postStandaloneMessage(input: SlackStandaloneMessageInput): Promise<{ ts: string }>;
```

3. Implement `postStandaloneMessage` in `createSlackClient()` return object. Model it on `postThreadMessage` but:
   - Do NOT include `thread_ts` in the request body
   - Parse the response JSON to extract `message.ts` (the parent message timestamp)
   - Return `{ ts: responseBody.ts as string }` where `responseBody` is the full Slack API JSON response

   The Slack `chat.postMessage` response has shape `{ ok: true, ts: "...", channel: "...", message: {...} }`. The `ts` field at the top level is the message timestamp. Use this.

   Full implementation:

```typescript
async postStandaloneMessage(input: SlackStandaloneMessageInput): Promise<{ ts: string }> {
  const response = await fetchImpl("https://slack.com/api/chat.postMessage", {
    method: "POST",
    headers: {
      authorization: `Bearer ${input.botToken}`,
      "content-type": "application/json; charset=utf-8",
    },
    body: JSON.stringify({
      channel: input.channel,
      text: input.text,
    }),
    signal: AbortSignal.timeout(timeoutMs),
  });

  if (!response.ok) {
    throw new Error(`Slack API chat.postMessage request failed: ${response.status}`);
  }

  const raw = await response.text();
  if (!raw.trim()) {
    throw new Error("Slack API chat.postMessage returned empty response body");
  }

  let parsed: SlackApiResponse & { ts?: string };
  try {
    parsed = JSON.parse(raw) as SlackApiResponse & { ts?: string };
  } catch {
    throw new Error(`Slack API chat.postMessage returned non-JSON response: ${raw.slice(0, 200)}`);
  }

  if (!parsed.ok) {
    throw new Error(`Slack API chat.postMessage failed: ${parsed.error ?? "unknown_error"}`);
  }

  if (!parsed.ts) {
    throw new Error("Slack API chat.postMessage response missing ts field");
  }

  return { ts: parsed.ts };
},
```

Note: `input.botToken` won't exist on `input` directly — use the captured `input` from `createSlackClient(input: CreateSlackClientInput)` closure. The parameter is named `input` in the outer scope but the method parameter is also named `input` — rename the method parameter to `messageInput` to avoid shadowing:

```typescript
async postStandaloneMessage(messageInput: SlackStandaloneMessageInput): Promise<{ ts: string }> {
  // use messageInput.channel, messageInput.text
  // use input.botToken from closure
```

#### src/slack/client.test.ts changes (or create if missing):

Find the existing test file or create it. Add a test for `postStandaloneMessage`:

```typescript
// Test: postStandaloneMessage returns ts from Slack API response
it("postStandaloneMessage returns ts from response", async () => {
  const fetchImpl = vi.fn().mockResolvedValue({
    ok: true,
    text: async () => JSON.stringify({ ok: true, ts: "1234567890.000100" }),
    headers: new Headers(),
  });

  const client = createSlackClient({ botToken: "xoxb-test", fetchImpl });
  const result = await client.postStandaloneMessage({
    channel: "C12345",
    text: "Wiki Staleness Report",
  });

  expect(result.ts).toBe("1234567890.000100");
  expect(fetchImpl).toHaveBeenCalledWith(
    "https://slack.com/api/chat.postMessage",
    expect.objectContaining({
      method: "POST",
      body: expect.stringContaining('"channel":"C12345"'),
    }),
  );
});
```

If `client.test.ts` already exists, add the test in the appropriate describe block.
</task>

## Verification

```
must_haves:
  - Migration file src/db/migrations/012-wiki-staleness-run-state.sql exists with wiki_staleness_run_state table CREATE
  - AppConfig type has slackWikiChannelId, wikiStalenessThresholdDays, wikiGithubOwner, wikiGithubRepo fields
  - SlackClient interface has postStandaloneMessage(input: SlackStandaloneMessageInput): Promise<{ ts: string }>
  - createSlackClient() implements postStandaloneMessage returning { ts } from Slack API response
  - Test for postStandaloneMessage passes
  - bun run typecheck passes (no TypeScript errors)
```
