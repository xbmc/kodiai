---
phase: 93-language-aware-retrieval-boosting
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/db/migrations/007-language-column.sql
  - src/db/migrations/007-language-column.down.sql
  - src/execution/diff-analysis.ts
  - src/execution/diff-analysis.test.ts
  - src/knowledge/types.ts
  - src/knowledge/memory-store.ts
  - src/knowledge/memory-store.test.ts
autonomous: true
requirements: [LANG-01, LANG-02]

must_haves:
  truths:
    - "learning_memories table has a nullable language TEXT column with an index"
    - "New learning memory records written via writeMemory() include the classified language"
    - "EXTENSION_LANGUAGE_MAP covers 30+ languages including comprehensive C/C++ and ambiguous extension handling"
    - "classifyFileLanguage resolves .h files using repository context when available"
  artifacts:
    - path: "src/db/migrations/007-language-column.sql"
      provides: "Schema migration adding language column to learning_memories and language_tags to wiki_pages"
      contains: "ALTER TABLE learning_memories ADD COLUMN"
    - path: "src/execution/diff-analysis.ts"
      provides: "Expanded language map and context-aware classification"
      contains: "RELATED_LANGUAGES"
    - path: "src/knowledge/memory-store.ts"
      provides: "Language column population on write"
      contains: "classifyFileLanguage"
  key_links:
    - from: "src/knowledge/memory-store.ts"
      to: "src/execution/diff-analysis.ts"
      via: "import classifyFileLanguage"
      pattern: "classifyFileLanguage"
    - from: "src/db/migrations/007-language-column.sql"
      to: "learning_memories"
      via: "ALTER TABLE"
      pattern: "ADD COLUMN.*language"
---

<objective>
Add language column to learning_memories, expand the language classification taxonomy to 30+ languages, add context-aware classification for ambiguous extensions, and populate the language column on new memory writes.

Purpose: Store programming language metadata at write time so retrieval can use it without runtime re-classification (LANG-01). Sets up schema for backfill (LANG-02).
Output: Migration 007, expanded classifyFileLanguage, updated writeMemory with language population.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
@/home/keith/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/93-language-aware-retrieval-boosting/93-CONTEXT.md
@.planning/phases/93-language-aware-retrieval-boosting/93-RESEARCH.md

@src/db/migrations/006-wiki-pages.sql
@src/execution/diff-analysis.ts
@src/knowledge/types.ts
@src/knowledge/memory-store.ts

<interfaces>
<!-- Key types the executor needs -->

From src/knowledge/types.ts:
```typescript
export type LearningMemoryRecord = {
  id?: number;
  repo: string;
  owner: string;
  findingId: number;
  reviewId: number;
  sourceRepo: string;
  findingText: string;
  severity: FindingSeverity;
  category: FindingCategory;
  filePath: string;
  outcome: MemoryOutcome;
  embeddingModel: string;
  embeddingDim: number;
  stale: boolean;
  createdAt?: string;
};

export type LearningMemoryStore = {
  writeMemory(record: LearningMemoryRecord, embedding: Float32Array): Promise<void>;
  // ... other methods
};
```

From src/execution/diff-analysis.ts:
```typescript
export const EXTENSION_LANGUAGE_MAP: Record<string, string> = { /* ~25 entries */ };
export function classifyFileLanguage(filePath: string): string;
export function classifyLanguages(files: string[]): Record<string, string[]>;
```

From src/knowledge/memory-store.ts:
```typescript
type MemoryRow = {
  id: number; repo: string; owner: string; finding_id: number; review_id: number;
  source_repo: string; finding_text: string; severity: string; category: string;
  file_path: string; outcome: string; embedding_model: string; embedding_dim: number;
  stale: boolean; created_at: string;
};
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration 007 — add language columns</name>
  <files>src/db/migrations/007-language-column.sql, src/db/migrations/007-language-column.down.sql</files>
  <action>
Create migration `007-language-column.sql`:

1. Add `language TEXT` nullable column to `learning_memories`:
```sql
ALTER TABLE learning_memories ADD COLUMN IF NOT EXISTS language TEXT;
CREATE INDEX IF NOT EXISTS idx_memories_language ON learning_memories(language);
```

2. Add `language_tags TEXT[] DEFAULT '{}'` to `wiki_pages`:
```sql
ALTER TABLE wiki_pages ADD COLUMN IF NOT EXISTS language_tags TEXT[] DEFAULT '{}';
CREATE INDEX IF NOT EXISTS idx_wiki_pages_language_tags ON wiki_pages USING gin(language_tags);
```

3. Backfill learning_memories from file_path using SQL CASE:
```sql
UPDATE learning_memories SET language = CASE
  WHEN language IS NOT NULL THEN language  -- idempotent: skip already-classified
  WHEN file_path LIKE '%.ts' OR file_path LIKE '%.tsx' OR file_path LIKE '%.mts' OR file_path LIKE '%.cts' THEN 'typescript'
  WHEN file_path LIKE '%.js' OR file_path LIKE '%.jsx' OR file_path LIKE '%.mjs' OR file_path LIKE '%.cjs' THEN 'javascript'
  WHEN file_path LIKE '%.py' OR file_path LIKE '%.pyw' THEN 'python'
  WHEN file_path LIKE '%.go' THEN 'go'
  WHEN file_path LIKE '%.rs' THEN 'rust'
  WHEN file_path LIKE '%.java' THEN 'java'
  WHEN file_path LIKE '%.kt' OR file_path LIKE '%.kts' THEN 'kotlin'
  WHEN file_path LIKE '%.swift' THEN 'swift'
  WHEN file_path LIKE '%.cs' THEN 'csharp'
  WHEN file_path LIKE '%.cpp' OR file_path LIKE '%.cc' OR file_path LIKE '%.cxx' OR file_path LIKE '%.hpp' OR file_path LIKE '%.hxx' THEN 'cpp'
  WHEN file_path LIKE '%.c' THEN 'c'
  WHEN file_path LIKE '%.h' THEN 'c'  -- default to C for .h in backfill; context-aware on new writes
  WHEN file_path LIKE '%.rb' THEN 'ruby'
  WHEN file_path LIKE '%.php' THEN 'php'
  WHEN file_path LIKE '%.scala' THEN 'scala'
  WHEN file_path LIKE '%.sh' OR file_path LIKE '%.bash' OR file_path LIKE '%.zsh' THEN 'shell'
  WHEN file_path LIKE '%.sql' THEN 'sql'
  WHEN file_path LIKE '%.dart' THEN 'dart'
  WHEN file_path LIKE '%.lua' THEN 'lua'
  WHEN file_path LIKE '%.ex' OR file_path LIKE '%.exs' THEN 'elixir'
  WHEN file_path LIKE '%.zig' THEN 'zig'
  WHEN file_path LIKE '%.r' OR file_path LIKE '%.R' THEN 'r'
  WHEN file_path LIKE '%.m' THEN 'objectivec'
  WHEN file_path LIKE '%.mm' THEN 'objectivecpp'
  WHEN file_path LIKE '%.pl' OR file_path LIKE '%.pm' THEN 'perl'
  WHEN file_path LIKE '%.clj' OR file_path LIKE '%.cljs' OR file_path LIKE '%.cljc' THEN 'clojure'
  WHEN file_path LIKE '%.erl' OR file_path LIKE '%.hrl' THEN 'erlang'
  WHEN file_path LIKE '%.hs' THEN 'haskell'
  WHEN file_path LIKE '%.ml' OR file_path LIKE '%.mli' THEN 'ocaml'
  WHEN file_path LIKE '%.fs' OR file_path LIKE '%.fsx' OR file_path LIKE '%.fsi' THEN 'fsharp'
  WHEN file_path LIKE '%.jl' THEN 'julia'
  WHEN file_path LIKE '%.groovy' OR file_path LIKE '%.gvy' THEN 'groovy'
  WHEN file_path LIKE '%.v' OR file_path LIKE '%.sv' THEN 'verilog'
  WHEN file_path LIKE '%.vhd' OR file_path LIKE '%.vhdl' THEN 'vhdl'
  WHEN file_path LIKE '%.cmake' THEN 'cmake'
  ELSE 'unknown'
END
WHERE language IS NULL;
```

Create `007-language-column.down.sql`:
```sql
ALTER TABLE learning_memories DROP COLUMN IF EXISTS language;
ALTER TABLE wiki_pages DROP COLUMN IF EXISTS language_tags;
DROP INDEX IF EXISTS idx_memories_language;
DROP INDEX IF EXISTS idx_wiki_pages_language_tags;
```

All language values stored lowercase for consistency.
  </action>
  <verify>
    <automated>cat src/db/migrations/007-language-column.sql | grep -c "ALTER TABLE" && echo "Migration has ALTER TABLE statements"</automated>
  </verify>
  <done>Migration 007 exists with language column for learning_memories, language_tags for wiki_pages, indexes, and backfill SQL</done>
</task>

<task type="auto">
  <name>Task 2: Expand EXTENSION_LANGUAGE_MAP and add context-aware classification</name>
  <files>src/execution/diff-analysis.ts, src/execution/diff-analysis.test.ts</files>
  <action>
TDD approach — write tests first, then implement.

**Tests to add in diff-analysis.test.ts:**

1. Test that EXTENSION_LANGUAGE_MAP covers 30+ extensions (count keys)
2. Test `classifyFileLanguage` for new extensions: `.r`, `.R`, `.m`, `.mm`, `.pl`, `.clj`, `.erl`, `.hs`, `.ml`, `.fs`, `.jl`, `.groovy`, `.v`, `.vhd`, `.cmake`
3. Test `classifyFileLanguageWithContext` (new function):
   - Given `.h` file with context `["foo.cpp", "bar.hpp"]` returns `"C++"`
   - Given `.h` file with context `["foo.c"]` returns `"C"`
   - Given `.h` file with NO context returns `"C"` (fallback)
   - Given `.h` file with mixed context `["foo.c", "bar.cpp"]` returns `"C++"` (C++ wins when both present — per CONTEXT.md: `.h` treated as C++ if PR contains `.cpp` files)
4. Test `RELATED_LANGUAGES` map:
   - `"c"` relates to `"cpp"` and vice versa
   - `"typescript"` relates to `"javascript"` and vice versa
   - `"objectivec"` relates to `"c"` and `"cpp"`

**Implementation:**

1. Expand `EXTENSION_LANGUAGE_MAP` to 30+ languages. Add entries for: `r`, `R`, `m`, `mm`, `pl`, `pm`, `clj`, `cljs`, `cljc`, `erl`, `hrl`, `hs`, `ml`, `mli`, `fs`, `fsx`, `fsi`, `jl`, `groovy`, `gvy`, `v`, `sv`, `vhd`, `vhdl`, `cmake`. Store values in **lowercase** (e.g., `"typescript"` not `"TypeScript"`) for consistency with DB storage. Update existing entries to lowercase too.

2. Export `RELATED_LANGUAGES: Record<string, string[]>`:
```typescript
export const RELATED_LANGUAGES: Record<string, string[]> = {
  c: ["cpp"],
  cpp: ["c"],
  typescript: ["javascript"],
  javascript: ["typescript"],
  objectivec: ["c", "cpp"],
  objectivecpp: ["c", "cpp", "objectivec"],
  kotlin: ["java"],
  // (only include genuinely related languages that should get affinity boost)
};
```

3. Export `classifyFileLanguageWithContext(filePath: string, contextFiles?: string[]): string`:
   - Same as `classifyFileLanguage` for non-ambiguous extensions
   - For `.h`: if contextFiles contains any `.cpp`, `.cc`, `.cxx`, `.hpp`, `.hxx` → return `"cpp"`. Else return `"c"`.
   - Falls back to `classifyFileLanguage` when no context provided

4. Update `classifyFileLanguage` to return lowercase values (breaking change for display — but consumers already normalize or can adapt). If this is too disruptive, keep `classifyFileLanguage` returning Title Case for backward compat and have `classifyFileLanguageWithContext` return lowercase. The executor should check existing test assertions and decide which approach minimizes test updates.

**IMPORTANT:** All language values in the database and new code paths should be lowercase. The existing `EXTENSION_LANGUAGE_MAP` uses Title Case (`"TypeScript"`, `"Python"`). Either update it to lowercase and fix all consumers, or add a separate normalized version. Check `classifyFileLanguage` usage sites to decide — the primary consumers are `retrieval-rerank.ts` (compares against `prLanguages`) and display code.
  </action>
  <verify>
    <automated>npx vitest run src/execution/diff-analysis.test.ts --reporter=verbose 2>&1 | tail -20</automated>
  </verify>
  <done>EXTENSION_LANGUAGE_MAP has 30+ language entries, classifyFileLanguageWithContext resolves ambiguous extensions using repo context, RELATED_LANGUAGES map exported, all tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Add language field to types and populate on memory write</name>
  <files>src/knowledge/types.ts, src/knowledge/memory-store.ts, src/knowledge/memory-store.test.ts</files>
  <action>
1. In `src/knowledge/types.ts`, add `language?: string` field to `LearningMemoryRecord` (after `filePath`).

2. In `src/knowledge/memory-store.ts`:
   - Import `classifyFileLanguage` from `"../execution/diff-analysis.ts"`
   - Add `language` to the `MemoryRow` type
   - Update `rowToRecord` to include `language: row.language`
   - Update `writeMemory` INSERT to include `language` column:
     ```typescript
     const language = classifyFileLanguage(record.filePath).toLowerCase();
     // ... INSERT INTO learning_memories (..., language) VALUES (..., ${language === 'unknown' ? 'unknown' : language})
     ```
   - Note: Use `classifyFileLanguage` (not context-aware version) since writeMemory doesn't have PR context. The caller can pass `record.language` if they have context-aware classification already done.
   - Actually: check if `record.language` is already set (from caller). If so, use it. Otherwise classify from filePath. This allows the review handler to pre-classify with context.

3. Update `memory-store.test.ts`:
   - Add test that writeMemory stores the language field
   - Add test that getMemoryRecord returns the language field
   - Add test that if record.language is provided, it is used instead of classifying from filePath

4. Export the `language` field in the `MemoryRow` type update and ensure `getMemoryRecord` returns it.
  </action>
  <verify>
    <automated>npx vitest run src/knowledge/memory-store.test.ts --reporter=verbose 2>&1 | tail -20</automated>
  </verify>
  <done>LearningMemoryRecord has language field, writeMemory populates it from filePath classification, getMemoryRecord returns it, tests pass</done>
</task>

</tasks>

<verification>
- Migration 007 SQL is syntactically valid
- `EXTENSION_LANGUAGE_MAP` has 30+ entries (count Object.keys)
- `classifyFileLanguageWithContext` correctly resolves `.h` based on context
- `RELATED_LANGUAGES` has bidirectional entries for C/C++, TS/JS
- `writeMemory` includes language in INSERT
- `getMemoryRecord` returns language field
- All existing tests still pass (no regressions from lowercase change)
</verification>

<success_criteria>
- learning_memories table has language column after migration
- wiki_pages table has language_tags column after migration
- Existing records backfilled with language from file_path
- New records automatically classified on write
- 30+ language extensions supported
- Ambiguous `.h` resolved with context
- Related language map available for affinity boosting
</success_criteria>

<output>
After completion, create `.planning/phases/93-language-aware-retrieval-boosting/93-01-SUMMARY.md`
</output>
