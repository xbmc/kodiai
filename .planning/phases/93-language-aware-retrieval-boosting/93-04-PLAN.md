---
phase: 93-language-aware-retrieval-boosting
plan: 04
type: execute
wave: 3
depends_on: [01, 02, 03]
files_modified:
  - src/knowledge/wiki-retrieval.ts
  - src/knowledge/wiki-retrieval.test.ts
  - src/knowledge/retrieval.e2e.test.ts
  - src/handlers/review.ts
  - src/handlers/mention.ts
autonomous: true
requirements: [LANG-01, LANG-03, LANG-05]

must_haves:
  truths:
    - "End-to-end retrieval test confirms language-aware ranking across all three corpora"
    - "Review handler passes context-aware language classification to memory writes"
    - "Wiki retrieval returns languageTags in search results for unified pipeline consumption"
    - "Mention handler passes prLanguages to retrieval for language-aware boosting"
  artifacts:
    - path: "src/knowledge/retrieval.e2e.test.ts"
      provides: "E2E test validating language-aware cross-corpus ranking"
      contains: "language.*boost\\|languageTags"
    - path: "src/knowledge/wiki-retrieval.ts"
      provides: "Wiki search results include languageTags"
      contains: "languageTags"
  key_links:
    - from: "src/handlers/review.ts"
      to: "src/knowledge/memory-store.ts"
      via: "writeMemory with language field"
      pattern: "language"
    - from: "src/knowledge/wiki-retrieval.ts"
      to: "src/knowledge/retrieval.ts"
      via: "WikiKnowledgeMatch with languageTags"
      pattern: "languageTags"
---

<objective>
Wire language metadata through all consumer paths: review handler pre-classifies languages for memory writes, wiki retrieval exposes language tags, and e2e tests validate end-to-end language-aware ranking.

Purpose: Complete the integration — all write paths store language, all read paths use it, and tests prove it works end-to-end.
Output: Updated handlers, wiki retrieval types, comprehensive e2e test.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/93-language-aware-retrieval-boosting/93-CONTEXT.md
@.planning/phases/93-language-aware-retrieval-boosting/93-01-SUMMARY.md
@.planning/phases/93-language-aware-retrieval-boosting/93-02-SUMMARY.md
@.planning/phases/93-language-aware-retrieval-boosting/93-03-SUMMARY.md

@src/handlers/review.ts
@src/handlers/mention.ts
@src/knowledge/wiki-retrieval.ts
@src/knowledge/retrieval.e2e.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire language through wiki retrieval and handlers</name>
  <files>src/knowledge/wiki-retrieval.ts, src/knowledge/wiki-retrieval.test.ts, src/handlers/review.ts, src/handlers/mention.ts</files>
  <action>
1. **Update wiki-retrieval.ts:**
   - Add `languageTags` to `WikiKnowledgeMatch` type:
     ```typescript
     export type WikiKnowledgeMatch = {
       // ... existing fields
       languageTags: string[];
     };
     ```
   - Update `searchWikiPages` to include `languageTags` from the wiki store search result:
     ```typescript
     return searchResults.map((r) => ({
       // ... existing mapping
       languageTags: r.record.languageTags ?? [],
     }));
     ```

2. **Update review handler (src/handlers/review.ts):**
   Find the code that calls `writeMemory` (or the learning pipeline that eventually calls it). When building the `LearningMemoryRecord`, add `language` field using context-aware classification:
   ```typescript
   import { classifyFileLanguageWithContext } from "../execution/diff-analysis.ts";

   // When creating a learning memory record:
   const prFiles = diffAnalysis.changedFiles ?? [];
   const language = classifyFileLanguageWithContext(finding.filePath, prFiles).toLowerCase();
   // Add to record: { ...record, language }
   ```
   This ensures `.h` files in C++ PRs get classified as `cpp` rather than `c`.

3. **Update mention handler (src/handlers/mention.ts):**
   Find where `prLanguages` is built (around line 1170). Ensure it passes lowercase-normalized languages to the retrieval call. The current code uses `classifyLanguages()` which returns Title Case — normalize:
   ```typescript
   const prLanguages = Array.from(
     new Set(Object.keys(classifyLanguages(changedFiles)).map(l => l.toLowerCase()))
   );
   ```

4. **Update wiki-retrieval.test.ts:**
   - Add test that searchWikiPages returns languageTags in results
   - Test that results without language_tags default to empty array
  </action>
  <verify>
    <automated>npx vitest run src/knowledge/wiki-retrieval.test.ts --reporter=verbose 2>&1 | tail -20</automated>
  </verify>
  <done>Wiki retrieval exposes languageTags, review handler writes language-classified memories, mention handler normalizes prLanguages to lowercase, tests pass</done>
</task>

<task type="auto">
  <name>Task 2: E2E test for language-aware cross-corpus ranking</name>
  <files>src/knowledge/retrieval.e2e.test.ts</files>
  <action>
Add e2e test cases to the existing retrieval e2e test suite that validate language-aware ranking across all three corpora.

**Test cases to add:**

1. **Language boost for learning memories:**
   - Insert two memories: one with `language: "cpp"`, one with `language: "python"`, both with similar semantic distance
   - Retrieve with `prLanguages: ["C++"]`
   - Assert: C++ memory ranks higher than Python memory in `unifiedResults`

2. **No penalty for non-matching:**
   - Insert a memory with `language: "python"`
   - Retrieve with `prLanguages: ["C++"]`
   - Assert: Python memory's rrfScore is NOT lower than it would be without language boosting (i.e., its score is unchanged)

3. **Wiki language tag boost:**
   - Insert wiki chunks: one tagged `["cpp"]`, one tagged `["general"]`, same semantic distance
   - Retrieve with `prLanguages: ["C++"]`
   - Assert: C++-tagged wiki chunk ranks higher

4. **Related language affinity:**
   - Insert memory with `language: "c"`
   - Retrieve with `prLanguages: ["C++"]`
   - Assert: C memory gets boosted (but less than exact C++ match)

5. **Multi-language proportional boost:**
   - Retrieve with `prLanguages: ["C++", "C++", "C++", "C++", "Python"]` (80% C++, 20% Python)
   - Assert: C++ results get stronger boost than Python results

**Implementation notes:**
- Follow the existing e2e test patterns in the file (mock stores, mock embedding provider)
- Use the existing test infrastructure — don't create a new test file
- Each test should be clearly named: `test("language boost: C++ memory ranks higher in C++ PR", ...)`
- If the existing e2e tests use real database connections, mock the language fields on the store responses rather than inserting real records
  </action>
  <verify>
    <automated>npx vitest run src/knowledge/retrieval.e2e.test.ts --reporter=verbose 2>&1 | tail -30</automated>
  </verify>
  <done>E2E tests validate: language boost for learning memories, no penalty for non-matching, wiki language tag boost, related language affinity, multi-language proportional boost. All tests pass.</done>
</task>

</tasks>

<verification>
- All test suites pass: retrieval.e2e.test.ts, wiki-retrieval.test.ts, retrieval.test.ts
- No double-boost detected in e2e test (unified results reflect single language boost)
- Review handler writes language-classified memories
- Wiki retrieval exposes language tags through to unified pipeline
- prLanguages normalized to lowercase throughout
</verification>

<success_criteria>
- End-to-end language-aware ranking proven by tests
- All write paths store language metadata
- All read paths expose language metadata to unified pipeline
- Handler integration complete (review writes, mention reads)
- No test regressions across entire knowledge module
</success_criteria>

<output>
After completion, create `.planning/phases/93-language-aware-retrieval-boosting/93-04-SUMMARY.md`
</output>
