---
phase: 93-language-aware-retrieval-boosting
plan: 03
type: tdd
wave: 2
depends_on: [01, 02]
files_modified:
  - src/knowledge/retrieval-rerank.ts
  - src/knowledge/retrieval-rerank.test.ts
  - src/knowledge/retrieval.ts
  - src/knowledge/retrieval.test.ts
  - src/knowledge/cross-corpus-rrf.ts
  - src/knowledge/cross-corpus-rrf.test.ts
autonomous: true
requirements: [LANG-03, LANG-04]

must_haves:
  truths:
    - "Retrieval results for a C++ PR rank C++ memories and C++-tagged wiki pages higher than Python ones"
    - "Language weighting is applied in exactly one location — the unified pipeline step 6e"
    - "Non-matching results keep their original score, never penalized"
    - "Multi-language PRs apply proportional boost by change volume"
    - "Related languages (C/C++) get a fraction of exact-match boost"
  artifacts:
    - path: "src/knowledge/retrieval.ts"
      provides: "Unified pipeline with language-aware boosting in step 6e"
      contains: "languageBoost"
    - path: "src/knowledge/retrieval-rerank.ts"
      provides: "Refactored to use stored language, boost-only (no penalty)"
      contains: "record.language"
    - path: "src/knowledge/cross-corpus-rrf.ts"
      provides: "UnifiedRetrievalChunk with language metadata"
      contains: "language"
  key_links:
    - from: "src/knowledge/retrieval.ts"
      to: "src/knowledge/cross-corpus-rrf.ts"
      via: "language boost in step 6e"
      pattern: "languageBoost\\|language.*boost"
    - from: "src/knowledge/retrieval.ts"
      to: "src/knowledge/retrieval-rerank.ts"
      via: "legacy rerank removal"
      pattern: "rerankByLanguage"
---

<objective>
Consolidate language boosting into the unified cross-corpus pipeline, remove legacy double-boost, and implement proportional multi-language boosting with related-language affinity.

Purpose: All three corpora get language-aware ranking in exactly one location (LANG-03, LANG-04). No penalty for non-matching — boost only.
Output: Unified pipeline language boost, refactored reranker, updated cross-corpus types.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
@/home/keith/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/93-language-aware-retrieval-boosting/93-CONTEXT.md
@.planning/phases/93-language-aware-retrieval-boosting/93-RESEARCH.md
@.planning/phases/93-language-aware-retrieval-boosting/93-01-SUMMARY.md
@.planning/phases/93-language-aware-retrieval-boosting/93-02-SUMMARY.md

@src/knowledge/retrieval.ts
@src/knowledge/retrieval-rerank.ts
@src/knowledge/cross-corpus-rrf.ts
@src/execution/diff-analysis.ts

<interfaces>
<!-- Key types from Plan 01 output -->

From src/execution/diff-analysis.ts (after Plan 01):
```typescript
export const RELATED_LANGUAGES: Record<string, string[]>;
export function classifyFileLanguageWithContext(filePath: string, contextFiles?: string[]): string;
```

From src/knowledge/types.ts (after Plan 01):
```typescript
export type LearningMemoryRecord = {
  // ... existing fields
  language?: string;  // NEW: stored language
};
```

From src/knowledge/cross-corpus-rrf.ts:
```typescript
export type UnifiedRetrievalChunk = {
  id: string;
  text: string;
  source: SourceType;
  sourceLabel: string;
  sourceUrl: string | null;
  vectorDistance: number | null;
  rrfScore: number;
  createdAt: string | null;
  metadata: Record<string, unknown>;
  alternateSources?: string[];
};
```

From src/knowledge/retrieval-rerank.ts:
```typescript
export type RerankedResult = RetrievalResult & {
  adjustedDistance: number;
  languageMatch: boolean;
};
export function rerankByLanguage(params: {
  results: RetrievalResult[];
  prLanguages: string[];
  config?: RerankConfig;
}): RerankedResult[];
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor retrieval-rerank.ts — stored language, no penalty</name>
  <files>src/knowledge/retrieval-rerank.ts, src/knowledge/retrieval-rerank.test.ts</files>
  <action>
TDD approach — update tests first, then implementation.

**Test updates in retrieval-rerank.test.ts:**

1. Update existing tests: `rerankByLanguage` now reads `result.record.language` instead of calling `classifyFileLanguage(result.record.filePath)`. Update test fixtures to include `language` field on records.
2. Remove or update "cross-language penalty" test — now there is NO penalty. Cross-language results keep original distance (multiplier 1.0).
3. Add test: record with `language: "typescript"` and prLanguages `["typescript"]` gets boost (adjustedDistance = distance * 0.85)
4. Add test: record with `language: "python"` and prLanguages `["typescript"]` gets NO penalty (adjustedDistance = distance * 1.0, NOT 1.15)
5. Add test: record with `language: "unknown"` gets no boost or penalty (multiplier 1.0)
6. Add test: record with `language: undefined` (old records without backfill) falls back to `classifyFileLanguage(record.filePath)` for backward compat
7. Add test for related language affinity: record with `language: "c"` and prLanguages `["cpp"]` gets partial boost (e.g., adjustedDistance = distance * 0.925 — halfway between 1.0 and 0.85)

**Implementation changes:**

1. Update `rerankByLanguage`:
```typescript
export function rerankByLanguage(params: {
  results: RetrievalResult[];
  prLanguages: string[];
  config?: RerankConfig;
}): RerankedResult[] {
  const { results, prLanguages, config = DEFAULT_RERANK_CONFIG } = params;
  const prLangSet = new Set(prLanguages.map(l => l.toLowerCase()));

  return results.map((result) => {
    // Use stored language, fallback to runtime classification for old records
    const language = (result.record.language ?? classifyFileLanguage(result.record.filePath)).toLowerCase();

    let multiplier = 1.0;  // DEFAULT: no change (no penalty ever)
    let languageMatch = false;

    if (language === "unknown" || !language) {
      // Neutral
    } else if (prLangSet.has(language)) {
      multiplier = config.sameLanguageBoost;
      languageMatch = true;
    } else if (isRelatedLanguage(language, prLangSet)) {
      // Related language affinity: 50% of exact boost
      multiplier = 1.0 - (1.0 - config.sameLanguageBoost) * config.relatedLanguageRatio;
      languageMatch = false; // partial match, not exact
    }
    // else: non-matching, multiplier stays 1.0 (NO PENALTY)

    return {
      ...result,
      adjustedDistance: result.distance * multiplier,
      languageMatch,
    };
  }).sort((a, b) => a.adjustedDistance - b.adjustedDistance);
}
```

2. Update `RerankConfig`:
```typescript
export type RerankConfig = {
  sameLanguageBoost: number;      // 0.85 — lower distance = better
  relatedLanguageRatio: number;   // 0.5 — related gets 50% of exact boost
};

export const DEFAULT_RERANK_CONFIG: RerankConfig = {
  sameLanguageBoost: 0.85,
  relatedLanguageRatio: 0.5,
};
```
   Remove `crossLanguagePenalty` from the type and default. This is a breaking change to the config type — update any other references.

3. Add helper:
```typescript
import { RELATED_LANGUAGES } from "../execution/diff-analysis.ts";

function isRelatedLanguage(lang: string, prLangSet: Set<string>): boolean {
  const related = RELATED_LANGUAGES[lang];
  if (!related) return false;
  return related.some(r => prLangSet.has(r));
}
```
  </action>
  <verify>
    <automated>npx vitest run src/knowledge/retrieval-rerank.test.ts --reporter=verbose 2>&1 | tail -20</automated>
  </verify>
  <done>rerankByLanguage uses stored language, no cross-language penalty, related language affinity at 50% boost, backward compat fallback for records without language field, all tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Move language boosting to unified pipeline, remove legacy double-boost</name>
  <files>src/knowledge/retrieval.ts, src/knowledge/retrieval.test.ts, src/knowledge/cross-corpus-rrf.ts</files>
  <action>
**CRITICAL: This task eliminates double-boost (LANG-04).** The unified pipeline becomes the single location for language weighting.

**Changes to retrieval.ts:**

1. **Remove legacy language reranking from step 4.** Change lines ~360-365 from:
```typescript
const languageReranked = mergedResults.length > 0
  ? rerankByLanguage({ results: mergedResults, prLanguages })
  : [];
const reranked = languageReranked.length > 0
  ? applyRecencyWeighting({ results: languageReranked })
  : [];
```
To:
```typescript
// Step 4: Apply recency weighting only (language boost moved to unified pipeline step 6e)
const reranked = mergedResults.length > 0
  ? applyRecencyWeighting({
      results: mergedResults.map(r => ({
        ...r,
        adjustedDistance: r.distance,  // pass-through, no language adjustment
        languageMatch: false,
      })),
    })
  : [];
```
Note: `applyRecencyWeighting` expects `RerankedResult[]` which has `adjustedDistance`. We need to provide it. Set `adjustedDistance = distance` (no language modification) since language boost now happens in step 6e.

**Alternative approach (simpler):** Keep `rerankByLanguage()` call but only for the legacy pipeline backward compat. The key constraint is: language boost must not affect the unified results. Since `memoryToUnified()` at line 408 uses `result.distance` (not `adjustedDistance`), the unified pipeline already ignores the legacy rerank. **Verify this is actually the case before choosing approach.** If `memoryToUnified` uses the reranked results which have `adjustedDistance` baked in, then double-boost IS happening and the legacy call must be removed.

Actually, looking at line 408: `const codeChunks = finalReranked.map((r) => memoryToUnified(r as unknown as MergedRetrievalResult));` — `memoryToUnified` reads `result.distance` from the original `MergedRetrievalResult`. But `finalReranked` has type `RerankedResult` with `adjustedDistance` — and the cast `as unknown as MergedRetrievalResult` loses the adjusted field. So `memoryToUnified` reads the original `distance`. **This means the unified pipeline currently does NOT double-boost — it uses raw distance.** But it also means the unified pipeline gets NO language boost currently.

**The correct approach:** Add language boosting ONLY in step 6e for the unified pipeline. Keep the legacy `rerankByLanguage()` call for the legacy `findings` output (backward compat for consumers still using `findings` array). This is safe because:
- Legacy consumers use `findings` (which has language reranking from step 4)
- New consumers use `unifiedResults` (which gets language boosting from step 6e)
- No double-boost because `memoryToUnified` reads `result.distance`, not `adjustedDistance`

2. **Add language boosting to step 6e in the unified pipeline.** After the existing source weight application:

```typescript
// 6e-bis: Apply language-aware boost to unified results
const langWeightMap = buildProportionalLanguageWeights(prLanguages);

if (langWeightMap.size > 0) {
  for (const chunk of unifiedResults) {
    const chunkLang = getChunkLanguage(chunk);
    if (!chunkLang || chunkLang === 'unknown' || chunkLang === 'general') continue;

    const LANGUAGE_BOOST_FACTOR = 0.25;
    const AFFINITY_RATIO = 0.5;

    let boost = 0;
    const normalizedChunkLang = chunkLang.toLowerCase();

    if (langWeightMap.has(normalizedChunkLang)) {
      // Exact match: boost proportional to that language's share of PR changes
      boost = langWeightMap.get(normalizedChunkLang)! * LANGUAGE_BOOST_FACTOR;
    } else if (hasRelatedLanguage(normalizedChunkLang, langWeightMap)) {
      // Related language: fraction of exact match boost
      boost = getMaxRelatedWeight(normalizedChunkLang, langWeightMap) * LANGUAGE_BOOST_FACTOR * AFFINITY_RATIO;
    }
    // else: no match, no boost, score unchanged (NEVER penalize)

    if (boost > 0) {
      chunk.rrfScore *= (1 + boost);
    }
  }
  // Re-sort after language boost
  unifiedResults.sort((a, b) => b.rrfScore - a.rrfScore);
}
```

3. **Add helper functions** (in retrieval.ts or a new utility):

```typescript
import { RELATED_LANGUAGES } from "../execution/diff-analysis.ts";
import { classifyFileLanguage } from "../execution/diff-analysis.ts";

/** Build proportional weights from PR language list.
 * E.g., ["C++", "C++", "C++", "C++", "Python"] -> Map { "cpp": 0.8, "python": 0.2 } */
function buildProportionalLanguageWeights(prLanguages: string[]): Map<string, number> {
  if (prLanguages.length === 0) return new Map();
  const counts = new Map<string, number>();
  for (const lang of prLanguages) {
    const normalized = lang.toLowerCase();
    counts.set(normalized, (counts.get(normalized) ?? 0) + 1);
  }
  const total = prLanguages.length;
  const weights = new Map<string, number>();
  for (const [lang, count] of counts) {
    weights.set(lang, count / total);
  }
  return weights;
}

/** Get language from a unified chunk's metadata. */
function getChunkLanguage(chunk: UnifiedRetrievalChunk): string | null {
  if (chunk.source === "code") {
    return (chunk.metadata?.language as string) ?? null;
  }
  if (chunk.source === "wiki") {
    const tags = chunk.metadata?.languageTags as string[] | undefined;
    // Return the first non-general tag, or 'general' if all are general
    return tags?.find(t => t !== 'general') ?? (tags?.[0] ?? null);
  }
  if (chunk.source === "review_comment") {
    // Review comments have filePath — classify from it
    const filePath = chunk.metadata?.filePath as string | undefined;
    return filePath ? classifyFileLanguage(filePath).toLowerCase() : null;
  }
  return null;
}

function hasRelatedLanguage(lang: string, weightMap: Map<string, number>): boolean {
  const related = RELATED_LANGUAGES[lang];
  return related?.some(r => weightMap.has(r)) ?? false;
}

function getMaxRelatedWeight(lang: string, weightMap: Map<string, number>): number {
  const related = RELATED_LANGUAGES[lang];
  if (!related) return 0;
  return Math.max(0, ...related.map(r => weightMap.get(r) ?? 0));
}
```

4. **Update memoryToUnified** to include `language` in metadata:
```typescript
function memoryToUnified(result: MergedRetrievalResult): UnifiedRetrievalChunk {
  return {
    // ... existing fields
    metadata: {
      // ... existing metadata
      language: result.record.language ?? classifyFileLanguage(result.record.filePath).toLowerCase(),
    },
  };
}
```

5. **Update wikiMatchToUnified** to include `languageTags` in metadata:
```typescript
function wikiMatchToUnified(match: WikiKnowledgeMatch): UnifiedRetrievalChunk {
  return {
    // ... existing fields
    metadata: {
      // ... existing metadata
      languageTags: match.languageTags ?? [],
    },
  };
}
```
This requires `WikiKnowledgeMatch` (from `wiki-retrieval.ts`) to include `languageTags`. Update that type too.

6. **Update retrieval.test.ts and cross-corpus-rrf tests:**
   - Test that unified results for C++ memory get boosted when prLanguages includes "C++"
   - Test that Python memory is NOT penalized when prLanguages is ["C++"]
   - Test proportional boost: 80% C++ PR boosts C++ results more than 50% C++ PR
   - Test related language affinity: C memory gets partial boost when prLanguages is ["C++"]
   - Test wiki chunk with languageTags: ["python"] gets boosted when prLanguages includes "Python"

**IMPORTANT:** The `prLanguages` parameter comes from `opts.prLanguages` which is populated by the review handler from `Object.keys(diffAnalysis.filesByLanguage ?? {})`. These are currently Title Case (e.g., "TypeScript"). The new code normalizes to lowercase internally. Verify this works correctly.
  </action>
  <verify>
    <automated>npx vitest run src/knowledge/retrieval.test.ts src/knowledge/retrieval-rerank.test.ts --reporter=verbose 2>&1 | tail -30</automated>
  </verify>
  <done>Language boosting applied in unified pipeline step 6e only. Legacy rerankByLanguage kept for backward compat findings output but does not affect unified results. No double-boost. Proportional multi-language weights. Related language affinity. No penalty for non-matching. All tests pass.</done>
</task>

</tasks>

<verification>
- No double-boost: language boost applied in exactly one location per pipeline path
  - Legacy findings: rerankByLanguage (step 4)
  - Unified results: step 6e boost (NOT rerankByLanguage)
- C++ PR: C++ memories and C++-tagged wiki pages rank higher than Python ones
- Multi-language PR: boost proportional to change volume
- Non-matching results: score unchanged (no penalty)
- Related languages (C/C++): partial boost at 50% of exact match
- All existing retrieval tests pass
- E2E test confirms language-aware ranking
</verification>

<success_criteria>
- Language weighting in unified pipeline (LANG-03)
- Single location for language boosting — no double-boost (LANG-04)
- Boost-only policy: non-matching results never penalized
- Proportional multi-language boost from PR file distribution
- Related language affinity for C/C++, TS/JS
- All tests pass, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/93-language-aware-retrieval-boosting/93-03-SUMMARY.md`
</output>
