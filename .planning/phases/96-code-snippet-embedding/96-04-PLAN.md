---
phase: 96-code-snippet-embedding
plan: 04
type: execute
wave: 3
depends_on: [01, 02, 03]
files_modified:
  - src/knowledge/retrieval.ts
  - src/knowledge/index.ts
  - src/handlers/review.ts
  - src/index.ts
  - src/knowledge/retrieval.test.ts
autonomous: true
requirements: [SNIP-01, SNIP-04, SNIP-05]

must_haves:
  truths:
    - createRetriever accepts optional codeSnippetStore dependency
    - Snippet corpus participates in cross-corpus RRF as a fourth source list
    - snippetToUnified normalizer produces [snippet] source labels with PR title + file + line range
    - Review handler triggers hunk embedding asynchronously after review completion
    - Hunk embedding respects retrieval.hunkEmbedding.enabled flag
    - Hunk embedding applies excludePatterns and maxHunksPerPr cap before calling embedding API
    - The entire embedding pipeline is fire-and-forget with fail-open error handling
  artifacts:
    - src/knowledge/retrieval.ts (modified)
    - src/knowledge/index.ts (modified)
    - src/handlers/review.ts (modified)
    - src/index.ts (modified)
  key_links:
    - retrieval.ts wires snippet search into parallel fan-out alongside code, review, wiki
    - review.ts calls embedDiffHunks after review completion (async, fail-open)
    - index.ts creates CodeSnippetStore and passes to createRetriever
---

<objective>
Wire code snippets into the cross-corpus retrieval pipeline and trigger hunk embedding from the review handler.

Purpose: Complete the end-to-end integration — hunks are embedded after review and appear in retrieval results.
Output: Fourth corpus in RRF pipeline, async embedding trigger in review handler.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/96-code-snippet-embedding/96-01-SUMMARY.md
@.planning/phases/96-code-snippet-embedding/96-02-SUMMARY.md
@.planning/phases/96-code-snippet-embedding/96-03-SUMMARY.md
@src/knowledge/retrieval.ts
@src/knowledge/index.ts
@src/knowledge/cross-corpus-rrf.ts
@src/knowledge/code-snippet-types.ts
@src/knowledge/code-snippet-retrieval.ts
@src/knowledge/code-snippet-chunker.ts
@src/knowledge/code-snippet-store.ts
@src/handlers/review.ts
@src/index.ts
@src/execution/config.ts

<interfaces>
<!-- From code-snippet-retrieval.ts (Plan 03) -->
export type CodeSnippetMatch = {
  embeddedText: string; distance: number; contentHash: string; repo: string;
  prNumber: number; prTitle: string | null; filePath: string; startLine: number;
  endLine: number; language: string; createdAt: string; source: "snippet";
};
export async function searchCodeSnippets(opts): Promise<CodeSnippetMatch[]>;

<!-- From code-snippet-chunker.ts (Plan 02) -->
export type ParsedHunk = { filePath: string; startLine: number; lineCount: number; functionContext: string; addedLines: string[]; language: string; };
export function parseDiffHunks(params): ParsedHunk[];
export function buildEmbeddingText(params): string;
export function isExcludedPath(filePath: string, patterns: string[]): boolean;
export function applyHunkCap(hunks: ParsedHunk[], maxHunks: number): ParsedHunk[];
export function computeContentHash(text: string): string;

<!-- From code-snippet-store.ts (Plan 03) -->
export function createCodeSnippetStore(opts): CodeSnippetStore;

<!-- From retrieval.ts — createRetriever deps -->
export function createRetriever(deps: {
  embeddingProvider: EmbeddingProvider; isolationLayer: IsolationLayer;
  config: RetrieverConfig; reviewCommentStore?: ReviewCommentStore;
  wikiPageStore?: WikiPageStore; memoryStore?: LearningMemoryStore;
}): { retrieve: (opts: RetrieveOptions) => Promise<RetrieveResult | null> };

<!-- From cross-corpus-rrf.ts -->
export type SourceType = "code" | "review_comment" | "wiki" | "snippet";
export type UnifiedRetrievalChunk = { id, text, source: SourceType, sourceLabel, ... };
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire snippet corpus into retrieval pipeline</name>
  <files>
    src/knowledge/retrieval.ts
    src/knowledge/index.ts
    src/knowledge/retrieval.test.ts
  </files>
  <action>
**1. Update `createRetriever` deps in `src/knowledge/retrieval.ts`:**

Add optional `codeSnippetStore` dependency:
```typescript
export function createRetriever(deps: {
  embeddingProvider: EmbeddingProvider;
  isolationLayer: IsolationLayer;
  config: RetrieverConfig;
  reviewCommentStore?: ReviewCommentStore;
  wikiPageStore?: WikiPageStore;
  memoryStore?: LearningMemoryStore;
  codeSnippetStore?: CodeSnippetStore;  // NEW
}): ...
```

Import at top of file:
```typescript
import { searchCodeSnippets, type CodeSnippetMatch } from "./code-snippet-retrieval.ts";
import type { CodeSnippetStore } from "./code-snippet-types.ts";
```

**2. Add `snippetToUnified` normalizer** (follows reviewMatchToUnified / wikiMatchToUnified pattern):

```typescript
function snippetToUnified(match: CodeSnippetMatch, repo: string): UnifiedRetrievalChunk {
  return {
    id: `snippet:${match.contentHash}:${match.distance}`,
    text: match.embeddedText,
    source: "snippet",
    sourceLabel: `[snippet] PR #${match.prNumber}: ${match.prTitle ?? "untitled"} — ${match.filePath}:${match.startLine}-${match.endLine}`,
    sourceUrl: `https://github.com/${repo}/pull/${match.prNumber}`,
    vectorDistance: match.distance,
    rrfScore: 0,
    createdAt: match.createdAt,
    metadata: {
      contentHash: match.contentHash,
      filePath: match.filePath,
      startLine: match.startLine,
      endLine: match.endLine,
      prNumber: match.prNumber,
      prTitle: match.prTitle,
      language: match.language,
    },
  };
}
```

**3. Add snippet search to parallel fan-out** (Step 3 in retrieve function):

Add a 7th Promise.allSettled entry alongside the existing 6 searches:
```typescript
// (g) Code snippet vector search
deps.codeSnippetStore
  ? searchCodeSnippets({
      store: deps.codeSnippetStore,
      embeddingProvider: deps.embeddingProvider,
      query: intentQuery,
      repo: opts.repo,
      topK: 5,
      logger: opts.logger,
    })
  : Promise.resolve([] as CodeSnippetMatch[]),
```

Extract settled result:
```typescript
const snippetResults = snippetVectorResult.status === "fulfilled" ? snippetVectorResult.value : [];
```

Log failure if rejected (same pattern as others).

**4. Add snippet corpus to cross-corpus RRF** (Step 6):

After existing `wikiChunks`:
```typescript
const snippetChunks = snippetResults.map((m) => snippetToUnified(m, opts.repo));
```

Add within-corpus dedup:
```typescript
const dedupedSnippets = deduplicateChunks({
  chunks: snippetChunks,
  similarityThreshold: DEDUP_THRESHOLD,
  mode: "within-corpus",
});
```

Add to sourceLists:
```typescript
if (dedupedSnippets.length > 0) {
  sourceLists.push({ source: "snippet", items: dedupedSnippets });
}
```

**5. Update SOURCE_WEIGHTS** to include snippet:
```typescript
const SOURCE_WEIGHTS: Record<TriggerType, Record<string, number>> = {
  pr_review: { code: 1.2, review_comment: 1.2, wiki: 1.0, snippet: 1.1 },
  issue: { code: 1.0, review_comment: 1.0, wiki: 1.2, snippet: 0.8 },
  question: { code: 1.0, review_comment: 1.0, wiki: 1.2, snippet: 0.8 },
  slack: { code: 1.0, review_comment: 1.0, wiki: 1.0, snippet: 1.0 },
};
```

Snippet gets 1.1 weight for PR reviews (slightly above neutral — it's code change context) and 0.8 for issues/questions (less relevant than wiki for conceptual queries).

**6. Update getChunkLanguage** to handle snippet source:
```typescript
if (chunk.source === "snippet") {
  const lang = chunk.metadata?.language as string | undefined;
  return lang ?? null;
}
```

**7. Update assembleContextWindow** missing corpora check:
```typescript
if (!sourcesPresent.has("snippet") && chunks.length > 0) missingCorpora.push("snippet");
```

Actually, do NOT add this — snippets are a new optional corpus and should not generate a "missing" note. The existing three corpora checks are fine. Leave assembleContextWindow as-is.

**8. Update provenance** to include snippetCount:
Add `snippetCount: snippetResults.length` to the provenance object and the RetrieveResult type.

**9. Update `src/knowledge/index.ts`** to re-export new modules:
```typescript
// Code snippet store
export { createCodeSnippetStore } from "./code-snippet-store.ts";
// Code snippet chunker
export { parseDiffHunks, buildEmbeddingText, isExcludedPath, applyHunkCap, computeContentHash } from "./code-snippet-chunker.ts";
// Code snippet types
export type { CodeSnippetStore, CodeSnippetRecord, CodeSnippetOccurrence, CodeSnippetSearchResult } from "./code-snippet-types.ts";
// Code snippet retrieval
export { searchCodeSnippets, type CodeSnippetMatch } from "./code-snippet-retrieval.ts";
```

**10. Update existing retrieval tests:**
- Ensure existing tests still pass with `codeSnippetStore` being undefined (backward compat)
- Add test: when codeSnippetStore is provided and returns results, snippet results appear in unifiedResults with source: "snippet"
- Add test: snippetToUnified produces correct sourceLabel format
  </action>
  <verify>
    <automated>npx vitest run src/knowledge/retrieval.test.ts --reporter=verbose 2>&1 | tail -30</automated>
    Verify snippet corpus appears in cross-corpus results. Verify backward compat when codeSnippetStore is undefined.
  </verify>
  <done>
    - createRetriever accepts optional codeSnippetStore
    - Snippet vector search runs in parallel with other 6 searches
    - Snippet results go through within-corpus dedup → cross-corpus RRF → source weighting → language boost
    - snippetToUnified produces [snippet] source labels with PR# + file + line range
    - Provenance includes snippetCount
    - index.ts re-exports all new modules
    - Existing retrieval tests still pass (backward compat)
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire hunk embedding trigger into review handler and application bootstrap</name>
  <files>
    src/handlers/review.ts
    src/index.ts
  </files>
  <action>
**1. Update `src/index.ts` (application bootstrap):**

Import and create code snippet store alongside existing stores:
```typescript
import { createCodeSnippetStore } from "./knowledge/code-snippet-store.ts";
```

After the existing store creation (find where reviewCommentStore / wikiPageStore are created), add:
```typescript
const codeSnippetStore = createCodeSnippetStore({ sql, logger });
```

Pass it to createRetriever:
```typescript
const retriever = createRetriever({
  embeddingProvider,
  isolationLayer,
  config: knowledgeConfig,
  reviewCommentStore,
  wikiPageStore,
  memoryStore,
  codeSnippetStore,  // NEW
});
```

Pass codeSnippetStore and config to the review handler (alongside existing deps).

**2. Update `src/handlers/review.ts`:**

Import chunker functions:
```typescript
import {
  parseDiffHunks,
  buildEmbeddingText,
  isExcludedPath,
  applyHunkCap,
  computeContentHash,
} from "../knowledge/code-snippet-chunker.ts";
import type { CodeSnippetStore } from "../knowledge/code-snippet-types.ts";
```

Create an `embedDiffHunks` function:
```typescript
async function embedDiffHunks(params: {
  diffFiles: Array<{ filename: string; patch?: string }>;
  repo: string;
  owner: string;
  prNumber: number;
  prTitle: string;
  codeSnippetStore: CodeSnippetStore;
  embeddingProvider: EmbeddingProvider;
  config: { enabled: boolean; maxHunksPerPr: number; minChangedLines: number; excludePatterns: string[] };
  logger: Logger;
}): Promise<void>
```

Implementation:
1. If `!config.enabled` → return immediately
2. For each diffFile:
   - If `isExcludedPath(diffFile.filename, config.excludePatterns)` → skip
   - If no `diffFile.patch` → skip
   - Call `parseDiffHunks({ diffText: diffFile.patch, filePath: diffFile.filename, minChangedLines: config.minChangedLines })`
   - Collect all hunks
3. Apply `applyHunkCap(allHunks, config.maxHunksPerPr)`
4. For each hunk:
   - `const embeddedText = buildEmbeddingText({ hunk, prTitle: params.prTitle })`
   - `const contentHash = computeContentHash(embeddedText)`
   - Generate embedding: `await embeddingProvider.generate(embeddedText, "document")`
   - If embedding null → skip this hunk (fail-open)
   - `await codeSnippetStore.writeSnippet({ contentHash, embeddedText, language: hunk.language, embeddingModel: embeddingProvider.model }, embedding.embedding)`
   - `await codeSnippetStore.writeOccurrence({ contentHash, repo, owner, prNumber, prTitle, filePath: hunk.filePath, startLine: hunk.startLine, endLine: hunk.startLine + hunk.addedLines.length - 1, functionContext: hunk.functionContext || null })`
5. Log summary: `logger.info({ repo, prNumber, hunkCount: cappedHunks.length, embeddedCount }, "Hunk embedding complete")`
6. Entire function wrapped in try/catch — on error, log warning and return (fire-and-forget, fail-open)

**3. Call embedDiffHunks from review handler:**

Find where the review handler completes the review (after posting the review comment to GitHub). After that point, fire-and-forget:

```typescript
// Fire-and-forget: embed diff hunks asynchronously (fail-open)
if (codeSnippetStore && hunkEmbeddingConfig.enabled) {
  embedDiffHunks({
    diffFiles: prFiles,  // the files array from the PR diff
    repo,
    owner,
    prNumber,
    prTitle: prTitle ?? "",
    codeSnippetStore,
    embeddingProvider,
    config: hunkEmbeddingConfig,
    logger,
  }).catch((err) => {
    logger.warn({ err }, "Hunk embedding failed (fire-and-forget)");
  });
}
```

The `.catch()` ensures any unhandled rejection doesn't crash the process. The review response has already been sent at this point, so embedding latency does not affect review speed.

**4. Pass hunkEmbedding config from the parsed `.kodiai.yml` config:**

The review handler already receives parsed config. Extract `config.knowledge.retrieval.hunkEmbedding` and pass it to `embedDiffHunks`.
  </action>
  <verify>
    <automated>npx vitest run src/handlers/review.test.ts --reporter=verbose 2>&1 | tail -30</automated>
    Verify existing review handler tests still pass. The new embedding trigger is fire-and-forget so existing tests should not be affected.
  </verify>
  <done>
    - index.ts creates CodeSnippetStore and passes to createRetriever
    - Review handler calls embedDiffHunks after posting review (fire-and-forget)
    - embedDiffHunks respects enabled flag, excludePatterns, maxHunksPerPr, minChangedLines
    - Entire pipeline is fail-open — errors logged, never thrown
    - Existing review handler tests still pass
  </done>
</task>

</tasks>

<verification>
- `npx vitest run src/knowledge/retrieval.test.ts src/handlers/review.test.ts` — all tests pass
- Snippet corpus appears in unifiedResults when codeSnippetStore is provided
- Review handler does not block on hunk embedding
- No existing functionality broken
</verification>

<success_criteria>
- Code snippets are a fully integrated fourth corpus in cross-corpus RRF (SNIP-04)
- Hunk embedding triggered after review with all cost bounding applied (SNIP-01, SNIP-05)
- Feature flag `retrieval.hunkEmbedding.enabled` controls the entire pipeline (SNIP-05)
- Fire-and-forget ensures zero impact on review latency
- All existing tests pass — zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/96-code-snippet-embedding/96-04-SUMMARY.md`
</output>
