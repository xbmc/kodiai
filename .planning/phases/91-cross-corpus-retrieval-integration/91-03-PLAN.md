---
phase: 91-cross-corpus-retrieval-integration
plan: 03
type: execute
wave: 2
depends_on: [91-01, 91-02]
files_modified:
  - src/knowledge/retrieval.ts
  - src/knowledge/retrieval.test.ts
  - src/knowledge/review-comment-retrieval.ts
  - src/knowledge/wiki-retrieval.ts
  - src/knowledge/index.ts
autonomous: true
requirements: [KI-13, KI-16, KI-17, KI-18]

must_haves:
  truths:
    - "Single retrieval call fans out to all three corpora simultaneously"
    - "All corpus results are normalized to UnifiedRetrievalChunk with source labels"
    - "Source-aware re-ranking weights results by context type (PR review vs issue Q&A)"
    - "Context assembly respects token budget with attributed chunks from any source"
    - "No retrieval path bypasses the unified layer"
  artifacts:
    - path: "src/knowledge/retrieval.ts"
      provides: "Unified retrieval pipeline with hybrid search, RRF, dedup, and context assembly"
      exports: ["createRetriever", "RetrieveResult", "RetrieveOptions"]
    - path: "src/knowledge/retrieval.test.ts"
      provides: "Updated tests for unified retrieval pipeline"
  key_links:
    - from: "src/knowledge/retrieval.ts"
      to: "src/knowledge/hybrid-search.ts"
      via: "per-corpus hybrid search before normalization"
      pattern: "hybridSearchMerge"
    - from: "src/knowledge/retrieval.ts"
      to: "src/knowledge/cross-corpus-rrf.ts"
      via: "cross-corpus rank fusion after normalization"
      pattern: "crossCorpusRRF"
    - from: "src/knowledge/retrieval.ts"
      to: "src/knowledge/dedup.ts"
      via: "dedup before and after RRF"
      pattern: "deduplicateChunks"
---

<objective>
Refactor the retrieval pipeline to use unified cross-corpus retrieval with hybrid search, RRF, source-aware re-ranking, and attributed context assembly.

Purpose: KI-13 (single retrieval call fans out to all corpora), KI-16 (source-aware re-ranking), KI-17 (source attribution labels), KI-18 (token-budgeted context assembly). The current `retrieval.ts` treats the three corpora as separate result streams (`findings`, `reviewPrecedents`, `wikiKnowledge`). This plan refactors it to normalize all results into `UnifiedRetrievalChunk`, run cross-corpus RRF, dedup, and return a unified ranked list with source attribution.

Output: Refactored `createRetriever` that returns unified results. Backward-compatible `RetrieveResult` type with new `unifiedResults` field alongside legacy fields for gradual consumer migration.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/91-cross-corpus-retrieval-integration/91-CONTEXT.md
@.planning/phases/91-cross-corpus-retrieval-integration/91-01-SUMMARY.md
@.planning/phases/91-cross-corpus-retrieval-integration/91-02-SUMMARY.md
@src/knowledge/retrieval.ts
@src/knowledge/retrieval.test.ts
@src/knowledge/review-comment-retrieval.ts
@src/knowledge/wiki-retrieval.ts
@src/knowledge/hybrid-search.ts
@src/knowledge/cross-corpus-rrf.ts
@src/knowledge/dedup.ts
@src/knowledge/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor retrieval pipeline to unified cross-corpus flow</name>
  <files>
    src/knowledge/retrieval.ts
    src/knowledge/review-comment-retrieval.ts
    src/knowledge/wiki-retrieval.ts
  </files>
  <action>
Refactor `createRetriever` in `retrieval.ts` to implement the full unified pipeline:

**New pipeline flow (replacing current steps 2b/2c):**

1. **Parallel fan-out** (all three fire simultaneously per CONTEXT.md decision "All three corpus queries fire in parallel every time"):
   - Learning memories: vector search via isolationLayer + full-text search via memoryStore.searchByFullText
   - Review comments: vector search via store.searchByEmbedding + full-text search via store.searchByFullText
   - Wiki pages: vector search via store.searchByEmbedding + full-text search via store.searchByFullText

2. **Per-corpus hybrid merge**: For each corpus, use `hybridSearchMerge` to combine vector + BM25 results into a single ranked list per corpus.

3. **Within-corpus dedup**: Run `deduplicateChunks({ mode: "within-corpus" })` on each corpus list before RRF (per CONTEXT.md: "Dedup happens before rank fusion, within each corpus, to prevent duplicates from inflating a corpus's RRF contribution").

4. **Normalize to UnifiedRetrievalChunk**: Convert each corpus result to unified format:
   - Learning memories: `source: "code"`, `sourceLabel: "[code: {filePath}]"`, `sourceUrl: null`
   - Review comments: `source: "review_comment"`, `sourceLabel: "[review: PR #{prNumber}]"`, `sourceUrl: "https://github.com/{repo}/pull/{prNumber}"`
   - Wiki: `source: "wiki"`, `sourceLabel: "[wiki: {pageTitle}]"`, `sourceUrl: "{pageUrl}"`

5. **Cross-corpus RRF**: Run `crossCorpusRRF` with all three normalized lists. Apply context-dependent source weighting via an optional `triggerType` field on RetrieveOptions:
   - `"pr_review"`: multiply code + review scores by 1.2 (they're more relevant for PR reviews)
   - `"issue"` or `"question"`: multiply wiki scores by 1.2 (wiki more relevant for Q&A)
   - Default: equal weights (no multiplier)
   Per CONTEXT.md: "Context-dependent source weighting: weight depends on trigger"

6. **Cross-corpus dedup**: Run `deduplicateChunks({ mode: "cross-corpus" })` on the merged list.

7. **Context assembly**: Build context string from top-ranked chunks respecting `maxContextChars` token budget. Each chunk prefixed with its `sourceLabel`. Per CONTEXT.md: "Shared token budget for context assembly: top-ranked chunks fill the budget regardless of source type."

**Update RetrieveOptions:**
```typescript
export type RetrieveOptions = {
  // ... existing fields ...
  triggerType?: "pr_review" | "issue" | "question" | "slack";  // NEW: for source weighting
};
```

**Update RetrieveResult** (backward compatible):
```typescript
export type RetrieveResult = {
  // Existing fields preserved for backward compatibility
  findings: MergedRetrievalResult[];
  snippetAnchors: SnippetAnchor[];
  reviewPrecedents: ReviewCommentMatch[];
  wikiKnowledge: WikiKnowledgeMatch[];
  // NEW unified results
  unifiedResults: UnifiedRetrievalChunk[];
  contextWindow: string;  // pre-assembled context with attribution
  provenance: {
    // ... existing fields ...
    unifiedResultCount: number;
    hybridSearchUsed: boolean;
    rrfK: number;
    dedupThreshold: number;
    triggerType: string;
  };
};
```

**Error handling**: Per existing fail-open philosophy, if any corpus query fails, log warning and proceed with results from successful corpora. If a corpus has no data (e.g., wiki not backfilled), per CONTEXT.md: "gracefully skip but add a subtle note."

**Update searchReviewComments and searchWikiPages** to also accept a `fullTextQuery` parameter alongside the embedding, so hybrid search can be done in one call from the pipeline.

Ensure the 6 parallel searches (3 vector + 3 BM25) are dispatched with Promise.allSettled for maximum parallelism and fail-open behavior.
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>Pipeline flow matches the 7-step sequence. All three corpora queried in parallel.</manual>
  </verify>
  <done>Retrieval pipeline normalized to unified chunks via hybrid search + RRF + dedup + context assembly</done>
</task>

<task type="auto">
  <name>Task 2: Update retrieval tests and barrel exports</name>
  <files>
    src/knowledge/retrieval.test.ts
    src/knowledge/index.ts
  </files>
  <action>
Update `src/knowledge/retrieval.test.ts`:

1. Update existing tests to work with new pipeline (they should still pass since legacy fields are preserved).

2. Add new tests for unified pipeline:
   - Test that `unifiedResults` contains chunks from all three corpora
   - Test that `contextWindow` contains source labels in assembled text
   - Test triggerType weighting: pr_review boosts code+review, issue boosts wiki
   - Test that within-corpus dedup prevents duplicate inflation
   - Test fail-open: one corpus fails, others still return results
   - Test empty corpus: missing wiki store returns results from other corpora with note
   - Test token budget: contextWindow respects maxContextChars

3. Ensure all existing tests in the file still pass (backward compatibility).

Update `src/knowledge/index.ts` barrel exports:
- Export `UnifiedRetrievalChunk` and `SourceType` from cross-corpus-rrf
- Export `hybridSearchMerge` and `HybridSearchResult` from hybrid-search
- Export `deduplicateChunks` from dedup
- Export `crossCorpusRRF` from cross-corpus-rrf
  </action>
  <verify>
    <automated>cd /home/keith/src/kodiai && npx vitest run src/knowledge/retrieval.test.ts 2>&1 | tail -30</automated>
  </verify>
  <done>All retrieval tests pass including new unified pipeline tests. Barrel exports updated.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- `npx vitest run src/knowledge/retrieval.test.ts` passes
- `npx vitest run src/knowledge/` â€” all knowledge module tests pass
- Unified results contain source attribution labels
- Context assembly respects token budget
- Fan-out to all three corpora happens in parallel
</verification>

<success_criteria>
- KI-13: Single retrieval call fans out to all three corpora simultaneously
- KI-16: Source-aware re-ranking with context-dependent weighting (pr_review vs issue)
- KI-17: Every chunk carries source label (code / review / wiki) for attribution
- KI-18: Context assembly respects token budget with attributed chunks
- Backward compatible: existing consumers still get findings, reviewPrecedents, wikiKnowledge
</success_criteria>

<output>
After completion, create `.planning/phases/91-cross-corpus-retrieval-integration/91-03-SUMMARY.md`
</output>
