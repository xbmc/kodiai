---
phase: 25-reporting-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/usage-report.ts
  - tsconfig.json
  - package.json
autonomous: true

must_haves:
  truths:
    - "Running `bun scripts/usage-report.ts` prints a human-readable summary with total executions, total tokens, and total cost"
    - "Running with `--since 7d` filters to last 7 days; `--since 2026-01-01` filters from that date"
    - "Running with `--repo owner/name` filters to a single repo"
    - "Running with `--json` outputs structured JSON suitable for piping to jq"
    - "Running with `--csv` outputs CSV with headers suitable for piping to a file"
    - "The default output includes a ranked list of repos by cost"
    - "The output includes avg duration per event type (review vs mention)"
    - "Running with `--help` shows usage information"
  artifacts:
    - path: "scripts/usage-report.ts"
      provides: "Self-contained CLI reporting script"
      contains: "Database.*readonly.*true"
    - path: "tsconfig.json"
      provides: "Type-checking includes scripts directory"
      contains: "scripts/**/*.ts"
    - path: "package.json"
      provides: "Convenience script entry for bun run report"
      contains: "report"
  key_links:
    - from: "scripts/usage-report.ts"
      to: "data/kodiai-telemetry.db"
      via: "bun:sqlite read-only Database constructor"
      pattern: "new Database.*readonly.*true"
    - from: "scripts/usage-report.ts"
      to: "executions table"
      via: "SQL aggregate queries with dynamic WHERE clause"
      pattern: "FROM executions"
---

<objective>
Create a self-contained CLI script at `scripts/usage-report.ts` that opens the telemetry SQLite database in read-only mode and surfaces usage, cost, and duration metrics with filtering and multiple output formats.

Purpose: Operators need visibility into Kodiai resource consumption -- which repos cost the most, how many tokens are used, and how execution duration varies by event type. This is the final piece of the v0.3 observability story.

Output: Working `scripts/usage-report.ts`, updated `tsconfig.json` and `package.json`.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Telemetry store schema and implementation
@src/telemetry/store.ts
@src/telemetry/types.ts

# Research with verified code examples
@.planning/phases/25-reporting-tools/25-RESEARCH.md

# Build config
@tsconfig.json
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create usage-report.ts CLI script with all report capabilities</name>
  <files>scripts/usage-report.ts</files>
  <action>
Create `scripts/usage-report.ts` as a self-contained CLI script. Do NOT import from `src/` -- open the database directly with `bun:sqlite`.

**CLI argument parsing** (use `util.parseArgs`):
- `--since <value>` (string): Time filter -- relative (`7d`, `30d`) or absolute (`2026-01-01`)
- `--repo <value>` (string): Repo filter -- format `owner/name`
- `--json` (boolean): Output structured JSON
- `--csv` (boolean): Output CSV
- `--db <path>` (string, default `./data/kodiai-telemetry.db`): Database path override
- `--help` / `-h` (boolean): Print usage and exit
- `strict: true` to reject unknown flags

**Database opening:**
- Resolve `--db` path with `node:path` resolve
- Check `existsSync(dbPath)` first -- if missing, print clear error: "Database not found at {path}. Has the Kodiai server been started? Use --db to specify a custom path." and exit(1)
- Open with `new Database(dbPath, { readonly: true })`
- Set `PRAGMA busy_timeout = 5000`

**parseSince function:**
- Relative: match `/^(\d+)d$/` -- compute `new Date()` minus N days, format as `YYYY-MM-DD HH:MM:SS`
- Absolute date: match `/^\d{4}-\d{2}-\d{2}$/` -- append ` 00:00:00`
- Full ISO datetime: match `/^\d{4}-\d{2}-\d{2}[T ]\d{2}:\d{2}/` -- replace T with space
- Invalid: print error and exit(1)

**Dynamic WHERE clause construction:**
- Build `conditions: string[]` and `params: Record<string, string | number>` from `--since` and `--repo`
- Use `$since` and `$repo` parameterized values (NOT string interpolation)

**Three SQL queries (all append dynamic WHERE clause):**

1. **Summary** (REPORT-04):
```sql
SELECT
  COUNT(*) as total_executions,
  COALESCE(SUM(input_tokens), 0) as total_input_tokens,
  COALESCE(SUM(output_tokens), 0) as total_output_tokens,
  COALESCE(SUM(input_tokens + output_tokens), 0) as total_tokens,
  COALESCE(SUM(cost_usd), 0) as total_cost
FROM executions
```

2. **Top repos by cost** (REPORT-05):
```sql
SELECT
  repo,
  COUNT(*) as executions,
  SUM(input_tokens + output_tokens) as total_tokens,
  SUM(cost_usd) as total_cost,
  ROUND(AVG(duration_ms)) as avg_duration_ms
FROM executions
{WHERE}
GROUP BY repo
ORDER BY total_cost DESC
```

3. **Duration by event category** (REPORT-08):
```sql
SELECT
  CASE
    WHEN event_type LIKE 'pull_request.%' THEN 'review'
    ELSE 'mention'
  END as category,
  COUNT(*) as executions,
  ROUND(AVG(duration_ms)) as avg_duration_ms,
  SUM(cost_usd) as total_cost
FROM executions
{WHERE}
GROUP BY category
ORDER BY avg_duration_ms DESC
```

**Output formats:**

1. **Human-readable** (default, no `--json`/`--csv`):
   - Print header "Kodiai Usage Report" with a line of `=`
   - If filters active, print "Filters:" section showing since/repo
   - Print "Summary" section with total executions, input tokens, output tokens, total tokens, total cost ($X.XXXX format)
   - Print "Top Repos by Cost" table with columns: Repo (35 wide), Execs (8), Tokens (12), Cost (10), Avg Duration (14)
   - Use `padRight`/`padLeft` helper functions for alignment
   - Print separator line of `-` between header and rows
   - Print "Duration by Event Type" table: Category (12), Execs (8), Avg Duration (14), Cost (10)
   - Handle zero results: print "No executions found." with active filters if any
   - Close the db before exiting

2. **JSON** (`--json`, REPORT-06):
   - Output: `{ generated, filters: { since, repo }, summary: { totalExecutions, totalInputTokens, totalOutputTokens, totalTokens, totalCost }, topRepos: [...], durationByCategory: [...] }`
   - Use `JSON.stringify(output, null, 2)`

3. **CSV** (`--csv`, REPORT-07):
   - Print summary line: `section,metric,value` with rows for each summary field
   - Print blank line
   - Print repos section: `repo,executions,total_tokens,total_cost,avg_duration_ms` header + data rows
   - Quote string fields: `"owner/repo"`
   - Print blank line
   - Print category section: `category,executions,avg_duration_ms,total_cost` header + data rows

**Help output:**
Print usage synopsis, options table, and examples:
```
Usage: bun scripts/usage-report.ts [options]

Options:
  --since <value>   Filter by time (e.g., 7d, 30d, 2026-01-01)
  --repo <value>    Filter by repository (e.g., owner/name)
  --json            Output as JSON
  --csv             Output as CSV
  --db <path>       Database path (default: ./data/kodiai-telemetry.db)
  -h, --help        Show this help

Examples:
  bun scripts/usage-report.ts
  bun scripts/usage-report.ts --since 7d
  bun scripts/usage-report.ts --repo kodiai/xbmc --json
  bun scripts/usage-report.ts --since 30d --csv > report.csv
```
  </action>
  <verify>
Run `bunx tsc --noEmit scripts/usage-report.ts` (after Task 2 updates tsconfig). Run `bun scripts/usage-report.ts --help` and verify it prints usage. If no database exists, run `bun scripts/usage-report.ts` and verify it prints a clear "Database not found" error (not a stack trace).
  </verify>
  <done>
scripts/usage-report.ts exists, parses all 6 flags, opens DB read-only, runs 3 aggregate queries, outputs in human-readable/JSON/CSV formats, handles missing DB and empty results gracefully, and --help prints usage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update tsconfig.json and package.json for script integration</name>
  <files>tsconfig.json, package.json</files>
  <action>
1. **tsconfig.json**: Add `"scripts/**/*.ts"` to the `include` array so the script is type-checked by `bunx tsc --noEmit`:
   ```json
   "include": ["src/**/*.ts", "scripts/**/*.ts"]
   ```

2. **package.json**: Add a `report` script entry for convenience:
   ```json
   "scripts": {
     "dev": "bun run --watch src/index.ts",
     "start": "bun run src/index.ts",
     "report": "bun scripts/usage-report.ts"
   }
   ```

After editing both files, run `bunx tsc --noEmit` to confirm the script type-checks cleanly alongside existing `src/` code.
  </action>
  <verify>
Run `bunx tsc --noEmit` -- must pass with zero errors. Run `bun run report --help` -- must print usage (same as `bun scripts/usage-report.ts --help`).
  </verify>
  <done>
tsconfig.json includes `scripts/**/*.ts`, package.json has `report` script, and `bunx tsc --noEmit` passes with zero errors.
  </done>
</task>

</tasks>

<verification>
1. `bun scripts/usage-report.ts --help` prints usage synopsis, options, and examples
2. `bun scripts/usage-report.ts` (without a DB) prints "Database not found" error message (not a stack trace)
3. `bunx tsc --noEmit` passes with zero errors (script type-checks)
4. `bun run report --help` works via package.json script
5. Code review: script uses `{ readonly: true }`, `PRAGMA busy_timeout`, parameterized queries ($-prefixed), and does NOT import from `src/`
</verification>

<success_criteria>
- REPORT-01: `scripts/usage-report.ts` exists and runs with `bun`
- REPORT-02: `--since 7d` and `--since 2026-01-01` both produce valid date cutoffs used in WHERE clause
- REPORT-03: `--repo owner/name` filters queries to that repo
- REPORT-04: Summary section shows total executions, total tokens (input + output), total cost
- REPORT-05: Top repos section shows repos ranked by cost descending
- REPORT-06: `--json` outputs valid JSON with summary, topRepos, durationByCategory
- REPORT-07: `--csv` outputs CSV with headers for each section
- REPORT-08: Duration section groups events into "review" and "mention" categories with avg duration
</success_criteria>

<output>
After completion, create `.planning/phases/25-reporting-tools/25-01-SUMMARY.md`
</output>
