---
phase: 67-rate-limit-resilience-telemetry
plan: 02
type: execute
wave: 2
depends_on: [67-01]
files_modified:
  - src/telemetry/types.ts
  - src/telemetry/store.ts
  - src/telemetry/store.test.ts
  - src/handlers/review.ts
  - src/handlers/review.test.ts
autonomous: true

must_haves:
  truths:
    - "Telemetry records cache-hit usage, skipped queries, retry attempts, and degradation path whenever Search enrichment runs"
    - "Rate-limit telemetry writes are additive-only and non-blocking, preserving fail-open execution behavior"
    - "Operators can query production telemetry to validate rate-limit handling effectiveness under load"
  artifacts:
    - path: "src/telemetry/types.ts"
      provides: "Typed rate-limit telemetry contract with cache-hit, skip, retry, and degradation fields"
      contains: "rateLimit"
    - path: "src/telemetry/store.ts"
      provides: "SQLite schema + insert path for rate-limit telemetry with additive migration safety"
      contains: "CREATE TABLE"
    - path: "src/handlers/review.ts"
      provides: "Emission of rate-limit telemetry from review flow using bounded-retry/degradation outcomes"
      contains: "record"
    - path: "src/handlers/review.test.ts"
      provides: "Regression coverage that validates telemetry payload values for normal and degraded paths"
      contains: "telemetry"
  key_links:
    - from: "src/handlers/review.ts"
      to: "src/telemetry/types.ts"
      via: "review handler constructs typed rate-limit telemetry event"
      pattern: "cacheHit|retryAttempts|degradationPath"
    - from: "src/telemetry/store.ts"
      to: "src/telemetry/store.test.ts"
      via: "store tests verify persistence, additive migration behavior, and idempotent inserts"
      pattern: "INSERT|SELECT"
---

<objective>
Add production-facing telemetry for Search rate-limit handling so operators can measure cache effectiveness, retry behavior, and degraded execution paths.

Purpose: Deliver OPS-03 observability by persisting actionable metrics for cache hit rate, skipped queries, retry attempts, and degradation outcomes.
Output: Telemetry schema/store extensions and review-handler wiring with regression coverage for normal and degraded execution paths.
</objective>

<execution_context>
@/home/keith/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/keith/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/67-rate-limit-resilience-telemetry/67-01-PLAN.md
@src/telemetry/types.ts
@src/telemetry/store.ts
@src/telemetry/store.test.ts
@src/handlers/review.ts
@src/handlers/review.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend telemetry schema and store for rate-limit metrics</name>
  <files>src/telemetry/types.ts, src/telemetry/store.ts, src/telemetry/store.test.ts</files>
  <action>
Add a dedicated, additive telemetry surface for Search rate-limit observability:

1) Define a typed telemetry record that captures OPS-03 fields.
   - Required metrics: `cacheHitRate`, `skippedQueries`, `retryAttempts`, and `degradationPath`.
   - Include correlation fields already used in telemetry (repo, deliveryId, prNumber, eventType) for joins/reporting.

2) Add SQLite persistence with additive-only migration strategy.
   - Create a new table (or additive columns on existing telemetry table) without mutating/removing existing schema.
   - Add indexes for repo/time queries and idempotency where applicable.

3) Expose a store method to record this telemetry in fail-open style.
   - Store-layer errors must remain non-fatal and compatible with current handler behavior.

Add store tests for insert behavior, idempotency policy, and migration safety on pre-existing DB files.
  </action>
  <verify>
Run `bun test src/telemetry/store.test.ts --timeout 30000`.
Run `bunx tsc --noEmit`.
  </verify>
  <done>
Telemetry store persists rate-limit metrics via a typed API with additive schema changes and deterministic regression coverage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Emit rate-limit telemetry from review flow</name>
  <files>src/handlers/review.ts, src/handlers/review.test.ts</files>
  <action>
Wire Phase 67-01 runtime outcomes into telemetry emission:

- Capture cache-hit and retry/degradation counters from Search enrichment execution.
- Compute and record OPS-03 metrics (`cacheHitRate`, `skippedQueries`, `retryAttempts`, `degradationPath`) through the new telemetry store method.
- Keep telemetry emission guarded by `config.telemetry.enabled` and fail-open (never block review completion if telemetry write fails).
- Add handler regressions for:
  1) Normal non-degraded path metric values
  2) Rate-limited degraded path metric values
  3) Telemetry write failure still allowing successful review completion

Avoid duplicating existing telemetry records; this is an additive metric path specifically for Search rate-limit behavior.
  </action>
  <verify>
Run `bun test src/handlers/review.test.ts --timeout 30000`.
Run `bun test src/telemetry/store.test.ts --timeout 30000`.
Run `bunx tsc --noEmit`.
  </verify>
  <done>
Review executions emit query-level rate-limit telemetry that operators can use to evaluate cache effectiveness and degradation frequency without impacting run success.
  </done>
</task>

</tasks>

<verification>
- `bun test src/telemetry/store.test.ts --timeout 30000` passes with new rate-limit telemetry coverage.
- `bun test src/handlers/review.test.ts --timeout 30000` passes with OPS-03 metric assertions.
- `bunx tsc --noEmit` passes.
- Rate-limit telemetry writes are non-blocking and do not alter existing execution success/failure semantics.
</verification>

<success_criteria>
OPS-03 is satisfied: production telemetry captures cache hit rate, skipped queries, retry attempts, and degradation path for Search rate-limit handling in review execution.
</success_criteria>

<output>
After completion, create `.planning/phases/67-rate-limit-resilience-telemetry/67-02-SUMMARY.md`
</output>
