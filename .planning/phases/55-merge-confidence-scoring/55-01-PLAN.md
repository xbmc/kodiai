---
phase: 55-merge-confidence-scoring
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/lib/merge-confidence.ts
  - src/lib/merge-confidence.test.ts
autonomous: true

must_haves:
  truths:
    - "computeMergeConfidence returns high for patch bump with no advisories and no breaking changes"
    - "computeMergeConfidence returns low for major bump with critical/high advisory"
    - "computeMergeConfidence returns low for major bump with confirmed breaking changes in changelog"
    - "computeMergeConfidence returns medium for major bump without critical advisories"
    - "Security-motivated bumps (isSecurityBump=true) do not downgrade confidence for advisory presence"
    - "Null enrichment data adds 'unavailable' rationale and does not crash"
    - "Group bumps with limited signals produce medium confidence with appropriate rationale"
  artifacts:
    - path: "src/lib/merge-confidence.ts"
      provides: "computeMergeConfidence pure function, MergeConfidence and MergeConfidenceLevel types"
      exports: ["computeMergeConfidence", "MergeConfidence", "MergeConfidenceLevel"]
    - path: "src/lib/merge-confidence.test.ts"
      provides: "Comprehensive test coverage for all scoring rule combinations"
      min_lines: 80
  key_links:
    - from: "src/lib/merge-confidence.ts"
      to: "src/lib/dep-bump-detector.ts"
      via: "imports DepBumpContext type"
      pattern: "import.*DepBumpContext.*dep-bump-detector"
---

<objective>
Create the `computeMergeConfidence` pure function that maps dependency bump signal combinations (semver classification, advisory status, breaking change detection) to a categorical confidence level (high/medium/low) with rationale strings.

Purpose: CONF-01 requires a composite merge confidence score from semver analysis, advisory status, and breaking change signals. This function is the scoring engine.
Output: `src/lib/merge-confidence.ts` with exported types and function, `src/lib/merge-confidence.test.ts` with full coverage.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/55-merge-confidence-scoring/55-RESEARCH.md
@src/lib/dep-bump-detector.ts
@src/lib/dep-bump-enrichment.ts
</context>

<feature>
  <name>Merge Confidence Scoring Function</name>
  <files>src/lib/merge-confidence.ts, src/lib/merge-confidence.test.ts</files>
  <behavior>
    The function accepts a `DepBumpContext` and returns `{ level: MergeConfidenceLevel, rationale: string[] }`.

    Scoring rules (starts at "high", downgrades based on signals):

    Semver signal:
    - patch → stay high, rationale: "Patch version bump (bug fix only)"
    - minor → stay high, rationale: "Minor version bump (backward-compatible)"
    - major → downgrade to medium, rationale: "Major version bump (potential breaking changes)"
    - unknown → downgrade to medium, rationale: "Version change could not be classified"

    Advisory signal (from ctx.security):
    - isSecurityBump=true → positive signal, rationale: "Security-motivated bump (patches known vulnerability)". Do NOT downgrade for advisory presence when this is true.
    - advisories.length > 0 AND NOT isSecurityBump:
      - max severity critical or high → downgrade to low, rationale: "{severity}-severity advisory affects this package"
      - max severity medium or low → downgrade one level (high→medium), rationale: "Security advisories exist for this package"
    - advisories.length === 0 (enrichment succeeded, no advisories) → rationale: "No known security advisories"
    - security === null (enrichment failed) → rationale: "Security advisory data unavailable"
    - security === undefined (enrichment not attempted, e.g. group bump) → no rationale added for security

    Breaking change signal (from ctx.changelog):
    - breakingChanges.length > 0 → downgrade one level (high→medium), rationale: "{N} breaking change(s) detected in changelog"
      - If isBreaking is also true (major + confirmed breaking) → downgrade to low
    - breakingChanges.length === 0 AND source !== "compare-url-only" → rationale: "No breaking changes detected in changelog"
    - changelog === null or undefined → no changelog rationale

    Helper: `getMaxAdvisorySeverity(advisories)` returns the highest severity from ["critical", "high", "medium", "low", "unknown"].

    Test cases:
    - patch + no advisories + no breaking → high, 3 rationale items
    - minor + no advisories + no breaking → high
    - major + no advisories + no breaking → medium
    - unknown bump + no enrichment → medium
    - patch + critical advisory → low
    - patch + medium advisory → medium
    - major + critical advisory → low
    - major + confirmed breaking changes → low
    - minor + 2 breaking changes (isBreaking=false) → medium
    - security-motivated bump (isSecurityBump=true) with advisories → high (not downgraded)
    - security null (enrichment failed) → adds "unavailable" rationale
    - security undefined (group bump) → no security rationale added
    - group bump (isGroup=true, bumpType=unknown, no enrichment) → medium with "Group update" or "Version change could not be classified"
    - changelog with source "compare-url-only" and no breaking → no "No breaking changes" rationale
  </behavior>
  <implementation>
    Export types `MergeConfidenceLevel = "high" | "medium" | "low"` and `MergeConfidence = { level: MergeConfidenceLevel; rationale: string[] }`.

    Export function `computeMergeConfidence(ctx: DepBumpContext): MergeConfidence` implementing the rules above.

    Keep the function under 50 lines. Use a local `getMaxAdvisorySeverity` helper (not exported) with severity ordering: critical > high > medium > low > unknown.

    Follow existing code patterns: use TypeScript strict types, import `DepBumpContext` from `./dep-bump-detector.ts` using type-only import.

    Tests use vitest. Follow the pattern in `src/lib/dep-bump-detector.test.ts` (describe blocks, factory helpers for building test contexts).

    Create a `makeCtx` helper in the test file that builds a minimal valid `DepBumpContext` with all required fields, allowing overrides. This keeps test cases concise.
  </implementation>
</feature>

<verification>
- `bun test src/lib/merge-confidence.test.ts` passes all tests
- All 14+ test cases cover the matrix described in behavior section
- `bunx tsc --noEmit` succeeds (type checking)
</verification>

<success_criteria>
- computeMergeConfidence is a pure function with no side effects
- All scoring rules from research produce the documented confidence level
- Security-motivated bumps are correctly treated as positive signals
- Null/undefined enrichment data is handled without crashes or misleading output
- Types are exported for use by plan 55-02
</success_criteria>

<output>
After completion, create `.planning/phases/55-merge-confidence-scoring/55-01-SUMMARY.md`
</output>
