---
phase: 52-intelligent-retrieval
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/learning/retrieval-query.ts
  - src/learning/retrieval-query.test.ts
  - src/learning/retrieval-rerank.ts
  - src/learning/retrieval-rerank.test.ts
  - src/learning/types.ts
autonomous: true

must_haves:
  truths:
    - "buildRetrievalQuery produces a query string incorporating PR title, body excerpt, conventional type, languages, risk signals, author tier, and file paths"
    - "buildRetrievalQuery caps output length to ~800 chars to avoid embedding quality degradation"
    - "rerankByLanguage boosts same-language results and penalizes cross-language results by adjustable factors"
    - "rerankByLanguage treats Unknown-language records as neutral (no boost, no penalty)"
    - "rerankByLanguage re-sorts results by adjusted distance after applying multipliers"
  artifacts:
    - path: "src/learning/retrieval-query.ts"
      provides: "Multi-signal retrieval query builder"
      exports: ["buildRetrievalQuery", "RetrievalQuerySignals"]
    - path: "src/learning/retrieval-query.test.ts"
      provides: "Unit tests for query builder"
      contains: "buildRetrievalQuery"
    - path: "src/learning/retrieval-rerank.ts"
      provides: "Language-aware post-retrieval re-ranker"
      exports: ["rerankByLanguage", "RerankConfig", "DEFAULT_RERANK_CONFIG", "RerankedResult"]
    - path: "src/learning/retrieval-rerank.test.ts"
      provides: "Unit tests for re-ranker"
      contains: "rerankByLanguage"
    - path: "src/learning/types.ts"
      provides: "Extended types for retrieval query signals"
  key_links:
    - from: "src/learning/retrieval-rerank.ts"
      to: "src/execution/diff-analysis.ts"
      via: "import classifyFileLanguage"
      pattern: "classifyFileLanguage"
---

<objective>
Build and test two pure functions: `buildRetrievalQuery()` for multi-signal query construction (RET-01) and `rerankByLanguage()` for post-retrieval language-aware re-ranking (RET-02).

Purpose: These are the core logic units for Phase 52. Both are pure functions with defined I/O, making them ideal TDD candidates. Building them first with full test coverage ensures correctness before integration.

Output: Two tested modules (`retrieval-query.ts`, `retrieval-rerank.ts`) and extended types in `types.ts`.
</objective>

<execution_context>
@/home/keith/.claude/get-shit-done/workflows/execute-plan.md
@/home/keith/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-intelligent-retrieval/52-RESEARCH.md
@src/learning/types.ts
@src/execution/diff-analysis.ts
@src/learning/memory-store.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD buildRetrievalQuery — multi-signal query construction</name>
  <files>
    src/learning/retrieval-query.ts
    src/learning/retrieval-query.test.ts
  </files>
  <action>
**RED phase:** Create `src/learning/retrieval-query.test.ts` with tests for `buildRetrievalQuery()`:

1. **Minimal input** — only `prTitle` and empty arrays → returns just the title
2. **Full signals** — all fields populated → query includes title, body excerpt, `[feat]` type tag, `Languages: TypeScript, Python`, `Risk: ...` signals, `Author: first-time`, and file paths
3. **Body truncation** — 500-char body → only first ~200 chars included
4. **Language cap** — 8 detected languages → only first 5 included
5. **Risk signal cap** — 6 risk signals → only first 3 included
6. **File path cap** — 25 file paths → only first 15 included
7. **Total length cap** — very long inputs → output capped at ~800 chars (truncate from the bottom, keeping title + higher-priority signals)
8. **Null/undefined conventional type** — omitted from output
9. **Empty body string** — not added to output

Define the `RetrievalQuerySignals` type inline in the test file initially (will move to module).

Run tests → all MUST FAIL (module doesn't exist yet).

**GREEN phase:** Create `src/learning/retrieval-query.ts`:

```typescript
export type RetrievalQuerySignals = {
  prTitle: string;
  prBody?: string;
  conventionalType?: string | null;
  detectedLanguages: string[];
  riskSignals: string[];
  authorTier?: string;
  topFilePaths: string[];
};

export function buildRetrievalQuery(signals: RetrievalQuerySignals): string {
  // Build parts array in priority order:
  // 1. PR title (always)
  // 2. Body excerpt (first 200 chars, if present and non-empty)
  // 3. Conventional type tag in brackets (if present)
  // 4. Languages line (first 5, if any)
  // 5. Risk line (first 3, if any)
  // 6. Author tier (if present)
  // 7. File paths (first 15, newline-separated)
  //
  // After joining with "\n", if total length > 800, truncate to 800.
  // This prevents embedding quality degradation per research pitfall 1.
}
```

Run tests → all MUST PASS.

**REFACTOR:** Clean up if needed. Ensure exports are clean.
  </action>
  <verify>Run `bun test src/learning/retrieval-query.test.ts` — all tests pass.</verify>
  <done>
    - `buildRetrievalQuery()` exported from `src/learning/retrieval-query.ts`
    - 9+ test cases covering all signal types, caps, and edge cases
    - Query length never exceeds 800 characters
    - Missing/null signals gracefully omitted
  </done>
</task>

<task type="auto">
  <name>Task 2: TDD rerankByLanguage — post-retrieval language-aware re-ranking</name>
  <files>
    src/learning/retrieval-rerank.ts
    src/learning/retrieval-rerank.test.ts
    src/learning/types.ts
  </files>
  <action>
**RED phase:** Create `src/learning/retrieval-rerank.test.ts` with tests for `rerankByLanguage()`:

1. **Same-language boost** — TypeScript PR with TypeScript finding (`.ts` filePath) → `adjustedDistance = distance * 0.85`, `languageMatch: true`
2. **Cross-language penalty** — TypeScript PR with Python finding (`.py` filePath) → `adjustedDistance = distance * 1.15`, `languageMatch: false`
3. **Unknown language neutral** — finding with `.json` or unknown extension filePath → `adjustedDistance = distance * 1.0` (no boost, no penalty). This prevents config/docs files from being demoted per research pitfall 4.
4. **Re-sort order** — mixed results → sorted by `adjustedDistance` ascending after re-ranking
5. **Custom config** — pass custom `sameLanguageBoost: 0.7, crossLanguagePenalty: 1.3` → factors applied correctly
6. **Empty results** — empty array in → empty array out (no crash)
7. **Ordering change** — a cross-language result with distance 0.10 should still beat a same-language result with distance 0.25 (language is tiebreaker, not dominant factor)
8. **Multiple PR languages** — PR with both TypeScript and Python → findings in either language get the boost

Use `RetrievalResult` from `src/learning/types.ts` for input shape. Create mock `LearningMemoryRecord` objects with appropriate `filePath` extensions.

Run tests → all MUST FAIL.

**GREEN phase:** Create `src/learning/retrieval-rerank.ts`:

```typescript
import { classifyFileLanguage } from "../execution/diff-analysis.ts";
import type { RetrievalResult } from "./types.ts";

export type RerankConfig = {
  sameLanguageBoost: number;   // < 1.0 = boost (lower distance = better). Default 0.85
  crossLanguagePenalty: number; // > 1.0 = penalize. Default 1.15
};

export const DEFAULT_RERANK_CONFIG: RerankConfig = {
  sameLanguageBoost: 0.85,
  crossLanguagePenalty: 1.15,
};

export type RerankedResult = RetrievalResult & {
  adjustedDistance: number;
  languageMatch: boolean;
};

export function rerankByLanguage(params: {
  results: RetrievalResult[];
  prLanguages: string[];
  config?: RerankConfig;
}): RerankedResult[] {
  // 1. For each result, classify its language from record.filePath using classifyFileLanguage()
  // 2. If language is "Unknown" → multiplier = 1.0 (neutral)
  // 3. If language matches any prLanguage → multiplier = config.sameLanguageBoost
  // 4. Otherwise → multiplier = config.crossLanguagePenalty
  // 5. adjustedDistance = distance * multiplier
  // 6. Sort by adjustedDistance ascending
  // 7. Return RerankedResult[]
}
```

Run tests → all MUST PASS.

**REFACTOR:** No need to extend `src/learning/types.ts` — the `RerankedResult` type extends `RetrievalResult` directly in the rerank module. Keep types co-located with the function that produces them.
  </action>
  <verify>Run `bun test src/learning/retrieval-rerank.test.ts` — all tests pass. Then run `bun test src/learning/` to confirm no regressions in existing memory-store tests.</verify>
  <done>
    - `rerankByLanguage()` exported from `src/learning/retrieval-rerank.ts`
    - `RerankConfig`, `DEFAULT_RERANK_CONFIG`, `RerankedResult` exported
    - 8+ test cases covering boost, penalty, neutral, re-sort, custom config, edge cases
    - Unknown-language records treated as neutral (multiplier 1.0)
    - Language is a tiebreaker, not a dominant ranking factor
  </done>
</task>

</tasks>

<verification>
1. `bun test src/learning/retrieval-query.test.ts` — all pass
2. `bun test src/learning/retrieval-rerank.test.ts` — all pass
3. `bun test src/learning/` — all pass (including existing memory-store tests)
4. `buildRetrievalQuery` with all signals produces a query under 800 chars
5. `rerankByLanguage` with mixed-language results re-orders by adjusted distance
</verification>

<success_criteria>
- Two new pure-function modules with full test coverage
- buildRetrievalQuery handles all signal types with graceful degradation
- rerankByLanguage applies mild language preference without distorting relevance
- All existing learning tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/52-intelligent-retrieval/52-01-SUMMARY.md`
</output>
