---
phase: 109-issue-corpus-retrieval-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/knowledge/issue-retrieval.ts
  - src/knowledge/cross-corpus-rrf.ts
  - src/knowledge/retrieval.ts
  - src/knowledge/index.ts
  - src/index.ts
autonomous: true
requirements: [PRLINK-04]

must_haves:
  truths:
    - "Issue results appear alongside code, review_comment, wiki, and snippet results in unified RRF retrieval"
    - "Issue citations use [issue: #N] Title (status) format in sourceLabel"
    - "Issue corpus is weighted per trigger type: pr_review=0.8, issue=1.5, question=1.2, slack=1.0"
    - "Both vector and BM25 search are used for issues (hybrid search)"
    - "Missing issueStore does not break the retrieval pipeline (fail-open)"
  artifacts:
    - path: "src/knowledge/issue-retrieval.ts"
      provides: "searchIssues() function and IssueKnowledgeMatch type"
      exports: ["searchIssues", "IssueKnowledgeMatch"]
    - path: "src/knowledge/cross-corpus-rrf.ts"
      provides: "Extended SourceType union including 'issue'"
      contains: '"issue"'
    - path: "src/knowledge/retrieval.ts"
      provides: "issueMatchToUnified normalizer, issue fan-out slots, hybrid merge, dedup, SOURCE_WEIGHTS with issue key, issueStore dep, issueCount provenance"
    - path: "src/knowledge/index.ts"
      provides: "Re-exports for searchIssues and IssueKnowledgeMatch"
    - path: "src/index.ts"
      provides: "issueStore passed to createRetriever()"
  key_links:
    - from: "src/knowledge/issue-retrieval.ts"
      to: "src/knowledge/issue-types.ts"
      via: "IssueStore.searchByEmbedding()"
      pattern: "store\\.searchByEmbedding"
    - from: "src/knowledge/retrieval.ts"
      to: "src/knowledge/issue-retrieval.ts"
      via: "searchIssues() call in fan-out"
      pattern: "searchIssues"
    - from: "src/knowledge/retrieval.ts"
      to: "src/knowledge/hybrid-search.ts"
      via: "hybridSearchMerge for issue vector + BM25"
      pattern: "hybridSearchMerge.*issue"
    - from: "src/index.ts"
      to: "src/knowledge/retrieval.ts"
      via: "issueStore passed to createRetriever"
      pattern: "issueStore"
---

<objective>
Wire the issue corpus into the unified cross-corpus retrieval pipeline so that PR reviews, @mention responses, and Slack queries can find and cite related issues via hybrid (vector + BM25) search.

Purpose: Issues are already ingested (phase 106) and linked to PRs (phase 108). This plan makes issue knowledge discoverable through the same retrieval pipeline all other corpora use, completing the issue intelligence story.

Output: Issue results appear in unified retrieval alongside code, review comments, wiki pages, and snippets -- with `[issue: #N] Title (status)` citations and per-trigger weight tuning.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/109-issue-corpus-retrieval-integration/109-CONTEXT.md
@.planning/109-issue-corpus-retrieval-integration/109-RESEARCH.md

@src/knowledge/retrieval.ts
@src/knowledge/cross-corpus-rrf.ts
@src/knowledge/issue-types.ts
@src/knowledge/wiki-retrieval.ts
@src/knowledge/hybrid-search.ts
@src/knowledge/index.ts
@src/index.ts

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/knowledge/issue-types.ts:
```typescript
export type IssueSearchResult = {
  record: IssueRecord;
  distance: number;
};

export type IssueStore = {
  searchByEmbedding(params: {
    queryEmbedding: Float32Array;
    repo: string;
    topK: number;
  }): Promise<IssueSearchResult[]>;

  searchByFullText(params: {
    query: string;
    repo: string;
    topK: number;
  }): Promise<IssueSearchResult[]>;
  // ... other methods
};
```

From src/knowledge/cross-corpus-rrf.ts:
```typescript
export type SourceType = "code" | "review_comment" | "wiki" | "snippet";
// Must become: "code" | "review_comment" | "wiki" | "snippet" | "issue"

export type UnifiedRetrievalChunk = {
  id: string;
  text: string;
  source: SourceType;
  sourceLabel: string;
  sourceUrl: string | null;
  vectorDistance: number | null;
  rrfScore: number;
  createdAt: string | null;
  metadata: Record<string, unknown>;
};
```

From src/knowledge/retrieval.ts:
```typescript
export function createRetriever(deps: {
  embeddingProvider: EmbeddingProvider;
  isolationLayer: IsolationLayer;
  config: RetrieverConfig;
  reviewCommentStore?: ReviewCommentStore;
  wikiPageStore?: WikiPageStore;
  memoryStore?: LearningMemoryStore;
  codeSnippetStore?: CodeSnippetStore;
  // Must add: issueStore?: IssueStore;
}): { retrieve: (opts: RetrieveOptions) => Promise<RetrieveResult | null> }

// SOURCE_WEIGHTS at line 98:
const SOURCE_WEIGHTS: Record<TriggerType, Record<string, number>> = {
  pr_review: { code: 1.2, review_comment: 1.2, wiki: 1.0, snippet: 1.1 },
  issue: { code: 1.0, review_comment: 1.0, wiki: 1.2, snippet: 0.8 },
  question: { code: 1.0, review_comment: 1.0, wiki: 1.2, snippet: 0.8 },
  slack: { code: 1.0, review_comment: 1.0, wiki: 1.0, snippet: 1.0 },
};
```

From src/index.ts (line 204):
```typescript
const issueStore = createIssueStore({ sql, logger });
// Already exists but NOT passed to createRetriever() at line 216
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create issue-retrieval.ts search module and extend SourceType</name>
  <files>src/knowledge/issue-retrieval.ts, src/knowledge/cross-corpus-rrf.ts, src/knowledge/index.ts</files>
  <action>
**1a. Create `src/knowledge/issue-retrieval.ts`** following the exact pattern from `wiki-retrieval.ts`:

- Define `IssueKnowledgeMatch` type with fields: `chunkText`, `distance`, `repo`, `issueNumber`, `title`, `state`, `authorLogin`, `githubCreatedAt`, `source: "issue"`.
- Implement `searchIssues()` with signature matching wiki pattern: accepts `{ store: IssueStore, embeddingProvider: EmbeddingProvider, query: string, repo: string, topK: number, distanceThreshold?: number, logger: Logger }`.
- Generate query embedding via `embeddingProvider.generate(query, "query")`. If null, return [] (fail-open).
- Call `store.searchByEmbedding({ queryEmbedding, repo, topK })`.
- Filter results by distance threshold (default 0.7).
- Map each `IssueSearchResult` to `IssueKnowledgeMatch`:
  - `chunkText`: `` `#${r.record.issueNumber} ${r.record.title}\n\n${(r.record.body ?? "").slice(0, 2000)}` ``
  - `distance`: `r.distance`
  - `repo`: `r.record.repo`
  - Other fields from `r.record`
  - `source: "issue" as const`
- Export both `IssueKnowledgeMatch` type and `searchIssues` function.

See research RESEARCH.md "Complete Issue Search Module" for full code example.

**1b. Extend SourceType** in `src/knowledge/cross-corpus-rrf.ts` line 9:
- Change from: `export type SourceType = "code" | "review_comment" | "wiki" | "snippet";`
- Change to: `export type SourceType = "code" | "review_comment" | "wiki" | "snippet" | "issue";`

**1c. Add re-exports** to `src/knowledge/index.ts`:
- Add after the existing "Code snippet retrieval" block (around line 90):
```typescript
// Issue retrieval
export { searchIssues, type IssueKnowledgeMatch } from "./issue-retrieval.ts";
```
  </action>
  <verify>npx tsc --noEmit 2>&1 | head -20 (should compile clean with new SourceType and module)</verify>
  <done>issue-retrieval.ts exists with searchIssues() and IssueKnowledgeMatch exports, SourceType includes "issue", index.ts re-exports both</done>
</task>

<task type="auto">
  <name>Task 2: Wire issue search into retrieval pipeline and application bootstrap</name>
  <files>src/knowledge/retrieval.ts, src/index.ts</files>
  <action>
**2a. Add imports** to `src/knowledge/retrieval.ts` (near existing searchWikiPages/searchReviewComments imports around line 14):
```typescript
import { searchIssues, type IssueKnowledgeMatch } from "./issue-retrieval.ts";
import type { IssueStore } from "./issue-types.ts";
```

**2b. Add `issue` to SOURCE_WEIGHTS** (line 98-103). Per locked decisions:
```typescript
const SOURCE_WEIGHTS: Record<TriggerType, Record<string, number>> = {
  pr_review: { code: 1.2, review_comment: 1.2, wiki: 1.0, snippet: 1.1, issue: 0.8 },
  issue: { code: 1.0, review_comment: 1.0, wiki: 1.2, snippet: 0.8, issue: 1.5 },
  question: { code: 1.0, review_comment: 1.0, wiki: 1.2, snippet: 0.8, issue: 1.2 },
  slack: { code: 1.0, review_comment: 1.0, wiki: 1.0, snippet: 1.0, issue: 1.0 },
};
```

**2c. Add `issueMatchToUnified` normalizer** (after `snippetToUnified` function, around line 260). Follow the `reviewMatchToUnified` pattern at line 186:
```typescript
function issueMatchToUnified(match: IssueKnowledgeMatch, repo: string): UnifiedRetrievalChunk {
  return {
    id: `issue:${repo}:${match.issueNumber}:${match.distance}`,
    text: match.chunkText,
    source: "issue",
    sourceLabel: `[issue: #${match.issueNumber}] ${match.title} (${match.state})`,
    sourceUrl: `https://github.com/${repo}/issues/${match.issueNumber}`,
    vectorDistance: match.distance,
    rrfScore: 0,
    createdAt: match.githubCreatedAt,
    metadata: {
      issueNumber: match.issueNumber,
      title: match.title,
      state: match.state,
      authorLogin: match.authorLogin,
    },
  };
}
```

**2d. Add `issueStore?: IssueStore`** to createRetriever deps parameter (line 327-335):
```typescript
export function createRetriever(deps: {
  embeddingProvider: EmbeddingProvider;
  isolationLayer: IsolationLayer;
  config: RetrieverConfig;
  reviewCommentStore?: ReviewCommentStore;
  wikiPageStore?: WikiPageStore;
  memoryStore?: LearningMemoryStore;
  codeSnippetStore?: CodeSnippetStore;
  issueStore?: IssueStore;
}): ...
```

**2e. Add issue vector + BM25 fan-out slots** to the Promise.allSettled array (after slot (g) snippetVectorResult, before the closing `]`). Add 2 new entries:
```typescript
// (h) Issue vector search
deps.issueStore
  ? searchIssues({
      store: deps.issueStore,
      embeddingProvider: deps.embeddingProvider,
      query: intentQuery,
      repo: opts.repo,
      topK: 5,
      logger: opts.logger,
    })
  : Promise.resolve([] as IssueKnowledgeMatch[]),
// (i) Issue BM25 full-text search
deps.issueStore?.searchByFullText
  ? deps.issueStore.searchByFullText({
      query: intentQuery,
      repo: opts.repo,
      topK: 5,
    })
  : Promise.resolve([]),
```
Update the destructuring to add `issueVectorResult, issueFullTextResult` after `snippetVectorResult`.

**2f. Extract settled issue results** (after existing extraction block ~line 458):
```typescript
const issueResults =
  issueVectorResult.status === "fulfilled" ? issueVectorResult.value : [];
```
Add failure logging matching existing pattern for issue searches.

**2g. Normalize + hybrid merge for issues** (after step 6b wiki hybrid, ~line 618). Follow the exact review/wiki hybrid pattern:
- Normalize vector results: `const issueChunks = issueResults.map((m) => issueMatchToUnified(m, opts.repo));`
- Normalize BM25 results: Extract from `issueFullTextResult`, map through `issueMatchToUnified` using the same `IssueSearchResult` record extraction pattern used by review/wiki BM25 normalization.
- Hybrid merge: `hybridSearchMerge({ vectorResults: issueChunks, bm25Results: issueBm25, getKey: (c) => c.id, k: RRF_K })`

**2h. Add within-corpus dedup** (after dedupedSnippets, ~line 644):
```typescript
const dedupedIssues = deduplicateChunks({
  chunks: hybridIssue.map((h) => h.item),
  similarityThreshold: DEDUP_THRESHOLD,
  mode: "within-corpus",
});
```

**2i. Add to sourceLists** (after the snippet block, ~line 658):
```typescript
if (dedupedIssues.length > 0) {
  sourceLists.push({ source: "issue", items: dedupedIssues });
}
```

**2j. Add `issueCount` to provenance** (line 737 area, after `snippetCount`):
```typescript
issueCount: issueResults.length,
```

**2k. Wire issueStore in `src/index.ts`** at line 216-235 (the createRetriever call):
Add `issueStore,` after `codeSnippetStore,` (line 234).

Do NOT update assembleContextWindow's missing corpora check -- issues are a supplementary corpus and their absence is not noteworthy (per research pitfall 3 guidance).
  </action>
  <verify>npx tsc --noEmit 2>&1 | head -20 (should compile clean with all wiring in place)</verify>
  <done>retrieval.ts has issueStore dep, issueMatchToUnified normalizer, issue fan-out (vector + BM25), hybrid merge, dedup, sourceLists entry, SOURCE_WEIGHTS with locked issue weights, and issueCount in provenance. src/index.ts passes issueStore to createRetriever.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles with zero errors
2. Grep confirms SourceType includes "issue": `grep '"issue"' src/knowledge/cross-corpus-rrf.ts`
3. Grep confirms SOURCE_WEIGHTS has issue entries: `grep 'issue:' src/knowledge/retrieval.ts`
4. Grep confirms issueStore in createRetriever: `grep 'issueStore' src/knowledge/retrieval.ts`
5. Grep confirms issueStore wired in index.ts: `grep 'issueStore' src/index.ts`
6. Grep confirms citation format: `grep 'issue: #' src/knowledge/retrieval.ts`
7. Grep confirms re-exports: `grep 'searchIssues' src/knowledge/index.ts`
</verification>

<success_criteria>
- TypeScript compiles cleanly with zero errors
- `src/knowledge/issue-retrieval.ts` exists with searchIssues() exported
- SourceType union includes "issue"
- SOURCE_WEIGHTS has issue key with locked values (0.8, 1.5, 1.2, 1.0)
- createRetriever accepts optional issueStore
- Issue vector + BM25 fan-out slots exist in Promise.allSettled
- Issue results go through hybridSearchMerge, dedup, and into sourceLists
- issueMatchToUnified produces `[issue: #N] Title (status)` sourceLabel
- issueCount in provenance tracking
- issueStore passed in src/index.ts createRetriever call
</success_criteria>

<output>
After completion, create `.planning/109-issue-corpus-retrieval-integration/109-01-SUMMARY.md`
</output>
