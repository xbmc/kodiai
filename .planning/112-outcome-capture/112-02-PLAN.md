---
phase: 112-outcome-capture
plan: 02
type: execute
wave: 2
depends_on: [112-01]
files_modified:
  - src/handlers/issue-opened.ts
  - src/handlers/issue-opened.test.ts
autonomous: true
requirements: [REACT-01]

must_haves:
  truths:
    - "After posting a triage comment, the comment's GitHub ID is stored in issue_triage_state.comment_github_id"
    - "Failure to store comment_github_id does not prevent triage from completing (non-fatal warn)"
    - "The UPDATE targets the correct row via repo + issue_number"
  artifacts:
    - path: "src/handlers/issue-opened.ts"
      provides: "Comment GitHub ID capture after createComment call"
      contains: "comment_github_id"
    - path: "src/handlers/issue-opened.test.ts"
      provides: "Test for comment GitHub ID capture"
      contains: "comment_github_id"
  key_links:
    - from: "src/handlers/issue-opened.ts"
      to: "src/db/migrations/017-issue-outcome-feedback.sql"
      via: "UPDATE issue_triage_state SET comment_github_id"
      pattern: "comment_github_id"
---

<objective>
Capture the GitHub comment ID when a triage comment is posted, storing it in `issue_triage_state.comment_github_id` for future reaction tracking.

Purpose: Phase 114's reaction sync job needs the comment GitHub ID to poll reactions on triage comments. Without this, there is no way to map triage records to their posted comments.

Output: Modified `src/handlers/issue-opened.ts` with comment ID capture, and a new test in `src/handlers/issue-opened.test.ts`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v0.23-ROADMAP.md
@.planning/112-outcome-capture/112-RESEARCH.md
@.planning/112-outcome-capture/112-01-SUMMARY.md

@src/handlers/issue-opened.ts
@src/handlers/issue-opened.test.ts

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/handlers/issue-opened.ts (the createComment call at line 180):
```typescript
// 8. Post comment
await octokit.rest.issues.createComment({
  owner,
  repo: repoName,
  issue_number: issueNumber,
  body: commentBody,
});
```

The createComment response has shape: `{ data: { id: number } }` where `data.id` is the GitHub comment ID (bigint in GitHub, number in JS).

From src/db/migrations/017-issue-outcome-feedback.sql (created in 112-01):
```sql
ALTER TABLE issue_triage_state
  ADD COLUMN IF NOT EXISTS comment_github_id BIGINT;
```

From src/db/migrations/016-issue-triage-state.sql:
```sql
CREATE TABLE IF NOT EXISTS issue_triage_state (
  id BIGSERIAL PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  repo TEXT NOT NULL,
  issue_number INTEGER NOT NULL,
  triaged_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  delivery_id TEXT NOT NULL,
  duplicate_count INTEGER NOT NULL DEFAULT 0,
  UNIQUE(repo, issue_number)
);
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Capture triage comment GitHub ID in issue-opened handler</name>
  <files>src/handlers/issue-opened.ts</files>
  <action>
Modify the `handleIssueOpened` function in `src/handlers/issue-opened.ts` to capture the comment GitHub ID after posting the triage comment.

**Change at line 180** (the createComment call). Currently:

```typescript
// 8. Post comment
await octokit.rest.issues.createComment({
  owner,
  repo: repoName,
  issue_number: issueNumber,
  body: commentBody,
});
```

Change to:

```typescript
// 8. Post comment
const commentResponse = await octokit.rest.issues.createComment({
  owner,
  repo: repoName,
  issue_number: issueNumber,
  body: commentBody,
});

// 8b. Store the comment GitHub ID for future reaction tracking (REACT-01)
try {
  await sql`
    UPDATE issue_triage_state
    SET comment_github_id = ${commentResponse.data.id}
    WHERE repo = ${repo} AND issue_number = ${issueNumber}
  `;
} catch (err) {
  handlerLogger.warn({ err, commentGithubId: commentResponse.data.id }, "Failed to store comment GitHub ID (non-fatal)");
}
```

Key details:
- Capture the return value of `createComment` into `commentResponse`.
- The GitHub comment ID is at `commentResponse.data.id`.
- UPDATE targets the triage state row already claimed in step 4 (Layer 2 idempotency).
- Wrapped in try/catch -- failure to store the comment ID must NOT prevent triage from completing.
- Log at `warn` level on failure (not error -- this is non-critical).
- This goes AFTER the existing comment post (line 180) and BEFORE the label application (line 188).
  </action>
  <verify>
    bun build src/handlers/issue-opened.ts --no-bundle 2>&1 | head -5
  </verify>
  <done>
    createComment return value captured in commentResponse.
    comment_github_id UPDATE runs after comment post, before label application.
    Failure is caught and logged at warn level without throwing.
    Compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add test for comment GitHub ID capture</name>
  <files>src/handlers/issue-opened.test.ts</files>
  <action>
Add a new test to the existing `describe("createIssueOpenedHandler")` block in `src/handlers/issue-opened.test.ts`.

**New test: "stores comment GitHub ID after posting triage comment"**

This test verifies that after posting a triage comment, the handler updates `issue_triage_state.comment_github_id` with the ID from the API response.

Setup:
- Use `createMockWorkspaceManager` with `{ triage: { enabled: true, autoTriageOnOpen: true } as any }`.
- Use `createMockIssueStore` with search results (reuse `makeSearchResult(50, "Similar issue", "open", 0.1)`) so that duplicates are found and a comment is posted.
- Create a custom mock Octokit that returns `{ data: { id: 99887766 } }` from `createComment`.
- Create a custom mock SQL that:
  - On the first call (INSERT for claim): returns `[{ id: 1 }]` (claim succeeds).
  - Tracks all subsequent calls in a `sqlCalls` array, capturing the template strings and values.
  - Returns empty arrays for UPDATE calls (both the duplicate_count update and the comment_github_id update).

Assertions:
- Verify at least one SQL call contains the string "comment_github_id" in its template.
- Verify the call includes the value `99887766` (the comment ID from the mock response).

To create the tracking SQL mock, extend the existing `createMockSql` pattern:

```typescript
const sqlCalls: Array<{ strings: string[]; values: unknown[] }> = [];
let callCount = 0;
const mockSql = new Proxy(
  (...args: any[]) => {
    callCount++;
    if (callCount === 1) {
      // First call is the INSERT claim
      return Promise.resolve([{ id: 1 }]);
    }
    // Subsequent calls: track and return empty
    if (Array.isArray(args[0]) && typeof args[0][0] === "string") {
      sqlCalls.push({ strings: args[0], values: args.slice(1) });
    }
    return Promise.resolve([]);
  },
  { apply: (_target, _thisArg, args) => { /* same logic */ } },
) as unknown as Sql;
```

Then assert:
```typescript
const commentIdCall = sqlCalls.find((c) =>
  c.strings.some((s) => s.includes("comment_github_id"))
);
expect(commentIdCall).toBeDefined();
```

**New test: "continues when comment GitHub ID storage fails"**

Verify that if the UPDATE for `comment_github_id` throws, the handler still continues to apply the label and log completion (fail-open).

Setup similar to above, but make the SQL mock throw on the `comment_github_id` UPDATE call. Verify that `addLabels` is still called (label application happens after comment ID storage).

Note: The existing mock SQL uses a simple Proxy. You may need to adjust the mock to handle tagged template literals properly. The postgres.js tagged template interface passes the template strings array as the first argument (via the Proxy `apply` trap), and interpolated values as subsequent arguments in the tagged template call. The Proxy pattern in the existing tests already handles this.
  </action>
  <verify>
    bun test src/handlers/issue-opened.test.ts
  </verify>
  <done>
    Test verifies comment_github_id is stored after posting triage comment.
    Test verifies handler continues when comment_github_id storage fails (fail-open).
    All existing tests still pass (no regressions).
  </done>
</task>

</tasks>

<verification>
1. `bun build src/handlers/issue-opened.ts --no-bundle` -- compiles clean
2. `bun test src/handlers/issue-opened.test.ts` -- all tests pass (existing + new)
3. Grep confirms `comment_github_id` appears in issue-opened.ts
4. Grep confirms `commentResponse.data.id` in issue-opened.ts
5. Grep confirms the UPDATE is wrapped in try/catch in issue-opened.ts
</verification>

<success_criteria>
- Triage comment's GitHub ID captured from createComment response
- Stored in issue_triage_state.comment_github_id via UPDATE
- Failure to store is non-fatal (warn, not error; does not throw)
- New tests pass alongside all existing tests
- No regressions in existing issue-opened behavior
</success_criteria>

<output>
After completion, create `.planning/112-outcome-capture/112-02-SUMMARY.md`
</output>
